diff -Naur php-src-vanilla/sapi/fpm/ac/fpm_build.m4 php-src/sapi/fpm/ac/fpm_build.m4
--- php-src-vanilla/sapi/fpm/ac/fpm_build.m4	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/ac/fpm_build.m4	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,47 @@
+
+AC_DEFUN([AC_FPM_BUILD_SAPI],
+[
+	PHP_ADD_MAKEFILE_FRAGMENT($abs_srcdir/sapi/fpm/ac/Makefile.frag,$abs_srcdir/sapi/fpm,sapi/fpm)
+
+    SAPI_FPM_PATH=sapi/fpm/$php_fpm_bin
+	PHP_SUBST(SAPI_FPM_PATH)
+	
+	mkdir -p sapi/fpm/cgi
+	PHP_FPM_SAPI_FILES=`cd $abs_srcdir/sapi/fpm && find cgi/ \( -name *.c \) -exec printf "{} " \;`
+	# PHP_FPM_SAPI_FILES="cgi/cgi_main.c cgi/fastcgi.c"
+
+	mkdir -p sapi/fpm/fpm
+	PHP_FPM_CORE_FILES=`cd $abs_srcdir/sapi/fpm && find fpm/ \( -name *.c -not -name fpm_trace*.c \) -exec printf "{} " \;`
+	# PHP_FPM_CORE_FILES="fpm/fpm_process_ctl.c fpm/fpm_signals.c fpm/fpm_shm.c fpm/fpm.c fpm/fpm_worker_pool.c fpm/fpm_clock.c fpm/fpm_env.c fpm/fpm_shm_slots.c fpm/fpm_children.c fpm/fpm_events.c fpm/fpm_php.c fpm/fpm_unix.c fpm/fpm_request.c fpm/fpm_sockets.c fpm/fpm_php_trace.c fpm/zlog.c fpm/fpm_cleanup.c fpm/fpm_conf.c fpm/xml_config.c fpm/fpm_stdio.c"
+
+	if test "$fpm_trace_type" ; then
+		PHP_FPM_TRACE_FILES=`cd $abs_srcdir/sapi/fpm && find fpm/ \( -name fpm_trace.c -or -name fpm_trace_$fpm_trace_type.c \) -exec printf "{} " \;`
+	fi
+	
+	PHP_FPM_CFLAGS="$LIBEVENT_CFLAGS -I$abs_srcdir/sapi/fpm"
+
+	SAPI_EXTRA_LIBS="$LIBEVENT_LIBS"
+	PHP_SUBST(SAPI_EXTRA_LIBS)
+	
+    dnl Set install target and select SAPI
+	INSTALL_IT=":"
+
+    PHP_SELECT_SAPI(fpm, program, $PHP_FPM_SAPI_FILES $PHP_FPM_CORE_FILES $PHP_FPM_TRACE_FILES, $PHP_FPM_CFLAGS, '$(SAPI_FPM_PATH)')
+
+    case $host_alias in
+      *aix*)
+        BUILD_FPM="echo '\#! .' > php.sym && echo >>php.sym && nm -BCpg \`echo \$(PHP_GLOBAL_OBJS) \$(PHP_SAPI_OBJS) | sed 's/\([A-Za-z0-9_]*\)\.lo/\1.o/g'\` | \$(AWK) '{ if (((\$\$2 == \"T\") || (\$\$2 == \"D\") || (\$\$2 == \"B\")) && (substr(\$\$3,1,1) != \".\")) { print \$\$3 } }' | sort -u >> php.sym && \$(LIBTOOL) --mode=link \$(CC) -export-dynamic \$(CFLAGS_CLEAN) \$(EXTRA_CFLAGS) \$(EXTRA_LDFLAGS_PROGRAM) \$(LDFLAGS) -Wl,-brtl -Wl,-bE:php.sym \$(PHP_RPATHS) \$(PHP_GLOBAL_OBJS) \$(PHP_SAPI_OBJS) \$(EXTRA_LIBS) \$(SAPI_EXTRA_LIBS) \$(ZEND_EXTRA_LIBS) -o \$(SAPI_FPM_PATH)"
+        ;;
+      *darwin*)
+        BUILD_FPM="\$(CC) \$(CFLAGS_CLEAN) \$(EXTRA_CFLAGS) \$(EXTRA_LDFLAGS_PROGRAM) \$(LDFLAGS) \$(NATIVE_RPATHS) \$(PHP_GLOBAL_OBJS:.lo=.o) \$(PHP_SAPI_OBJS:.lo=.o) \$(PHP_FRAMEWORKS) \$(EXTRA_LIBS) \$(SAPI_EXTRA_LIBS) \$(ZEND_EXTRA_LIBS) -o \$(SAPI_FPM_PATH)"
+      ;;
+      *)
+        BUILD_FPM="\$(LIBTOOL) --mode=link \$(CC) -export-dynamic \$(CFLAGS_CLEAN) \$(EXTRA_CFLAGS) \$(EXTRA_LDFLAGS_PROGRAM) \$(LDFLAGS) \$(PHP_RPATHS) \$(PHP_GLOBAL_OBJS) \$(PHP_SAPI_OBJS) \$(EXTRA_LIBS) \$(SAPI_EXTRA_LIBS) \$(ZEND_EXTRA_LIBS) -o \$(SAPI_FPM_PATH)"
+      ;;
+    esac
+
+	ENDIF=endif
+	PHP_SUBST(ENDIF)
+    PHP_SUBST(BUILD_FPM)
+
+])
diff -Naur php-src-vanilla/sapi/fpm/ac/fpm_checks.m4 php-src/sapi/fpm/ac/fpm_checks.m4
--- php-src-vanilla/sapi/fpm/ac/fpm_checks.m4	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/ac/fpm_checks.m4	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,299 @@
+dnl
+dnl $Id$
+dnl
+
+AC_DEFUN([AC_FPM_CHECKS],
+[
+	AC_FPM_STDLIBS
+	AC_FPM_PRCTL
+	AC_FPM_CLOCK
+	AC_FPM_TRACE
+])
+
+AC_DEFUN([AC_FPM_STDLIBS],
+[
+	AC_CHECK_FUNCS(setenv clearenv)
+
+	AC_SEARCH_LIBS(socket, socket)
+	AC_SEARCH_LIBS(inet_addr, nsl)
+
+	AC_CHECK_HEADERS([errno.h fcntl.h stdio.h stdlib.h unistd.h sys/uio.h])
+	AC_CHECK_HEADERS([sys/select.h sys/socket.h sys/time.h])
+	AC_CHECK_HEADERS([arpa/inet.h netinet/in.h])
+])
+
+AC_DEFUN([AC_FPM_PRCTL],
+[
+	AC_MSG_CHECKING([for prctl])
+
+	AC_TRY_COMPILE([ #include <sys/prctl.h> ], [prctl(0, 0, 0, 0, 0);], [
+		AC_DEFINE([HAVE_PRCTL], 1, [do we have prctl?])
+		AC_MSG_RESULT([yes])
+	], [
+		AC_MSG_RESULT([no])
+	])
+])
+
+AC_DEFUN([AC_FPM_CLOCK],
+[
+	have_clock_gettime=no
+
+	AC_MSG_CHECKING([for clock_gettime])
+
+	AC_TRY_LINK([ #include <time.h> ], [struct timespec ts; clock_gettime(CLOCK_MONOTONIC, &ts);], [
+		have_clock_gettime=yes
+		AC_MSG_RESULT([yes])
+	], [
+		AC_MSG_RESULT([no])
+	])
+
+	if test "$have_clock_gettime" = "no"; then
+		AC_MSG_CHECKING([for clock_gettime in -lrt])
+
+		SAVED_LIBS="$LIBS"
+		LIBS="$LIBS -lrt"
+
+		AC_TRY_LINK([ #include <time.h> ], [struct timespec ts; clock_gettime(CLOCK_MONOTONIC, &ts);], [
+			have_clock_gettime=yes
+			AC_MSG_RESULT([yes])
+		], [
+			LIBS="$SAVED_LIBS"
+			AC_MSG_RESULT([no])
+		])
+	fi
+
+	if test "$have_clock_gettime" = "yes"; then
+		AC_DEFINE([HAVE_CLOCK_GETTIME], 1, [do we have clock_gettime?])
+	fi
+
+	have_clock_get_time=no
+
+	if test "$have_clock_gettime" = "no"; then
+		AC_MSG_CHECKING([for clock_get_time])
+
+		AC_TRY_RUN([ #include <mach/mach.h>
+			#include <mach/clock.h>
+			#include <mach/mach_error.h>
+
+			int main()
+			{
+				kern_return_t ret; clock_serv_t aClock; mach_timespec_t aTime;
+				ret = host_get_clock_service(mach_host_self(), REALTIME_CLOCK, &aClock);
+
+				if (ret != KERN_SUCCESS) {
+					return 1;
+				}
+
+				ret = clock_get_time(aClock, &aTime);
+				if (ret != KERN_SUCCESS) {
+					return 2;
+				}
+
+				return 0;
+			}
+		], [
+			have_clock_get_time=yes
+			AC_MSG_RESULT([yes])
+		], [
+			AC_MSG_RESULT([no])
+		])
+	fi
+
+	if test "$have_clock_get_time" = "yes"; then
+		AC_DEFINE([HAVE_CLOCK_GET_TIME], 1, [do we have clock_get_time?])
+	fi
+])
+
+AC_DEFUN([AC_FPM_TRACE],
+[
+	have_ptrace=no
+	have_broken_ptrace=no
+
+	AC_MSG_CHECKING([for ptrace])
+
+	AC_TRY_COMPILE([
+		#include <sys/types.h>
+		#include <sys/ptrace.h> ], [ptrace(0, 0, (void *) 0, 0);], [
+		have_ptrace=yes
+		AC_MSG_RESULT([yes])
+	], [
+		AC_MSG_RESULT([no])
+	])
+
+	if test "$have_ptrace" = "yes"; then
+		AC_MSG_CHECKING([whether ptrace works])
+
+		AC_TRY_RUN([
+			#include <unistd.h>
+			#include <signal.h>
+			#include <sys/wait.h>
+			#include <sys/types.h>
+			#include <sys/ptrace.h>
+			#include <errno.h>
+
+			#if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
+			#define PTRACE_ATTACH PT_ATTACH
+			#endif
+
+			#if !defined(PTRACE_DETACH) && defined(PT_DETACH)
+			#define PTRACE_DETACH PT_DETACH
+			#endif
+
+			#if !defined(PTRACE_PEEKDATA) && defined(PT_READ_D)
+			#define PTRACE_PEEKDATA PT_READ_D
+			#endif
+
+			int main()
+			{
+				long v1 = (unsigned int) -1; /* copy will fail if sizeof(long) == 8 and we've got "int ptrace()" */
+				long v2;
+				pid_t child;
+				int status;
+
+				if ( (child = fork()) ) { /* parent */
+					int ret = 0;
+
+					if (0 > ptrace(PTRACE_ATTACH, child, 0, 0)) {
+						return 1;
+					}
+
+					waitpid(child, &status, 0);
+
+			#ifdef PT_IO
+					struct ptrace_io_desc ptio = {
+						.piod_op = PIOD_READ_D,
+						.piod_offs = &v1,
+						.piod_addr = &v2,
+						.piod_len = sizeof(v1)
+					};
+
+					if (0 > ptrace(PT_IO, child, (void *) &ptio, 0)) {
+						ret = 1;
+					}
+			#else
+					errno = 0;
+
+					v2 = ptrace(PTRACE_PEEKDATA, child, (void *) &v1, 0);
+
+					if (errno) {
+						ret = 1;
+					}
+			#endif
+					ptrace(PTRACE_DETACH, child, (void *) 1, 0);
+
+					kill(child, SIGKILL);
+
+					return ret ? ret : (v1 != v2);
+				}
+				else { /* child */
+					sleep(10);
+					return 0;
+				}
+			}
+		], [
+			AC_MSG_RESULT([yes])
+		], [
+			have_ptrace=no
+			have_broken_ptrace=yes
+			AC_MSG_RESULT([no])
+		])
+	fi
+
+	if test "$have_ptrace" = "yes"; then
+		AC_DEFINE([HAVE_PTRACE], 1, [do we have ptrace?])
+	fi
+
+	have_mach_vm_read=no
+
+	if test "$have_broken_ptrace" = "yes"; then
+		AC_MSG_CHECKING([for mach_vm_read])
+
+		AC_TRY_COMPILE([ #include <mach/mach.h>
+			#include <mach/mach_vm.h>
+		], [
+			mach_vm_read((vm_map_t)0, (mach_vm_address_t)0, (mach_vm_size_t)0, (vm_offset_t *)0, (mach_msg_type_number_t*)0);
+		], [
+			have_mach_vm_read=yes
+			AC_MSG_RESULT([yes])
+		], [
+			AC_MSG_RESULT([no])
+		])
+	fi
+
+	if test "$have_mach_vm_read" = "yes"; then
+		AC_DEFINE([HAVE_MACH_VM_READ], 1, [do we have mach_vm_read?])
+	fi
+
+	proc_mem_file=""
+
+	if test -r /proc/$$/mem ; then
+		proc_mem_file="mem"
+	else
+		if test -r /proc/$$/as ; then
+			proc_mem_file="as"
+		fi
+	fi
+
+	if test -n "$proc_mem_file" ; then
+		AC_MSG_CHECKING([for proc mem file])
+	
+		AC_TRY_RUN([
+			#define _GNU_SOURCE
+			#define _FILE_OFFSET_BITS 64
+			#if HAVE_INTTYPES_H
+			#include <inttypes.h>
+			#else
+			#include <stdint.h>
+			#endif
+
+			#include <unistd.h>
+			#include <sys/types.h>
+			#include <sys/stat.h>
+			#include <fcntl.h>
+			#include <stdio.h>
+			int main()
+			{
+				long v1 = (unsigned int) -1, v2 = 0;
+				char buf[128];
+				int fd;
+				sprintf(buf, "/proc/%d/$proc_mem_file", getpid());
+				fd = open(buf, O_RDONLY);
+				if (0 > fd) {
+					return 1;
+				}
+				if (sizeof(long) != pread(fd, &v2, sizeof(long), (uintptr_t) &v1)) {
+					close(fd);
+					return 1;
+				}
+				close(fd);
+				return v1 != v2;
+			}
+		], [
+			AC_MSG_RESULT([$proc_mem_file])
+		], [
+			proc_mem_file=""
+			AC_MSG_RESULT([no])
+		])
+	fi
+	
+	if test -n "$proc_mem_file"; then
+		AC_DEFINE_UNQUOTED([PROC_MEM_FILE], "$proc_mem_file", [/proc/pid/mem interface])
+	fi
+	
+	fpm_trace_type=""
+
+	if test "$have_ptrace" = "yes"; then
+		fpm_trace_type=ptrace
+		
+	elif test -n "$proc_mem_file"; then
+		fpm_trace_type=pread
+		
+	elif test "$have_mach_vm_read" = "yes" ; then
+		fpm_trace_type=mach
+		
+	else
+		AC_MSG_ERROR([FPM Trace - ptrace, pread, or mach: could not be found])		
+	fi
+	
+])
+
diff -Naur php-src-vanilla/sapi/fpm/ac/fpm_conf.m4 php-src/sapi/fpm/ac/fpm_conf.m4
--- php-src-vanilla/sapi/fpm/ac/fpm_conf.m4	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/ac/fpm_conf.m4	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,188 @@
+
+AC_DEFUN([AC_FPM_ARGS],
+[
+	PHP_ARG_WITH(fpm-bin,,
+	[  --with-fpm-bin[=PATH]   Set the path for the php-fpm binary [/usr/local/bin/php-fpm]], yes, no)
+
+	PHP_ARG_WITH(fpm-port,,
+	[  --with-fpm-port[=PORT]  Set the tcp port number to listen for cgi requests [9000]], yes, no)
+
+	PHP_ARG_WITH(fpm-conf,,
+	[  --with-fpm-conf[=PATH]  Set the path for php-fpm configuration file [/etc/php-fpm.conf]], yes, no)
+
+	PHP_ARG_WITH(fpm-init,,
+	[  --with-fpm-init[=PATH]  Set the path for php-fpm init file [/etc/init.d/php-fpm]], yes, no)
+
+	PHP_ARG_WITH(fpm-log,,
+	[  --with-fpm-log[=PATH]   Set the path for php-fpm log file [/var/log/php-fpm.log]], yes, no)
+
+	PHP_ARG_WITH(fpm-pid,,
+	[  --with-fpm-pid[=PATH]   Set the path for php-fpm pid file [/var/run/php-fpm.pid]], yes, no)
+
+	PHP_ARG_WITH(fpm-user,,
+	[  --with-fpm-user[=USER]  Set the user for php-fpm to run as [nobody]], yes, no)
+
+	PHP_ARG_WITH(fpm-group,,
+	[  --with-fpm-group[=GRP]  Set the group for php-fpm to run as. For a system user,
+	                  this should be set to match the fpm username [nobody]], yes, no)
+])
+
+AC_DEFUN([AC_FPM_VARS],
+[
+	fpm_prefix=$ac_default_prefix
+	if test $prefix != "NONE" -a $prefix != "" -a $prefix != "no" ; then
+		fpm_prefix=$prefix
+	else
+		prefix=$fpm_prefix
+	fi
+
+	if test $exec_prefix = "NONE" -o $exec_prefix = "" -o $exec_prefix = "no" ; then
+		exec_prefix=$fpm_prefix
+	fi
+
+	if test `echo "$bindir" | grep "exec_prefix"` ; then
+		bindir=$exec_prefix/bin
+	fi
+
+	fpm_bin_prefix=$fpm_prefix/bin
+	if test $bindir != "NONE" -a $bindir != "" -a $bindir != "no" ; then
+		fpm_bin_prefix=$bindir
+	fi
+
+	if test -z "$PHP_FPM_BIN" -o "$PHP_FPM_BIN" = "yes" -o "$PHP_FPM_BIN" = "no"; then
+		php_fpm_bin_path="$fpm_bin_prefix/php-fpm"
+	else
+		php_fpm_bin_path="$PHP_FPM_BIN"
+	fi
+	php_fpm_bin=`basename $php_fpm_bin_path`
+	php_fpm_bin_dir=`dirname $php_fpm_bin_path`
+
+	if test -z "$PHP_FPM_PORT" -o "$PHP_FPM_PORT" = "yes" -o "$PHP_FPM_PORT" = "no"; then
+		php_fpm_port="9000"
+	else
+		php_fpm_port="$PHP_FPM_PORT"
+	fi
+
+	if test -z "$PHP_FPM_CONF" -o "$PHP_FPM_CONF" = "yes"; then
+		case $host_os in
+			freebsd*|dragonfly*)  php_fpm_conf_path="/usr/local/etc/php-fpm.conf" ;;
+			*)                    php_fpm_conf_path="/etc/php-fpm.conf" ;;
+		esac
+	elif test "$PHP_FPM_CONF" = "no"; then
+		php_fpm_conf_path=""
+	else
+		php_fpm_conf_path="$PHP_FPM_CONF"
+	fi
+	if test -z "$php_fpm_conf_path"; then
+		php_fpm_conf=""
+		php_fpm_conf_dir=""
+	else
+		php_fpm_conf=`basename $php_fpm_conf_path`
+		php_fpm_conf_dir=`dirname $php_fpm_conf_path`		
+	fi
+
+	if test -z "$PHP_FPM_INIT" -o "$PHP_FPM_INIT" = "yes"; then
+		case $host_os in
+			openbsd*)          php_fpm_init_path="" ;;
+			netbsd*)           php_fpm_init_path="/etc/rc.d/php-fpm" ;;
+			*bsd*|dragonfly*)  php_fpm_init_path="/usr/local/etc/rc.d/php-fpm" ;;
+			*)                 php_fpm_init_path="/etc/init.d/php-fpm" ;;
+		esac
+		test -f /etc/arch-release && php_fpm_init_path="/etc/rc.d/php-fpm" # arch linux
+
+	elif test "$PHP_FPM_INIT" = "no"; then
+		php_fpm_init_path=""
+	else
+		php_fpm_init_path="$PHP_FPM_INIT"
+	fi
+	if test -z "$php_fpm_init_path"; then
+		php_fpm_init=""
+		php_fpm_init_dir=""
+	else
+		php_fpm_init=`basename $php_fpm_init_path`
+		php_fpm_init_dir=`dirname $php_fpm_init_path`		
+	fi
+
+	if test -z "$PHP_FPM_LOG" -o "$PHP_FPM_LOG" = "yes" -o "$PHP_FPM_LOG" = "no"; then
+		php_fpm_log_path="/var/log/php-fpm.log"
+	else
+		php_fpm_log_path="$PHP_FPM_LOG"
+	fi
+	php_fpm_log_dir=`dirname $php_fpm_log_path`
+
+	if test -z "$PHP_FPM_PID" -o "$PHP_FPM_PID" = "yes" -o "$PHP_FPM_PID" = "no"; then
+		php_fpm_pid_path="/var/run/php-fpm.pid"
+	else
+		php_fpm_pid_path="$PHP_FPM_PID"
+	fi
+	php_fpm_pid_dir=`dirname $php_fpm_pid_path`
+
+	if test -z "$PHP_FPM_USER" -o "$PHP_FPM_USER" = "yes" -o "$PHP_FPM_USER" = "no"; then
+		php_fpm_user="nobody"
+	else
+		php_fpm_user="$PHP_FPM_USER"
+	fi
+
+	if test -z "$PHP_FPM_GROUP" -o "$PHP_FPM_GROUP" = "yes" -o "$PHP_FPM_GROUP" = "no"; then
+		php_fpm_group="nobody"
+	else
+		php_fpm_group="$PHP_FPM_GROUP"
+	fi
+
+
+	PHP_SUBST_OLD(fpm_version)
+	PHP_SUBST_OLD(php_fpm_bin)
+	PHP_SUBST_OLD(php_fpm_bin_dir)
+	PHP_SUBST_OLD(php_fpm_bin_path)
+	PHP_SUBST_OLD(php_fpm_port)
+	PHP_SUBST_OLD(php_fpm_conf)
+	PHP_SUBST_OLD(php_fpm_conf_dir)
+	PHP_SUBST_OLD(php_fpm_conf_path)
+	PHP_SUBST_OLD(php_fpm_init)
+	PHP_SUBST_OLD(php_fpm_init_dir)
+	PHP_SUBST_OLD(php_fpm_init_path)
+	PHP_SUBST_OLD(php_fpm_log_dir)
+	PHP_SUBST_OLD(php_fpm_log_path)
+	PHP_SUBST_OLD(php_fpm_pid_dir)
+	PHP_SUBST_OLD(php_fpm_pid_path)
+	PHP_SUBST_OLD(php_fpm_user)
+	PHP_SUBST_OLD(php_fpm_group)
+
+
+	AC_DEFINE_UNQUOTED(PHP_FPM_VERSION, "$fpm_version", [fpm version])
+	AC_DEFINE_UNQUOTED(PHP_FPM_BIN, "$php_fpm_bin", [fpm binary executable])
+	AC_DEFINE_UNQUOTED(PHP_FPM_BIN_DIR, "$php_fpm_bin_dir", [fpm binary dir])
+	AC_DEFINE_UNQUOTED(PHP_FPM_BIN_PATH, "$php_fpm_bin_path", [fpm bin file path])
+	AC_DEFINE_UNQUOTED(PHP_FPM_PORT, "$php_fpm_port", [tcp port])
+	AC_DEFINE_UNQUOTED(PHP_FPM_CONF, "$php_fpm_conf", [fpm conf file])
+	AC_DEFINE_UNQUOTED(PHP_FPM_CONF_DIR, "$php_fpm_conf_dir", [fpm conf dir])
+	AC_DEFINE_UNQUOTED(PHP_FPM_CONF_PATH, "$php_fpm_conf_path", [fpm conf file path])
+	AC_DEFINE_UNQUOTED(PHP_FPM_INIT, "$php_fpm_init", [fpm init file])
+	AC_DEFINE_UNQUOTED(PHP_FPM_INIT_DIR, "$php_fpm_init_dir", [fpm init dir])
+	AC_DEFINE_UNQUOTED(PHP_FPM_INIT_PATH, "$php_fpm_init_path", [fpm init file path])
+	AC_DEFINE_UNQUOTED(PHP_FPM_LOG_DIR, "$php_fpm_log_dir", [fpm log dir])
+	AC_DEFINE_UNQUOTED(PHP_FPM_LOG_PATH, "$php_fpm_log_path", [fpm log file path])
+	AC_DEFINE_UNQUOTED(PHP_FPM_PID_DIR, "$php_fpm_pid_dir", [fpm pid dir])
+	AC_DEFINE_UNQUOTED(PHP_FPM_PID_PATH, "$php_fpm_pid_path", [fpm pid file path])
+	AC_DEFINE_UNQUOTED(PHP_FPM_USER, "$php_fpm_user", [fpm user name])
+	AC_DEFINE_UNQUOTED(PHP_FPM_GROUP, "$php_fpm_group", [fpm group name])
+
+])
+
+
+AC_DEFUN([AC_FPM_OUTPUT],
+[
+	PHP_OUTPUT(sapi/fpm/php_fpm.conf:sapi/fpm/conf/php-fpm.conf.in)
+	PHP_OUTPUT(sapi/fpm/init.d.php_fpm:sapi/fpm/conf/init.d.php-fpm.in)
+	PHP_OUTPUT(sapi/fpm/nginx-site-conf.sample:sapi/fpm/conf/nginx-site-conf.sample.in)
+	PHP_OUTPUT(sapi/fpm/$php_fpm_bin.1:sapi/fpm/man/php-fpm.1.in)
+])
+
+
+AC_DEFUN([AC_FPM_CONF],
+[
+	AC_FPM_ARGS
+	AC_FPM_VARS
+	AC_FPM_OUTPUT
+])
+
diff -Naur php-src-vanilla/sapi/fpm/ac/fpm_libevent.m4 php-src/sapi/fpm/ac/fpm_libevent.m4
--- php-src-vanilla/sapi/fpm/ac/fpm_libevent.m4	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/ac/fpm_libevent.m4	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,250 @@
+dnl @synopsis AC_LIB_EVENT([MINIMUM-VERSION],[REQUIRED-VERSION])
+dnl
+dnl Test for the libevent library of a particular version (or newer).
+dnl Source: http://svn.apache.org/repos/asf/incubator/thrift/trunk/aclocal/ax_lib_event.m4
+dnl Modified: This file was modified for autoconf-2.13 and the PHP_ARG_WITH macro.
+dnl
+dnl If no path to the installed libevent is given, the macro will first try
+dnl using no -I or -L flags, then searches under /usr, /usr/local, /opt,
+dnl and /opt/libevent.
+dnl If these all fail, it will try the $LIBEVENT_ROOT environment variable.
+dnl
+dnl This macro requires that #include <sys/types.h> works and defines u_char.
+dnl
+dnl This macro calls:
+dnl   AC_SUBST(LIBEVENT_CFLAGS)
+dnl   AC_SUBST(LIBEVENT_LIBS)
+dnl
+dnl And (if libevent is found):
+dnl   AC_DEFINE(HAVE_LIBEVENT)
+dnl
+dnl It also leaves the shell variables "success" and "ac_have_libevent"
+dnl set to "yes" or "no".
+dnl
+dnl NOTE: This macro does not currently work for cross-compiling,
+dnl       but it can be easily modified to allow it.  (grep "cross").
+dnl
+dnl @category InstalledPackages
+dnl @category C
+dnl @version 2007-09-12
+dnl @license AllPermissive
+dnl
+dnl Copyright (C) 2009 David Reiss
+dnl Copying and distribution of this file, with or without modification,
+dnl are permitted in any medium without royalty provided the copyright
+dnl notice and this notice are preserved.
+
+AC_DEFUN([AC_LIB_EVENT_DO_CHECK],
+[
+# Save our flags.
+CPPFLAGS_SAVED="$CPPFLAGS"
+LDFLAGS_SAVED="$LDFLAGS"
+LIBS_SAVED="$LIBS"
+LD_LIBRARY_PATH_SAVED="$LD_LIBRARY_PATH"
+
+# Set our flags if we are checking a specific directory.
+if test -n "$ac_libevent_path" ; then
+	LIBEVENT_CPPFLAGS="-I$ac_libevent_path/include"
+	LIBEVENT_LDFLAGS="-L$ac_libevent_path/lib"
+	LD_LIBRARY_PATH="$ac_libevent_path/lib:$LD_LIBRARY_PATH"
+else
+	LIBEVENT_CPPFLAGS=""
+	LIBEVENT_LDFLAGS=""
+fi
+
+# Required flag for libevent.
+LIBEVENT_LIBS="-levent"
+
+# Prepare the environment for compilation.
+CPPFLAGS="$CPPFLAGS $LIBEVENT_CPPFLAGS"
+LDFLAGS="$LDFLAGS $LIBEVENT_LDFLAGS"
+LIBS="$LIBS $LIBEVENT_LIBS"
+export CPPFLAGS
+export LDFLAGS
+export LIBS
+export LD_LIBRARY_PATH
+
+success=no
+
+# Compile, link, and run the program.  This checks:
+# - event.h is available for including.
+# - event_get_version() is available for linking.
+# - The event version string is lexicographically greater
+#   than the required version.
+AC_TRY_RUN([
+#include <sys/types.h>
+#include <event.h>
+
+int main(int argc, char *argv[])
+{
+	const char* lib_version = event_get_version();
+	const char* wnt_version = "$WANT_LIBEVENT_VERSION";
+	for (;;) {
+		/* If we reached the end of the want version.  We have it. */
+		if (*wnt_version == '\0' || *wnt_version == '-') {
+			return 0;
+		}
+		/* If the want version continues but the lib version does not, */
+		/* we are missing a letter.  We don't have it. */
+		if (*lib_version == '\0' || *lib_version == '-') {
+			return 1;
+		}
+
+		/* In the 1.4 version numbering style, if there are more digits */
+		/* in one version than the other, that one is higher. */
+		int lib_digits;
+		for (lib_digits = 0;
+		lib_version[lib_digits] >= '0' &&
+		lib_version[lib_digits] <= '9';
+		lib_digits++)
+		;
+		int wnt_digits;
+		for (wnt_digits = 0;
+		wnt_version[wnt_digits] >= '0' &&
+		wnt_version[wnt_digits] <= '9';
+		wnt_digits++)
+		;
+		if (lib_digits > wnt_digits) {
+			return 0;
+		}
+		if (lib_digits < wnt_digits) {
+			return 1;
+		}
+		/* If we have greater than what we want.  We have it. */
+		if (*lib_version > *wnt_version) {
+			return 0;
+		}
+		/* If we have less, we don't. */
+		if (*lib_version < *wnt_version) {
+			return 1;
+		}
+		lib_version++;
+		wnt_version++;
+	}
+	return 0;
+}
+],[
+success=yes
+])
+
+# Restore flags.
+LIBEVENT_LIBS=""
+CPPFLAGS="$CPPFLAGS_SAVED"
+LDFLAGS="$LDFLAGS_SAVED"
+LIBS="$LIBS_SAVED"
+LD_LIBRARY_PATH="$LD_LIBRARY_PATH_SAVED"
+])
+
+AC_DEFUN([AC_LIB_EVENT],
+[
+
+PHP_ARG_WITH(libevent,,
+[  --with-libevent[=PATH]  Path to the libevent, needed for fpm SAPI [/usr/local]], yes, yes)
+
+if test "$PHP_LIBEVENT" != "no"; then
+    LIBEVENT_MIN_VERSION=ifelse([$1], ,1.4.3,$1)
+    LIBEVENT_REQ_VERSION=ifelse([$2], ,1.4.11,$2)
+
+	# Default library search paths ($sys_lib_search_path_spec)
+	AC_LIBTOOL_SYS_DYNAMIC_LINKER
+
+	libevent_prefix=$ac_default_prefix
+	if test $prefix != "NONE" -a $prefix != "" -a $prefix != "no" ; then 
+		libevent_prefix=$prefix
+	fi
+
+    if test "$PHP_LIBEVENT" = "yes"; then
+		PHP_LIBEVENT=$libevent_prefix
+    fi
+
+    AC_MSG_CHECKING(for libevent >= $LIBEVENT_REQ_VERSION)
+    for ac_libevent_path in "" $PHP_LIBEVENT /usr /usr/local /opt /opt/local /opt/libevent ; do
+	  WANT_LIBEVENT_VERSION="$LIBEVENT_REQ_VERSION"
+      AC_LIB_EVENT_DO_CHECK
+      if test "$success" = "yes"; then
+        break;
+      fi
+    done
+    if test "$success" = "no"; then
+
+		AC_MSG_RESULT(no)
+		AC_MSG_WARN([Could not find libevent $LIBEVENT_REQ_VERSION.])
+		AC_MSG_WARN([The use of earlier versions of libevent is not recommended])
+		AC_MSG_WARN([and can result in unspecified or unsupported behaviour.])
+
+        AC_MSG_CHECKING(for minimum libevent version >= $LIBEVENT_MIN_VERSION)
+        for ac_libevent_path in "" $PHP_LIBEVENT /usr /usr/local /opt /opt/local /opt/libevent ; do
+		  WANT_LIBEVENT_VERSION="$LIBEVENT_MIN_VERSION"
+	      AC_LIB_EVENT_DO_CHECK
+          if test "$success" = "yes"; then
+            break;
+          fi
+        done
+        if test "$success" = "no"; then
+		  AC_MSG_RESULT(no)
+          LIBEVENT_LIBS=""
+		  ac_have_libevent=no
+          AC_MSG_WARN([Syntax:])
+          AC_MSG_WARN([--with-libevent=yes|[path] - link to libevent.a (static library)])
+          AC_MSG_WARN([--with-libevent=shared[,path] - link to libevent.so (shared library)])
+          AC_MSG_ERROR([Libevent minimum version >= $LIBEVENT_MIN_VERSION could not be found.])
+        fi
+	fi
+
+	if test "$ext_shared" = "yes"; then
+		if test -n "$ac_libevent_path"; then
+			LIBEVENT_LIBS="-L$ac_libevent_path/lib -levent"
+		else
+			LIBEVENT_LIBS="-levent"
+		fi
+	else
+		libevent_a="libevent.a"
+		if test -n "$ac_libevent_path"; then
+			if test -f "$ac_libevent_path/lib/$libevent_a" ; then
+				LIBEVENT_LIBS="$ac_libevent_path/lib/$libevent_a"
+			fi
+			if test -z "$LIBEVENT_LIBS"; then
+				AC_MSG_RESULT(no)
+				AC_MSG_WARN([libevent.a could not be found. We looked in:])
+				AC_MSG_WARN([\"$ac_libevent_path\"])
+			fi
+		else
+			for search_path in $sys_lib_search_path_spec ; do
+				if test -f "$search_path$libevent_a" ; then
+					LIBEVENT_LIBS="$search_path$libevent_a"
+					break;
+				fi
+			done
+			if test -z "$LIBEVENT_LIBS"; then
+				AC_MSG_RESULT(no)
+				AC_MSG_WARN([libevent.a could not be found. We looked in:])
+				AC_MSG_WARN([\"$sys_lib_search_path_spec\"])
+			fi
+		fi
+		if test -z "$LIBEVENT_LIBS"; then
+			AC_MSG_WARN([Install libevent system-wide (make install)])
+			AC_MSG_WARN([Syntax:])
+			AC_MSG_WARN([--with-libevent=yes|[path] - link to libevent.a (static library)])
+			AC_MSG_WARN([--with-libevent=shared[,path] - link to libevent.so (shared library)])
+			AC_MSG_ERROR([libevent.a could not be found. Stop.])
+		fi
+	fi
+
+	if test "$success" = "yes" ; then
+		AC_MSG_RESULT(yes)
+		ac_have_libevent=yes
+		AC_DEFINE(HAVE_LIBEVENT, 1, [define if libevent is available])
+	fi
+
+	if test -n "$ac_libevent_path"; then
+		LIBEVENT_CFLAGS="-I$ac_libevent_path/include"
+	fi
+
+    AC_SUBST(LIBEVENT_CFLAGS)
+    AC_SUBST(LIBEVENT_LIBS)
+
+else
+	AC_MSG_ERROR([FPM Requires Libevent. You must build this target --with-libevent. Stop.])
+fi
+
+])
diff -Naur php-src-vanilla/sapi/fpm/ac/Makefile.frag php-src/sapi/fpm/ac/Makefile.frag
--- php-src-vanilla/sapi/fpm/ac/Makefile.frag	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/ac/Makefile.frag	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,61 @@
+fpm: $(SAPI_FPM_PATH)
+
+$(SAPI_FPM_PATH): $(PHP_GLOBAL_OBJS) $(PHP_SAPI_OBJS) $(SAPI_EXTRA_DEPS)
+	$(BUILD_FPM)
+
+install: install-fpm
+
+install-fpm: all
+	@echo "Installing PHP FPM binary:        $(INSTALL_ROOT)$(php_fpm_bin_path)"
+	@$(mkinstalldirs) $(INSTALL_ROOT)$(php_fpm_bin_dir)
+	@$(mkinstalldirs) $(INSTALL_ROOT)$(php_fpm_pid_dir)
+	@$(mkinstalldirs) $(INSTALL_ROOT)$(php_fpm_log_dir)
+	@$(INSTALL) -m 0755 $(SAPI_FPM_PATH) $(INSTALL_ROOT)$(php_fpm_bin_path)$(program_suffix)$(EXEEXT)
+
+	@test "$(php_fpm_conf)" && \
+	echo "Installing PHP FPM config:        $(INSTALL_ROOT)$(php_fpm_conf_path)" && \
+	$(mkinstalldirs) $(INSTALL_ROOT)$(php_fpm_conf_dir) || :
+
+	@test "$(php_fpm_conf)" && \
+	test -f "$(INSTALL_ROOT)$(php_fpm_conf_path)" && \
+	$(INSTALL_DATA) --backup=numbered $(INSTALL_ROOT)$(php_fpm_conf_path) $(INSTALL_ROOT)$(php_fpm_conf_path).old || :
+
+	@test "$(php_fpm_conf)" && \
+	$(INSTALL_DATA) sapi/fpm/php_fpm.conf $(INSTALL_ROOT)$(php_fpm_conf_path).default && \
+	ln -sf $(INSTALL_ROOT)$(php_fpm_conf_path).default $(INSTALL_ROOT)$(php_fpm_conf_path) || :
+
+	@echo "Installing PHP FPM man page:      $(INSTALL_ROOT)$(mandir)/man1/$(php_fpm_bin)$(program_suffix).1"
+	@$(mkinstalldirs) $(INSTALL_ROOT)$(mandir)/man1
+	@$(INSTALL_DATA) sapi/fpm/$(php_fpm_bin).1 $(INSTALL_ROOT)$(mandir)/man1/$(php_fpm_bin)$(program_suffix).1
+
+	@test "$(php_fpm_init)" && \
+	echo "Installing PHP FPM init script:   $(INSTALL_ROOT)$(php_fpm_init_path)" && \
+	$(mkinstalldirs) $(INSTALL_ROOT)$(php_fpm_init_dir) && \
+	$(INSTALL) -m 0755 sapi/fpm/init.d.php_fpm $(INSTALL_ROOT)$(php_fpm_init_path) || :
+
+	@test -d /etc/nginx/ && \
+	echo "Installing NGINX sample config:   /etc/nginx/nginx-site-conf.sample" && \
+	$(mkinstalldirs) $(INSTALL_ROOT)/etc/nginx && \
+	$(INSTALL_DATA) -b sapi/fpm/nginx-site-conf.sample $(INSTALL_ROOT)/etc/nginx/nginx-site-conf.sample || :
+
+	@test -d /usr/local/etc/nginx/ && \
+	echo "Installing NGINX sample config:   /usr/local/etc/nginx/nginx-site-conf.sample" && \
+	$(mkinstalldirs) $(INSTALL_ROOT)/usr/local/etc/nginx && \
+	$(INSTALL_DATA) -b sapi/fpm/nginx-site-conf.sample $(INSTALL_ROOT)/usr/local/etc/nginx/nginx-site-conf.sample || :
+
+	@test -d /usr/local/nginx/conf/ && \
+	echo "Installing NGINX sample config:   /usr/local/nginx/conf/nginx-site-conf.sample" && \
+	$(mkinstalldirs) $(INSTALL_ROOT)/usr/local/nginx/conf && \
+	$(INSTALL_DATA) -b sapi/fpm/nginx-site-conf.sample $(INSTALL_ROOT)/usr/local/nginx/conf/nginx-site-conf.sample || :
+
+	@echo ""
+	@echo "*** FPM Installation complete. ***"
+	@echo ""
+
+	@test "$(php_fpm_init)" && \
+	echo "run:" && \
+	echo "\`update-rc.d $(php_fpm_init) defaults; invoke-rc.d $(php_fpm_init) start\`" && \
+	echo "" && \
+	echo "or system equivalent to start the $(php_fpm_init) service." && \
+	echo "" || :
+
diff -Naur php-src-vanilla/sapi/fpm/cgi/cgi_main.c php-src/sapi/fpm/cgi/cgi_main.c
--- php-src-vanilla/sapi/fpm/cgi/cgi_main.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/cgi/cgi_main.c	2009-10-18 21:05:39.302497288 +0100
@@ -0,0 +1,1660 @@
+/*
+   +----------------------------------------------------------------------+
+   | PHP Version 5                                                        |
+   +----------------------------------------------------------------------+
+   | Copyright (c) 1997-2008 The PHP Group                                |
+   +----------------------------------------------------------------------+
+   | This source file is subject to version 3.01 of the PHP license,      |
+   | that is bundled with this package in the file LICENSE, and is        |
+   | available through the world-wide-web at the following url:           |
+   | http://www.php.net/license/3_01.txt                                  |
+   | If you did not receive a copy of the PHP license and are unable to   |
+   | obtain it through the world-wide-web, please send a note to          |
+   | license@php.net so we can mail you a copy immediately.               |
+   +----------------------------------------------------------------------+
+   | Authors: Rasmus Lerdorf <rasmus@lerdorf.on.ca>                       |
+   |          Stig Bakken <ssb@php.net>                                   |
+   |          Zeev Suraski <zeev@zend.com>                                |
+   | FastCGI: Ben Mansell <php@slimyhorror.com>                           |
+   |          Shane Caraveo <shane@caraveo.com>                           |
+   |          Dmitry Stogov <dmitry@zend.com>                             |
+   +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+
+#include <php.h>
+#include <php_globals.h>
+#include <php_variables.h>
+#include <zend_modules.h>
+
+#include <SAPI.h>
+
+#include <stdio.h>
+
+#ifdef PHP_WIN32
+#include "win32/time.h"
+#include "win32/signal.h"
+#include <process.h>
+#endif
+#if HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#if HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#if HAVE_SIGNAL_H
+#include <signal.h>
+#endif
+#if HAVE_SETLOCALE
+#include <locale.h>
+#endif
+#if HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#if HAVE_SYS_WAIT_H
+#include <sys/wait.h>
+#endif
+#if HAVE_FCNTL_H
+#include <fcntl.h>
+#endif
+#include <zend.h>
+#include <zend_extensions.h>
+#include <php_ini.h>
+#include <php_main.h>
+#include <fopen_wrappers.h>
+#include <ext/standard/php_standard.h>
+#ifdef PHP_WIN32
+#include <io.h>
+#include <fcntl.h>
+#include "win32/php_registry.h"
+#endif
+
+#ifdef __riscos__
+#include <unixlib/local.h>
+int __riscosify_control = __RISCOSIFY_STRICT_UNIX_SPECS;
+#endif
+
+#include "zend_compile.h"
+#include "zend_execute.h"
+#include "zend_highlight.h"
+#include "zend_indent.h"
+
+#include "php_getopt.h"
+
+#include "fastcgi.h"
+
+#ifdef FPM_AUTOCONFIG_H
+#include <fpm_autoconfig.h>
+#else
+#include <php_config.h>
+#endif
+#include <fpm/fpm.h>
+#include <fpm/fpm_request.h>
+
+
+static void (*php_php_import_environment_variables)(zval *array_ptr TSRMLS_DC);
+
+static int parent = 1;
+
+static int request_body_fd;
+
+static char *sapi_cgibin_getenv(char *name, size_t name_len TSRMLS_DC);
+
+static char *php_optarg = NULL;
+static int php_optind = 1;
+static zend_module_entry cgi_module_entry;
+
+static const opt_struct OPTIONS[] = {
+	{'a', 0, "interactive"},
+	{'b', 1, "bindpath"},
+	{'C', 0, "no-chdir"},
+	{'c', 1, "php-ini"},
+	{'d', 1, "define"},
+	{'e', 0, "profile-info"},
+	{'f', 1, "file"},
+	{'h', 0, "help"},
+	{'i', 0, "info"},
+	{'l', 0, "syntax-check"},
+	{'m', 0, "modules"},
+	{'n', 0, "no-php-ini"},
+	{'q', 0, "no-header"},
+	{'s', 0, "syntax-highlight"},
+	{'s', 0, "syntax-highlighting"},
+	{'w', 0, "strip"},
+	{'?', 0, "usage"},/* help alias (both '?' and 'usage') */
+	{'v', 0, "version"},
+	{'x', 0, "fpm"},
+	{'y', 1, "fpm-config"},
+	{'z', 1, "zend-extension"},
+	{'-', 0, NULL} /* end of args */
+};
+
+typedef struct _php_cgi_globals_struct {
+	zend_bool rfc2616_headers;
+	zend_bool nph;
+	zend_bool check_shebang_line;
+#if ENABLE_PATHINFO_CHECK
+	zend_bool fix_pathinfo;
+#endif
+	zend_bool fcgi_logging;
+# ifdef PHP_WIN32
+	zend_bool impersonate;
+# endif
+	char *error_header;
+} php_cgi_globals_struct;
+
+#ifdef ZTS
+static int php_cgi_globals_id;
+#define CGIG(v) TSRMG(php_cgi_globals_id, php_cgi_globals_struct *, v)
+#else
+static php_cgi_globals_struct php_cgi_globals;
+#define CGIG(v) (php_cgi_globals.v)
+#endif
+
+#ifdef PHP_WIN32
+#define TRANSLATE_SLASHES(path) \
+	{ \
+		char *tmp = path; \
+		while (*tmp) { \
+			if (*tmp == '\\') *tmp = '/'; \
+			tmp++; \
+		} \
+	}
+#else
+#define TRANSLATE_SLASHES(path)
+#endif
+
+static int print_module_info(zend_module_entry *module, void *arg TSRMLS_DC)
+{
+	php_printf("%s\n", module->name);
+	return 0;
+}
+
+static int module_name_cmp(const void *a, const void *b TSRMLS_DC)
+{
+	Bucket *f = *((Bucket **) a);
+	Bucket *s = *((Bucket **) b);
+
+	return strcasecmp(((zend_module_entry *)f->pData)->name,
+					  ((zend_module_entry *)s->pData)->name);
+}
+
+static void print_modules(TSRMLS_D)
+{
+	HashTable sorted_registry;
+	zend_module_entry tmp;
+
+	zend_hash_init(&sorted_registry, 50, NULL, NULL, 1);
+	zend_hash_copy(&sorted_registry, &module_registry, NULL, &tmp, sizeof(zend_module_entry));
+	zend_hash_sort(&sorted_registry, zend_qsort, module_name_cmp, 0 TSRMLS_CC);
+	zend_hash_apply_with_argument(&sorted_registry, (apply_func_arg_t) print_module_info, NULL TSRMLS_CC);
+	zend_hash_destroy(&sorted_registry);
+}
+
+static int print_extension_info(zend_extension *ext, void *arg TSRMLS_DC)
+{
+	php_printf("%s\n", ext->name);
+	return 0;
+}
+
+static int extension_name_cmp(const zend_llist_element **f,
+							  const zend_llist_element **s TSRMLS_DC)
+{
+	return strcmp(((zend_extension *)(*f)->data)->name,
+				  ((zend_extension *)(*s)->data)->name);
+}
+
+static void print_extensions(TSRMLS_D)
+{
+	zend_llist sorted_exts;
+
+	zend_llist_copy(&sorted_exts, &zend_extensions);
+	sorted_exts.dtor = NULL;
+	zend_llist_sort(&sorted_exts, extension_name_cmp TSRMLS_CC);
+	zend_llist_apply_with_argument(&sorted_exts, (llist_apply_with_arg_func_t) print_extension_info, NULL TSRMLS_CC);
+	zend_llist_destroy(&sorted_exts);
+}
+
+#ifndef STDOUT_FILENO
+#define STDOUT_FILENO 1
+#endif
+
+static inline size_t sapi_cgibin_single_write(const char *str, uint str_length TSRMLS_DC)
+{
+	long ret;
+
+	if (fcgi_is_fastcgi()) {
+		fcgi_request *request = (fcgi_request*) SG(server_context);
+		long ret = fcgi_write(request, FCGI_STDOUT, str, str_length);
+		if (ret <= 0) {
+			return 0;
+		}
+		return ret;
+	}
+	ret = write(STDOUT_FILENO, str, str_length);
+	if (ret <= 0) return 0;
+	return ret;
+}
+
+static int sapi_cgibin_ub_write(const char *str, uint str_length TSRMLS_DC)
+{
+	const char *ptr = str;
+	uint remaining = str_length;
+	size_t ret;
+
+	while (remaining > 0) {
+		ret = sapi_cgibin_single_write(ptr, remaining TSRMLS_CC);
+		if (!ret) {
+			php_handle_aborted_connection();
+			return str_length - remaining;
+		}
+		ptr += ret;
+		remaining -= ret;
+	}
+
+	return str_length;
+}
+
+
+static void sapi_cgibin_flush(void *server_context)
+{
+	if (fcgi_is_fastcgi()) {
+		fcgi_request *request = (fcgi_request*) server_context;
+		if (
+#ifndef PHP_WIN32
+		!parent && 
+#endif
+		request && !fcgi_flush(request, 0)) {
+			php_handle_aborted_connection();
+		}
+		return;
+	}
+	if (fflush(stdout) == EOF) {
+		php_handle_aborted_connection();
+	}
+}
+
+#define SAPI_CGI_MAX_HEADER_LENGTH 1024
+
+typedef struct _http_error {
+  int code;
+  const char* msg;
+} http_error;
+
+static const http_error http_error_codes[] = {
+	{100, "Continue"},
+	{101, "Switching Protocols"},
+	{200, "OK"},
+	{201, "Created"},
+	{202, "Accepted"},
+	{203, "Non-Authoritative Information"},
+	{204, "No Content"},
+	{205, "Reset Content"},
+	{206, "Partial Content"},
+	{300, "Multiple Choices"},
+	{301, "Moved Permanently"},
+	{302, "Moved Temporarily"},
+	{303, "See Other"},
+	{304, "Not Modified"},
+	{305, "Use Proxy"},
+	{400, "Bad Request"},
+	{401, "Unauthorized"},
+	{402, "Payment Required"},
+	{403, "Forbidden"},
+	{404, "Not Found"},
+	{405, "Method Not Allowed"},
+	{406, "Not Acceptable"},
+	{407, "Proxy Authentication Required"},
+	{408, "Request Time-out"},
+	{409, "Conflict"},
+	{410, "Gone"},
+	{411, "Length Required"},
+	{412, "Precondition Failed"},
+	{413, "Request Entity Too Large"},
+	{414, "Request-URI Too Large"},
+	{415, "Unsupported Media Type"},
+	{500, "Internal Server Error"},
+	{501, "Not Implemented"},
+	{502, "Bad Gateway"},
+	{503, "Service Unavailable"},
+	{504, "Gateway Time-out"},
+	{505, "HTTP Version not supported"},
+	{0,   NULL}
+};
+
+static int sapi_cgi_send_headers(sapi_headers_struct *sapi_headers TSRMLS_DC)
+{
+	char buf[SAPI_CGI_MAX_HEADER_LENGTH];
+	sapi_header_struct *h;
+	zend_llist_position pos;
+	zend_bool ignore_status = 0;
+	int response_status = SG(sapi_headers).http_response_code;
+
+	if (SG(request_info).no_headers == 1) {
+		return  SAPI_HEADER_SENT_SUCCESSFULLY;
+	}
+
+	if (CGIG(nph) || SG(sapi_headers).http_response_code != 200)
+	{
+		int len;
+		zend_bool has_status = 0;
+
+		if (CGIG(rfc2616_headers) && SG(sapi_headers).http_status_line) {
+			char *s;
+			len = slprintf(buf, SAPI_CGI_MAX_HEADER_LENGTH, "%s\r\n", SG(sapi_headers).http_status_line);
+			if ((s = strchr(SG(sapi_headers).http_status_line, ' '))) {
+				response_status = atoi((s + 1));
+			}
+
+			if (len > SAPI_CGI_MAX_HEADER_LENGTH) {
+				len = SAPI_CGI_MAX_HEADER_LENGTH;
+			}
+
+		} else {
+			char *s;
+
+			if (SG(sapi_headers).http_status_line &&
+			    (s = strchr(SG(sapi_headers).http_status_line, ' ')) != 0 &&
+			    (s - SG(sapi_headers).http_status_line) >= 5 &&
+			    strncasecmp(SG(sapi_headers).http_status_line, "HTTP/", 5) == 0) {
+				len = slprintf(buf, sizeof(buf), "Status:%s\r\n", s);
+				response_status = atoi((s + 1));
+			} else {
+				h = (sapi_header_struct*)zend_llist_get_first_ex(&sapi_headers->headers, &pos);
+				while (h) {
+					if (h->header_len > sizeof("Status:")-1 &&
+					    strncasecmp(h->header, "Status:", sizeof("Status:")-1) == 0) {
+						has_status = 1;
+						break;
+					}
+					h = (sapi_header_struct*)zend_llist_get_next_ex(&sapi_headers->headers, &pos);
+				}
+				if (!has_status) {
+					http_error *err = (http_error*)http_error_codes;
+
+					while (err->code != 0) {
+					    if (err->code == SG(sapi_headers).http_response_code) {
+							break;
+						}
+						err++;
+					}
+					if (err->msg) {
+						len = slprintf(buf, sizeof(buf), "Status: %d %s\r\n", SG(sapi_headers).http_response_code, err->msg);
+					} else {
+						len = slprintf(buf, sizeof(buf), "Status: %d\r\n", SG(sapi_headers).http_response_code);
+					}
+				}
+			}
+		}
+		if (!has_status) {
+			PHPWRITE_H(buf, len);
+			ignore_status = 1;
+		}
+	}
+
+	h = (sapi_header_struct*)zend_llist_get_first_ex(&sapi_headers->headers, &pos);
+	while (h) {
+		/* prevent CRLFCRLF */
+		if (h->header_len) {
+			if (h->header_len > sizeof("Status:")-1 &&
+			    strncasecmp(h->header, "Status:", sizeof("Status:")-1) == 0) {
+			    if (!ignore_status) {
+				    ignore_status = 1;
+					PHPWRITE_H(h->header, h->header_len);
+					PHPWRITE_H("\r\n", 2);
+				}
+			} else if (response_status == 304 && h->header_len > sizeof("Content-Type:")-1 && 
+					strncasecmp(h->header, "Content-Type:", sizeof("Content-Type:")-1) == 0) {
+				h = (sapi_header_struct*)zend_llist_get_next_ex(&sapi_headers->headers, &pos);
+				continue;
+			} else {
+				PHPWRITE_H(h->header, h->header_len);
+				PHPWRITE_H("\r\n", 2);
+			}
+		}
+		h = (sapi_header_struct*)zend_llist_get_next_ex(&sapi_headers->headers, &pos);
+	}
+	PHPWRITE_H("\r\n", 2);
+
+	return SAPI_HEADER_SENT_SUCCESSFULLY;
+}
+
+
+static int sapi_cgi_read_post(char *buffer, uint count_bytes TSRMLS_DC)
+{
+	int read_bytes=0, tmp_read_bytes;
+
+	count_bytes = MIN(count_bytes, (uint) SG(request_info).content_length - SG(read_post_bytes));
+	while (read_bytes < count_bytes) {
+		if (fcgi_is_fastcgi()) {
+			fcgi_request *request = (fcgi_request*) SG(server_context);
+
+			if (request_body_fd == -1) {
+				char *request_body_filename = sapi_cgibin_getenv((char *) "REQUEST_BODY_FILE",
+						sizeof("REQUEST_BODY_FILE")-1 TSRMLS_CC);
+
+				if (request_body_filename && *request_body_filename) {
+					request_body_fd = open(request_body_filename, O_RDONLY);
+
+					if (0 > request_body_fd) {
+						php_error(E_WARNING, "REQUEST_BODY_FILE: open('%s') failed: %s (%d)",
+								request_body_filename, strerror(errno), errno);
+						return 0;
+					}
+				}
+			}
+
+			/* If REQUEST_BODY_FILE variable not available - read post body from fastcgi stream */
+			if (request_body_fd < 0) {
+				tmp_read_bytes = fcgi_read(request, buffer + read_bytes, count_bytes - read_bytes);
+			} else {
+				tmp_read_bytes = read(request_body_fd, buffer + read_bytes, count_bytes - read_bytes);
+			}
+		} else {
+			tmp_read_bytes = read(0, buffer + read_bytes, count_bytes - read_bytes);
+		}
+
+		if (tmp_read_bytes <= 0) {
+			break;
+		}
+		read_bytes += tmp_read_bytes;
+	}
+	return read_bytes;
+}
+
+static char *sapi_cgibin_getenv(char *name, size_t name_len TSRMLS_DC)
+{
+	/* when php is started by mod_fastcgi, no regular environment
+	   is provided to PHP.  It is always sent to PHP at the start
+	   of a request.  So we have to do our own lookup to get env
+	   vars.  This could probably be faster somehow.  */
+	if (fcgi_is_fastcgi()) {
+		fcgi_request *request = (fcgi_request*) SG(server_context);
+		return fcgi_getenv(request, name, name_len);
+	}
+	/*  if cgi, or fastcgi and not found in fcgi env
+		check the regular environment */
+	return getenv(name);
+}
+
+static char *_sapi_cgibin_putenv(char *name, char *value TSRMLS_DC)
+{
+	int name_len;
+#if !HAVE_SETENV || !HAVE_UNSETENV
+	int len;
+	char *buf;
+#endif
+
+	if (!name) {
+		return NULL;
+	}
+	name_len = strlen(name);
+
+	/* when php is started by mod_fastcgi, no regular environment
+	   is provided to PHP.  It is always sent to PHP at the start
+	   of a request.  So we have to do our own lookup to get env
+	   vars.  This could probably be faster somehow.  */
+	if (fcgi_is_fastcgi()) {
+		fcgi_request *request = (fcgi_request*) SG(server_context);
+		return fcgi_putenv(request, name, name_len, value);
+	}
+#if HAVE_SETENV
+	if (value) {
+		setenv(name, value, 1);
+	}
+#endif
+#if HAVE_UNSETENV
+	if (!value) {
+		unsetenv(name);
+	}
+#endif
+
+#if !HAVE_SETENV || !HAVE_UNSETENV
+	/*  if cgi, or fastcgi and not found in fcgi env
+		check the regular environment 
+		this leaks, but it's only cgi anyway, we'll fix
+		it for 5.0
+	*/
+	len = name_len + (value ? strlen(value) : 0) + sizeof("=") + 2;
+	buf = (char *) malloc(len);
+	if (buf == NULL) {
+		return getenv(name);
+	}
+#endif
+#if !HAVE_SETENV
+	if (value) {
+		len = slprintf(buf, len - 1, "%s=%s", name, value);
+		putenv(buf);
+	}
+#endif
+#if !HAVE_UNSETENV
+	if (!value) {
+		len = slprintf(buf, len - 1, "%s=", name);
+		putenv(buf);
+	}
+#endif
+	return getenv(name);
+}
+
+static char *sapi_cgi_read_cookies(TSRMLS_D)
+{
+	return sapi_cgibin_getenv((char *) "HTTP_COOKIE", sizeof("HTTP_COOKIE")-1 TSRMLS_CC);
+}
+
+void cgi_php_import_environment_variables(zval *array_ptr TSRMLS_DC)
+{
+	if (PG(http_globals)[TRACK_VARS_ENV] &&
+	    array_ptr != PG(http_globals)[TRACK_VARS_ENV] &&
+	    Z_TYPE_P(PG(http_globals)[TRACK_VARS_ENV]) == IS_ARRAY &&
+	    zend_hash_num_elements(Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_ENV])) > 0) {
+	    zval_dtor(array_ptr);
+	    *array_ptr = *PG(http_globals)[TRACK_VARS_ENV];
+	    INIT_PZVAL(array_ptr);
+	    zval_copy_ctor(array_ptr);
+	    return;
+	} else if (PG(http_globals)[TRACK_VARS_SERVER] &&
+		array_ptr != PG(http_globals)[TRACK_VARS_SERVER] &&
+	    Z_TYPE_P(PG(http_globals)[TRACK_VARS_SERVER]) == IS_ARRAY &&
+	    zend_hash_num_elements(Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_SERVER])) > 0) {
+	    zval_dtor(array_ptr);
+	    *array_ptr = *PG(http_globals)[TRACK_VARS_SERVER];
+	    INIT_PZVAL(array_ptr);
+	    zval_copy_ctor(array_ptr);
+	    return;
+	}
+	
+	/* call php's original import as a catch-all */
+	php_php_import_environment_variables(array_ptr TSRMLS_CC);
+
+	if (fcgi_is_fastcgi()) {
+		fcgi_request *request = (fcgi_request*) SG(server_context);
+		HashPosition pos;
+		int magic_quotes_gpc = PG(magic_quotes_gpc);
+		char *var, **val;
+		uint var_len;
+		ulong idx;
+		int filter_arg = (array_ptr == PG(http_globals)[TRACK_VARS_ENV])?PARSE_ENV:PARSE_SERVER;
+
+		/* turn off magic_quotes while importing environment variables */
+		PG(magic_quotes_gpc) = 0;
+		for (zend_hash_internal_pointer_reset_ex(&request->env, &pos);
+		     zend_hash_get_current_key_ex(&request->env, &var, &var_len, &idx, 0, &pos) == HASH_KEY_IS_STRING &&
+		     zend_hash_get_current_data_ex(&request->env, (void **) &val, &pos) == SUCCESS;
+		     zend_hash_move_forward_ex(&request->env, &pos)) {
+			unsigned int new_val_len;
+			if (sapi_module.input_filter(filter_arg, var, val, strlen(*val), &new_val_len TSRMLS_CC)) {
+				php_register_variable_safe(var, *val, new_val_len, array_ptr TSRMLS_CC);
+			}
+		}
+		PG(magic_quotes_gpc) = magic_quotes_gpc;
+	}
+}
+
+static void sapi_cgi_register_variables(zval *track_vars_array TSRMLS_DC)
+{
+	unsigned int php_self_len;
+	char *php_self;
+
+	/* In CGI mode, we consider the environment to be a part of the server
+	 * variables
+	 */
+	php_import_environment_variables(track_vars_array TSRMLS_CC);
+
+#if ENABLE_PATHINFO_CHECK
+	if (CGIG(fix_pathinfo)) {
+		char *script_name   = SG(request_info).request_uri;
+		unsigned int script_name_len = script_name ? strlen(script_name) : 0;
+		char *path_info     = sapi_cgibin_getenv("PATH_INFO", sizeof("PATH_INFO")-1 TSRMLS_CC);
+		unsigned int path_info_len = path_info ? strlen(path_info) : 0;
+
+		php_self_len = script_name_len + path_info_len;
+		php_self = emalloc(php_self_len + 1);
+		if (script_name) {
+			memcpy(php_self, script_name, script_name_len + 1);
+		}
+		if (path_info) {
+			memcpy(php_self + script_name_len, path_info, path_info_len + 1);
+		}
+
+		/* Build the special-case PHP_SELF variable for the CGI version */
+		if (sapi_module.input_filter(PARSE_SERVER, "PHP_SELF", &php_self, php_self_len, &php_self_len TSRMLS_CC)) {
+			php_register_variable_safe("PHP_SELF", php_self, php_self_len, track_vars_array TSRMLS_CC);
+		}
+		efree(php_self);
+		return;
+	}
+#endif
+
+	php_self = SG(request_info).request_uri ? SG(request_info).request_uri : "";
+	php_self_len = strlen(php_self);
+	if (sapi_module.input_filter(PARSE_SERVER, "PHP_SELF", &php_self, php_self_len, &php_self_len TSRMLS_CC)) {
+		php_register_variable_safe("PHP_SELF", php_self, php_self_len, track_vars_array TSRMLS_CC);
+	}
+}
+
+static void sapi_cgi_log_message(char *message)
+{
+	TSRMLS_FETCH();
+
+	if (fcgi_is_fastcgi() && CGIG(fcgi_logging)) {
+		fcgi_request *request;
+		
+		request = (fcgi_request*) SG(server_context);
+		if (request) {			
+			int len = strlen(message);
+			char *buf = malloc(len+2);
+
+			memcpy(buf, message, len);
+			memcpy(buf + len, "\n", sizeof("\n"));
+			fcgi_write(request, FCGI_STDERR, buf, len+1);
+			free(buf);
+		} else {
+			fprintf(stderr, "%s\n", message);
+		}
+		/* ignore return code */
+	} else
+	fprintf(stderr, "%s\n", message);
+}
+
+static int sapi_cgi_deactivate(TSRMLS_D)
+{
+	/* flush only when SAPI was started. The reasons are:
+		1. SAPI Deactivate is called from two places: module init and request shutdown
+		2. When the first call occurs and the request is not set up, flush fails on 
+			FastCGI.
+	*/
+	if (SG(sapi_started)) {
+		sapi_cgibin_flush(SG(server_context));
+	}
+	return SUCCESS;
+}
+
+static int php_cgi_startup(sapi_module_struct *sapi_module)
+{
+	if (php_module_startup(sapi_module, &cgi_module_entry, 1) == FAILURE) {
+		return FAILURE;
+	}
+	return SUCCESS;
+}
+
+
+/* {{{ sapi_module_struct cgi_sapi_module
+ */
+static sapi_module_struct cgi_sapi_module = {
+	"cgi-fcgi",						/* name */
+	"CGI/FastCGI",					/* pretty name */
+
+	php_cgi_startup,				/* startup */
+	php_module_shutdown_wrapper,	/* shutdown */
+
+	NULL,							/* activate */
+	sapi_cgi_deactivate,			/* deactivate */
+
+	sapi_cgibin_ub_write,			/* unbuffered write */
+	sapi_cgibin_flush,				/* flush */
+	NULL,							/* get uid */
+	sapi_cgibin_getenv,				/* getenv */
+
+	php_error,						/* error handler */
+
+	NULL,							/* header handler */
+	sapi_cgi_send_headers,			/* send headers handler */
+	NULL,							/* send header handler */
+
+	sapi_cgi_read_post,				/* read POST data */
+	sapi_cgi_read_cookies,			/* read Cookies */
+
+	sapi_cgi_register_variables,	/* register server variables */
+	sapi_cgi_log_message,			/* Log message */
+	NULL,							/* Get request time */
+
+	STANDARD_SAPI_MODULE_PROPERTIES
+};
+/* }}} */
+
+/* {{{ php_cgi_usage
+ */
+static void php_cgi_usage(char *argv0)
+{
+	char *prog;
+
+	prog = strrchr(argv0, '/');
+	if (prog) {
+		prog++;
+	} else {
+		prog = "php";
+	}
+
+	php_printf("Usage: %s [options]\n"
+			   "\n"
+			   "  -C               Do not chdir to the script's directory\n"
+			   "  -c <path>|<file> Look for php.ini file in this directory\n"
+			   "  -n               No php.ini file will be used\n"
+			   "  -d foo[=bar]     Define INI entry foo with value 'bar'\n"
+			   "  -e               Generate extended information for debugger/profiler\n"
+			   "  -h               This help\n"
+			   "  -i               PHP information\n"
+			   "  -m               Show compiled in modules\n"
+			   "  -v               Version number\n"
+			   "  -y, --fpm-config <file>\n"
+			   "                   Specify alternative path to FastCGI process manager config file.\n"
+ 			   "  -z <file>        Load Zend extension <file>.\n"
+			   ,
+			   prog);
+}
+/* }}} */
+
+/* {{{ is_valid_path
+ *
+ * some server configurations allow '..' to slip through in the
+ * translated path.   We'll just refuse to handle such a path.
+ */
+static int is_valid_path(const char *path)
+{
+	const char *p;
+
+	if (!path) {
+		return 0;
+	}
+	p = strstr(path, "..");
+	if (p) {
+		if ((p == path || IS_SLASH(*(p-1))) &&
+		    (*(p+2) == 0 || IS_SLASH(*(p+2)))) {
+			return 0;
+		}
+		while (1) {
+			p = strstr(p+1, "..");
+			if (!p) {
+				break;
+			}
+			if (IS_SLASH(*(p-1)) &&
+			    (*(p+2) == 0 || IS_SLASH(*(p+2)))) {
+					return 0;
+			}
+		}
+	}
+	return 1;
+}
+/* }}} */
+
+/* {{{ init_request_info
+
+  initializes request_info structure
+
+  specificly in this section we handle proper translations
+  for:
+
+  PATH_INFO
+	derived from the portion of the URI path following 
+	the script name but preceding any query data
+	may be empty
+
+  PATH_TRANSLATED
+    derived by taking any path-info component of the 
+	request URI and performing any virtual-to-physical 
+	translation appropriate to map it onto the server's 
+	document repository structure
+
+	empty if PATH_INFO is empty
+
+	The env var PATH_TRANSLATED **IS DIFFERENT** than the
+	request_info.path_translated variable, the latter should
+	match SCRIPT_FILENAME instead.
+
+  SCRIPT_NAME
+    set to a URL path that could identify the CGI script
+	rather than the interpreter.  PHP_SELF is set to this.
+
+  REQUEST_URI
+    uri section following the domain:port part of a URI
+
+  SCRIPT_FILENAME
+    The virtual-to-physical translation of SCRIPT_NAME (as per 
+	PATH_TRANSLATED)
+
+  These settings are documented at
+  http://cgi-spec.golux.com/
+
+
+  Based on the following URL request:
+  
+  http://localhost/info.php/test?a=b 
+ 
+  should produce, which btw is the same as if
+  we were running under mod_cgi on apache (ie. not
+  using ScriptAlias directives):
+ 
+  PATH_INFO=/test
+  PATH_TRANSLATED=/docroot/test
+  SCRIPT_NAME=/info.php
+  REQUEST_URI=/info.php/test?a=b
+  SCRIPT_FILENAME=/docroot/info.php
+  QUERY_STRING=a=b
+ 
+  but what we get is (cgi/mod_fastcgi under apache):
+  
+  PATH_INFO=/info.php/test
+  PATH_TRANSLATED=/docroot/info.php/test
+  SCRIPT_NAME=/php/php-cgi  (from the Action setting I suppose)
+  REQUEST_URI=/info.php/test?a=b
+  SCRIPT_FILENAME=/path/to/php/bin/php-cgi  (Action setting translated)
+  QUERY_STRING=a=b
+ 
+  Comments in the code below refer to using the above URL in a request
+
+ */
+static void init_request_info(TSRMLS_D)
+{
+	char *env_script_filename = sapi_cgibin_getenv("SCRIPT_FILENAME", sizeof("SCRIPT_FILENAME")-1 TSRMLS_CC);
+	char *env_path_translated = sapi_cgibin_getenv("PATH_TRANSLATED", sizeof("PATH_TRANSLATED")-1 TSRMLS_CC);
+	char *script_path_translated = env_script_filename;
+
+#if !DISCARD_PATH
+	/* some broken servers do not have script_filename or argv0
+	   an example, IIS configured in some ways.  then they do more
+	   broken stuff and set path_translated to the cgi script location */
+	if (!script_path_translated && env_path_translated) {
+		script_path_translated = env_path_translated;
+	}
+#endif
+
+	/* initialize the defaults */
+	SG(request_info).path_translated = NULL;
+	SG(request_info).request_method = NULL;
+	SG(request_info).proto_num = 1000;
+	SG(request_info).query_string = NULL;
+	SG(request_info).request_uri = NULL;
+	SG(request_info).content_type = NULL;
+	SG(request_info).content_length = 0;
+	SG(sapi_headers).http_response_code = 200;
+
+	/* script_path_translated being set is a good indication that
+	   we are running in a cgi environment, since it is always
+	   null otherwise.  otherwise, the filename
+	   of the script will be retreived later via argc/argv */
+	if (script_path_translated) {
+		const char *auth;
+		char *content_length = sapi_cgibin_getenv("CONTENT_LENGTH", sizeof("CONTENT_LENGTH")-1 TSRMLS_CC);
+		char *content_type = sapi_cgibin_getenv("CONTENT_TYPE", sizeof("CONTENT_TYPE")-1 TSRMLS_CC);
+		char *env_path_info = sapi_cgibin_getenv("PATH_INFO", sizeof("PATH_INFO")-1 TSRMLS_CC);
+		char *env_script_name = sapi_cgibin_getenv("SCRIPT_NAME", sizeof("SCRIPT_NAME")-1 TSRMLS_CC);
+#if ENABLE_PATHINFO_CHECK
+		struct stat st;
+		char *env_redirect_url = sapi_cgibin_getenv("REDIRECT_URL", sizeof("REDIRECT_URL")-1 TSRMLS_CC);
+		char *env_document_root = sapi_cgibin_getenv("DOCUMENT_ROOT", sizeof("DOCUMENT_ROOT")-1 TSRMLS_CC);
+		int script_path_translated_len;
+
+		/* Hack for buggy IIS that sets incorrect PATH_INFO */
+		char *env_server_software = sapi_cgibin_getenv("SERVER_SOFTWARE", sizeof("SERVER_SOFTWARE")-1 TSRMLS_CC);
+		if (env_server_software &&
+		    env_script_name &&
+		    env_path_info &&
+		    strncmp(env_server_software, "Microsoft-IIS", sizeof("Microsoft-IIS")-1) == 0 &&
+		    strncmp(env_path_info, env_script_name, strlen(env_script_name)) == 0) {
+			env_path_info = _sapi_cgibin_putenv("ORIG_PATH_INFO", env_path_info TSRMLS_CC);
+		    env_path_info += strlen(env_script_name);
+		    if (*env_path_info == 0) {
+		    	env_path_info = NULL;
+		    }
+			env_path_info = _sapi_cgibin_putenv("PATH_INFO", env_path_info TSRMLS_CC);
+		}
+
+		if (CGIG(fix_pathinfo)) {
+			char *real_path = NULL;
+			char *orig_path_translated = env_path_translated;
+			char *orig_path_info = env_path_info;
+			char *orig_script_name = env_script_name;
+			char *orig_script_filename = env_script_filename;
+
+			if (!env_document_root && PG(doc_root)) {
+				env_document_root = _sapi_cgibin_putenv("DOCUMENT_ROOT", PG(doc_root) TSRMLS_CC);
+				/* fix docroot */
+				TRANSLATE_SLASHES(env_document_root);
+ 			}
+
+			if (env_path_translated != NULL && env_redirect_url != NULL) {
+				/* 
+				   pretty much apache specific.  If we have a redirect_url
+				   then our script_filename and script_name point to the
+				   php executable
+				*/
+				script_path_translated = env_path_translated;
+				/* we correct SCRIPT_NAME now in case we don't have PATH_INFO */
+				env_script_name = env_redirect_url;
+			}
+
+#ifdef __riscos__
+			/* Convert path to unix format*/
+			__riscosify_control |= __RISCOSIFY_DONT_CHECK_DIR;
+			script_path_translated = __unixify(script_path_translated, 0, NULL, 1, 0);
+#endif
+			
+			/*
+			 * if the file doesn't exist, try to extract PATH_INFO out
+			 * of it by stat'ing back through the '/'
+			 * this fixes url's like /info.php/test
+			 */
+			if (script_path_translated &&
+				(script_path_translated_len = strlen(script_path_translated)) > 0 &&
+				(script_path_translated[script_path_translated_len-1] == '/' ||
+#ifdef PHP_WIN32
+				 script_path_translated[script_path_translated_len-1] == '\\' ||
+#endif
+			     (real_path = tsrm_realpath(script_path_translated, NULL TSRMLS_CC)) == NULL)) {
+				char *pt = estrndup(script_path_translated, script_path_translated_len);
+				int len = script_path_translated_len;
+				char *ptr;
+
+				while ((ptr = strrchr(pt, '/')) || (ptr = strrchr(pt, '\\'))) {
+					*ptr = 0;
+					if (stat(pt, &st) == 0 && S_ISREG(st.st_mode)) {
+						/*
+						 * okay, we found the base script!
+						 * work out how many chars we had to strip off;
+						 * then we can modify PATH_INFO
+						 * accordingly
+						 *
+						 * we now have the makings of
+						 * PATH_INFO=/test
+						 * SCRIPT_FILENAME=/docroot/info.php
+						 *
+						 * we now need to figure out what docroot is.
+						 * if DOCUMENT_ROOT is set, this is easy, otherwise,
+						 * we have to play the game of hide and seek to figure
+						 * out what SCRIPT_NAME should be
+						 */
+						int slen = len - strlen(pt);
+						int pilen = env_path_info ? strlen(env_path_info) : 0;
+						char *path_info = env_path_info ? env_path_info + pilen - slen : NULL;
+
+						if (orig_path_info != path_info) {
+							if (orig_path_info) {
+								char old;
+
+								_sapi_cgibin_putenv("ORIG_PATH_INFO", orig_path_info TSRMLS_CC);
+								old = path_info[0];
+								path_info[0] = 0;
+								if (!orig_script_name ||
+									strcmp(orig_script_name, env_path_info) != 0) {
+									if (orig_script_name) {
+										_sapi_cgibin_putenv("ORIG_SCRIPT_NAME", orig_script_name TSRMLS_CC);
+									}
+									SG(request_info).request_uri = _sapi_cgibin_putenv("SCRIPT_NAME", env_path_info TSRMLS_CC);
+								} else {
+									SG(request_info).request_uri = orig_script_name;
+								}
+								path_info[0] = old;
+							}
+							env_path_info = _sapi_cgibin_putenv("PATH_INFO", path_info TSRMLS_CC);
+						}
+						if (!orig_script_filename ||
+							strcmp(orig_script_filename, pt) != 0) {
+							if (orig_script_filename) {
+								_sapi_cgibin_putenv("ORIG_SCRIPT_FILENAME", orig_script_filename TSRMLS_CC);
+							}
+							script_path_translated = _sapi_cgibin_putenv("SCRIPT_FILENAME", pt TSRMLS_CC);
+						}
+						TRANSLATE_SLASHES(pt);
+
+						/* figure out docroot
+						   SCRIPT_FILENAME minus SCRIPT_NAME
+						*/
+
+						if (env_document_root) {
+							int l = strlen(env_document_root);
+							int path_translated_len = 0;
+							char *path_translated = NULL;
+							
+							if (l && env_document_root[l - 1] == '/') {
+								--l;
+							}
+
+							/* we have docroot, so we should have:
+							 * DOCUMENT_ROOT=/docroot
+							 * SCRIPT_FILENAME=/docroot/info.php
+							 */
+
+							/* PATH_TRANSLATED = DOCUMENT_ROOT + PATH_INFO */
+							path_translated_len = l + (env_path_info ? strlen(env_path_info) : 0);
+							path_translated = (char *) emalloc(path_translated_len + 1);
+							memcpy(path_translated, env_document_root, l);
+							if (env_path_info) {
+								memcpy(path_translated + l, env_path_info, (path_translated_len - l));
+							}
+							path_translated[path_translated_len] = '\0';
+							if (orig_path_translated) {
+								_sapi_cgibin_putenv("ORIG_PATH_TRANSLATED", orig_path_translated TSRMLS_CC);
+						   	}
+							env_path_translated = _sapi_cgibin_putenv("PATH_TRANSLATED", path_translated TSRMLS_CC);
+							efree(path_translated);
+						} else if (env_script_name && 
+								   strstr(pt, env_script_name)
+						) {
+							/* PATH_TRANSLATED = PATH_TRANSLATED - SCRIPT_NAME + PATH_INFO */
+							int ptlen = strlen(pt) - strlen(env_script_name);
+							int path_translated_len = ptlen + (env_path_info ? strlen(env_path_info) : 0);
+							char *path_translated = NULL;
+
+							path_translated = (char *) emalloc(path_translated_len + 1);
+							memcpy(path_translated, pt, ptlen);
+							if (env_path_info) {
+								memcpy(path_translated + ptlen, env_path_info, path_translated_len - ptlen);
+							}
+							path_translated[path_translated_len] = '\0';
+							if (orig_path_translated) {
+								_sapi_cgibin_putenv("ORIG_PATH_TRANSLATED", orig_path_translated TSRMLS_CC);
+						   	}
+							env_path_translated = _sapi_cgibin_putenv("PATH_TRANSLATED", path_translated TSRMLS_CC);
+							efree(path_translated);
+						}
+						break;
+					}
+				}
+				if (!ptr) {
+					/*
+					 * if we stripped out all the '/' and still didn't find
+					 * a valid path... we will fail, badly. of course we would
+					 * have failed anyway... we output 'no input file' now.
+					 */
+					if (orig_script_filename) {
+						_sapi_cgibin_putenv("ORIG_SCRIPT_FILENAME", orig_script_filename TSRMLS_CC);
+					}
+					script_path_translated = _sapi_cgibin_putenv("SCRIPT_FILENAME", NULL TSRMLS_CC);
+					SG(sapi_headers).http_response_code = 404;
+				}
+				if (!SG(request_info).request_uri) {
+					if (!orig_script_name ||
+						strcmp(orig_script_name, env_script_name) != 0) {
+						if (orig_script_name) {
+							_sapi_cgibin_putenv("ORIG_SCRIPT_NAME", orig_script_name TSRMLS_CC);
+						}
+						SG(request_info).request_uri = _sapi_cgibin_putenv("SCRIPT_NAME", env_script_name TSRMLS_CC);
+					} else {
+						SG(request_info).request_uri = orig_script_name;
+					}
+				}	
+				if (pt) {
+					efree(pt);
+				}
+				if (is_valid_path(script_path_translated)) {
+					SG(request_info).path_translated = estrdup(script_path_translated);
+				}
+			} else {
+				/* make sure path_info/translated are empty */
+				if (!orig_script_filename ||
+					(script_path_translated != orig_script_filename &&
+					strcmp(script_path_translated, orig_script_filename) != 0)) {
+					if (orig_script_filename) {
+						_sapi_cgibin_putenv("ORIG_SCRIPT_FILENAME", orig_script_filename TSRMLS_CC);
+					}
+					script_path_translated = _sapi_cgibin_putenv("SCRIPT_FILENAME", script_path_translated TSRMLS_CC);
+				}
+				if (env_redirect_url) {
+	 				if (orig_path_info) {
+						_sapi_cgibin_putenv("ORIG_PATH_INFO", orig_path_info TSRMLS_CC);
+						_sapi_cgibin_putenv("PATH_INFO", NULL TSRMLS_CC);
+					}
+					if (orig_path_translated) {
+	 					_sapi_cgibin_putenv("ORIG_PATH_TRANSLATED", orig_path_translated TSRMLS_CC);
+						_sapi_cgibin_putenv("PATH_TRANSLATED", NULL TSRMLS_CC);
+					}
+				}
+				if (env_script_name != orig_script_name) {
+					if (orig_script_name) {
+						_sapi_cgibin_putenv("ORIG_SCRIPT_NAME", orig_script_name TSRMLS_CC);
+					}
+					SG(request_info).request_uri = _sapi_cgibin_putenv("SCRIPT_NAME", env_script_name TSRMLS_CC);
+				} else {
+					SG(request_info).request_uri = env_script_name;
+				}
+				if (is_valid_path(script_path_translated)) {
+					SG(request_info).path_translated = estrdup(script_path_translated);
+				}
+				free(real_path);
+			}
+		} else {
+#endif
+			/* pre 4.3 behaviour, shouldn't be used but provides BC */
+			if (env_path_info) {
+				SG(request_info).request_uri = env_path_info;
+			} else {
+				SG(request_info).request_uri = env_script_name;
+			}
+#if !DISCARD_PATH
+			if (env_path_translated) {
+				script_path_translated = env_path_translated;
+			}
+#endif
+			if (is_valid_path(script_path_translated)) {
+				SG(request_info).path_translated = estrdup(script_path_translated);
+			}
+#if ENABLE_PATHINFO_CHECK
+		}
+#endif
+		SG(request_info).request_method = sapi_cgibin_getenv("REQUEST_METHOD", sizeof("REQUEST_METHOD")-1 TSRMLS_CC);
+		/* FIXME - Work out proto_num here */
+		SG(request_info).query_string = sapi_cgibin_getenv("QUERY_STRING", sizeof("QUERY_STRING")-1 TSRMLS_CC);
+		SG(request_info).content_type = (content_type ? content_type : "" );
+		SG(request_info).content_length = (content_length ? atoi(content_length) : 0);
+		
+		/* The CGI RFC allows servers to pass on unvalidated Authorization data */
+		auth = sapi_cgibin_getenv("HTTP_AUTHORIZATION", sizeof("HTTP_AUTHORIZATION")-1 TSRMLS_CC);
+		php_handle_auth_data(auth TSRMLS_CC);
+	}
+}
+/* }}} */
+
+
+PHP_INI_BEGIN()
+	STD_PHP_INI_ENTRY("cgi.rfc2616_headers",     "0",  PHP_INI_ALL,    OnUpdateBool,   rfc2616_headers, php_cgi_globals_struct, php_cgi_globals)
+	STD_PHP_INI_ENTRY("cgi.nph",                 "0",  PHP_INI_ALL,    OnUpdateBool,   nph, php_cgi_globals_struct, php_cgi_globals)
+	STD_PHP_INI_ENTRY("cgi.check_shebang_line",  "1",  PHP_INI_SYSTEM, OnUpdateBool,   check_shebang_line, php_cgi_globals_struct, php_cgi_globals)
+#if ENABLE_PATHINFO_CHECK
+	STD_PHP_INI_ENTRY("cgi.fix_pathinfo",        "1",  PHP_INI_SYSTEM, OnUpdateBool,   fix_pathinfo, php_cgi_globals_struct, php_cgi_globals)
+#endif
+	STD_PHP_INI_ENTRY("fastcgi.logging",         "1",  PHP_INI_SYSTEM, OnUpdateBool,   fcgi_logging, php_cgi_globals_struct, php_cgi_globals)
+# ifdef PHP_WIN32
+	STD_PHP_INI_ENTRY("fastcgi.impersonate",     "0",  PHP_INI_SYSTEM, OnUpdateBool,   impersonate, php_cgi_globals_struct, php_cgi_globals)
+# endif
+	STD_PHP_INI_ENTRY("fastcgi.error_header",    NULL, PHP_INI_SYSTEM, OnUpdateString, error_header, php_cgi_globals_struct, php_cgi_globals)
+PHP_INI_END()
+
+/* {{{ php_cgi_globals_ctor
+ */
+static void php_cgi_globals_ctor(php_cgi_globals_struct *php_cgi_globals TSRMLS_DC)
+{
+	php_cgi_globals->rfc2616_headers = 0;
+	php_cgi_globals->nph = 0;
+	php_cgi_globals->check_shebang_line = 1;
+#if ENABLE_PATHINFO_CHECK
+	php_cgi_globals->fix_pathinfo = 1;
+#endif
+	php_cgi_globals->fcgi_logging = 1;
+# ifdef PHP_WIN32
+	php_cgi_globals->impersonate = 0;
+# endif
+	php_cgi_globals->error_header = NULL;
+}
+/* }}} */
+
+/* {{{ PHP_MINIT_FUNCTION
+ */
+static PHP_MINIT_FUNCTION(cgi)
+{
+#ifdef ZTS
+	ts_allocate_id(&php_cgi_globals_id, sizeof(php_cgi_globals_struct), (ts_allocate_ctor) php_cgi_globals_ctor, NULL);
+#else
+	php_cgi_globals_ctor(&php_cgi_globals TSRMLS_CC);
+#endif
+	REGISTER_INI_ENTRIES();
+	return SUCCESS;
+}
+/* }}} */
+
+/* {{{ PHP_MSHUTDOWN_FUNCTION
+ */
+static PHP_MSHUTDOWN_FUNCTION(cgi)
+{
+	UNREGISTER_INI_ENTRIES();
+	return SUCCESS;
+}
+/* }}} */
+
+/* {{{ PHP_MINFO_FUNCTION
+ */
+static PHP_MINFO_FUNCTION(cgi)
+{
+	DISPLAY_INI_ENTRIES();
+
+	php_info_print_table_start();
+	php_info_print_table_row(2, "php-fpm", "active");
+	php_info_print_table_row(2, "php-fpm version", PHP_FPM_VERSION);
+	php_info_print_table_end();
+
+}
+/* }}} */
+
+PHP_FUNCTION(fastcgi_finish_request)
+{
+	fcgi_request *request = (fcgi_request*) SG(server_context);
+
+	if (fcgi_is_fastcgi() && request->fd >= 0) {
+
+		php_end_ob_buffers(1 TSRMLS_CC);
+		php_header(TSRMLS_C);
+
+		fcgi_flush(request, 1);
+		fcgi_close(request, 0, 0);
+		RETURN_TRUE;
+	}
+
+	RETURN_FALSE;
+
+}
+
+function_entry cgi_fcgi_sapi_functions[] = {
+	PHP_FE(fastcgi_finish_request,				NULL)
+	{NULL, NULL, NULL}
+};
+
+static zend_module_entry cgi_module_entry = {
+	STANDARD_MODULE_HEADER,
+	"cgi-fcgi",
+	cgi_fcgi_sapi_functions, 
+	PHP_MINIT(cgi), 
+	PHP_MSHUTDOWN(cgi), 
+	NULL, 
+	NULL, 
+	PHP_MINFO(cgi), 
+	NO_VERSION_YET,
+	STANDARD_MODULE_PROPERTIES
+};
+
+/* {{{ main
+ */
+int main(int argc, char *argv[])
+{
+	int free_query_string = 0;
+	int exit_status = SUCCESS;
+	int c;
+	zend_file_handle file_handle = {};
+	int retval;
+/* temporary locals */
+	int orig_optind = php_optind;
+	char *orig_optarg = php_optarg;
+	int ini_entries_len = 0;
+
+/* end of temporary locals */
+#ifdef ZTS
+	void ***tsrm_ls;
+#endif
+
+	int max_requests = 500;
+	int requests = 0;
+	int fcgi_fd = 0;
+	fcgi_request request;
+	char *fpm_config = NULL;
+
+#ifdef HAVE_SIGNAL_H
+#if defined(SIGPIPE) && defined(SIG_IGN)
+	signal(SIGPIPE, SIG_IGN); /* ignore SIGPIPE in standalone mode so
+								that sockets created via fsockopen()
+								don't kill PHP if the remote site
+								closes it.  in apache|apxs mode apache
+								does that for us!  thies@thieso.net
+								20000419 */
+#endif
+#endif
+
+#ifdef ZTS
+	tsrm_startup(1, 1, 0, NULL);
+	tsrm_ls = ts_resource(0);
+#endif
+
+	sapi_startup(&cgi_sapi_module);
+	cgi_sapi_module.php_ini_path_override = NULL;
+
+#ifdef PHP_WIN32
+	_fmode = _O_BINARY; /* sets default for file streams to binary */
+	setmode(_fileno(stdin),  O_BINARY);	/* make the stdio mode be binary */
+	setmode(_fileno(stdout), O_BINARY);	/* make the stdio mode be binary */
+	setmode(_fileno(stderr), O_BINARY);	/* make the stdio mode be binary */
+#endif
+
+	while ((c = php_getopt(argc, argv, OPTIONS, &php_optarg, &php_optind, 0)) != -1) {
+		switch (c) {
+
+			case 'c':
+				if (cgi_sapi_module.php_ini_path_override) {
+					free(cgi_sapi_module.php_ini_path_override);
+				}
+				cgi_sapi_module.php_ini_path_override = strdup(php_optarg);
+				break;
+
+			case 'n':
+				cgi_sapi_module.php_ini_ignore = 1;
+				break;
+
+			case 'C': /* don't chdir to the script directory */
+				SG(options) |= SAPI_OPTION_NO_CHDIR;
+				break;
+
+			case 'd': { 
+				/* define ini entries on command line */
+				int len = strlen(php_optarg);
+				char *val;
+
+				if ((val = strchr(php_optarg, '='))) {
+					val++;
+					if (!isalnum(*val) && *val != '"' && *val != '\'' && *val != '\0') {
+						cgi_sapi_module.ini_entries = realloc(cgi_sapi_module.ini_entries, ini_entries_len + len + sizeof("\"\"\n\0"));
+						memcpy(cgi_sapi_module.ini_entries + ini_entries_len, php_optarg, (val - php_optarg));
+						ini_entries_len += (val - php_optarg);
+						memcpy(cgi_sapi_module.ini_entries + ini_entries_len, "\"", 1);
+						ini_entries_len++;
+						memcpy(cgi_sapi_module.ini_entries + ini_entries_len, val, len - (val - php_optarg));
+						ini_entries_len += len - (val - php_optarg);
+						memcpy(cgi_sapi_module.ini_entries + ini_entries_len, "\"\n\0", sizeof("\"\n\0"));
+						ini_entries_len += sizeof("\n\0\"") - 2;
+					} else {
+						cgi_sapi_module.ini_entries = realloc(cgi_sapi_module.ini_entries, ini_entries_len + len + sizeof("\n\0"));
+						memcpy(cgi_sapi_module.ini_entries + ini_entries_len, php_optarg, len);
+						memcpy(cgi_sapi_module.ini_entries + ini_entries_len + len, "\n\0", sizeof("\n\0"));
+						ini_entries_len += len + sizeof("\n\0") - 2;
+					}
+				} else {
+					cgi_sapi_module.ini_entries = realloc(cgi_sapi_module.ini_entries, ini_entries_len + len + sizeof("=1\n\0"));
+					memcpy(cgi_sapi_module.ini_entries + ini_entries_len, php_optarg, len);
+					memcpy(cgi_sapi_module.ini_entries + ini_entries_len + len, "=1\n\0", sizeof("=1\n\0"));
+					ini_entries_len += len + sizeof("=1\n\0") - 2;
+				}
+				break;
+			}
+
+			case 'y':
+				fpm_config = php_optarg;
+				break;
+
+			case 'e': /* enable extended info output */
+				/* CG(extended_info) = 1; */ /* 5_2 */
+				CG(compiler_options) |= ZEND_COMPILE_EXTENDED_INFO; /* 5_3 */
+				break;
+
+			case 'm': /* list compiled in modules */
+				cgi_sapi_module.startup(&cgi_sapi_module);
+				php_output_startup();
+				php_output_activate(TSRMLS_C);
+				SG(headers_sent) = 1;
+				php_printf("[PHP Modules]\n");
+				print_modules(TSRMLS_C);
+				php_printf("\n[Zend Modules]\n");
+				print_extensions(TSRMLS_C);
+				php_printf("\n");
+				php_end_ob_buffers(1 TSRMLS_CC);
+				exit_status = 0;
+				goto out;
+
+			case 'i': /* php info & quit */
+				cgi_sapi_module.startup(&cgi_sapi_module);
+				if (php_request_startup(TSRMLS_C) == FAILURE) {
+					SG(server_context) = NULL;
+					php_module_shutdown(TSRMLS_C);
+					return FAILURE;
+				}
+				SG(headers_sent) = 1;
+				SG(request_info).no_headers = 1;
+				php_print_info(0xFFFFFFFF TSRMLS_CC);
+				php_request_shutdown((void *) 0);
+				exit_status = 0;
+				goto out;
+
+			case 'h':
+			case '?':
+				cgi_sapi_module.startup(&cgi_sapi_module);
+				php_output_startup();
+				php_output_activate(TSRMLS_C);
+				SG(headers_sent) = 1;
+				php_cgi_usage(argv[0]);
+				php_end_ob_buffers(1 TSRMLS_CC);
+				exit_status = 0;
+				goto out;
+
+			case 'v': /* show php version & quit */
+				cgi_sapi_module.startup(&cgi_sapi_module);
+				if (php_request_startup(TSRMLS_C) == FAILURE) {
+					SG(server_context) = NULL;
+					php_module_shutdown(TSRMLS_C);
+					return FAILURE;
+				}
+				SG(headers_sent) = 1;
+				SG(request_info).no_headers = 1;
+
+#if SUHOSIN_PATCH
+#if ZEND_DEBUG
+						php_printf("PHP %s with Suhosin-Patch %s (%s) (built: %s %s) (DEBUG)\nCopyright (c) 1997-2009 The PHP Group\n%s", PHP_VERSION, SUHOSIN_PATCH_VERSION, sapi_module.name, __DATE__, __TIME__, get_zend_version());
+#else
+						php_printf("PHP %s with Suhosin-Patch %s (%s) (built: %s %s)\nCopyright (c) 1997-2009 The PHP Group\n%s", PHP_VERSION, SUHOSIN_PATCH_VERSION, sapi_module.name, __DATE__, __TIME__, get_zend_version());
+#endif
+#else
+#if ZEND_DEBUG
+				php_printf("PHP %s (%s) (built: %s %s) (DEBUG)\nCopyright (c) 1997-2009 The PHP Group\n%s", PHP_VERSION, sapi_module.name, __DATE__, __TIME__, get_zend_version());
+#else
+				php_printf("PHP %s (%s) (built: %s %s)\nCopyright (c) 1997-2009 The PHP Group\n%s", PHP_VERSION, sapi_module.name, __DATE__, __TIME__, get_zend_version());
+#endif
+#endif
+				php_request_shutdown((void *) 0);
+				exit_status = 0;
+				goto out;
+
+		}
+
+	}
+	php_optind = orig_optind;
+	php_optarg = orig_optarg;
+
+#ifdef ZTS
+	SG(request_info).path_translated = NULL;
+#endif
+
+	cgi_sapi_module.executable_location = argv[0];
+
+	/* startup after we get the above ini override se we get things right */
+	if (cgi_sapi_module.startup(&cgi_sapi_module) == FAILURE) {
+#ifdef ZTS
+		tsrm_shutdown();
+#endif
+		return FAILURE;
+	}
+
+	if (0 > fpm_init(argc, argv, fpm_config)) {
+		return FAILURE;
+	}
+
+	fcgi_fd = fpm_run(&max_requests);
+
+	parent = 0;
+
+	fcgi_set_is_fastcgi(1);
+
+	/* make php call us to get _ENV vars */
+	php_php_import_environment_variables = php_import_environment_variables;
+	php_import_environment_variables = cgi_php_import_environment_variables;
+
+	/* library is already initialized, now init our request */
+	fcgi_init_request(&request, fcgi_fd);
+
+	zend_first_try {
+
+		/* start of FAST CGI loop */
+		/* Initialise FastCGI request structure */
+#ifdef PHP_WIN32
+		/* attempt to set security impersonation for fastcgi
+		   will only happen on NT based OS, others will ignore it. */
+		if (fastcgi && CGIG(impersonate)) {
+			fcgi_impersonate();
+		}
+#endif
+		while (fcgi_accept_request(&request) >= 0) {
+
+		request_body_fd = -1;
+
+		SG(server_context) = (void *) &request;
+
+		init_request_info(TSRMLS_C);
+
+		CG(interactive) = 0;
+
+		fpm_request_info();
+
+		/* 
+			we never take stdin if we're (f)cgi, always
+			rely on the web server giving us the info
+			we need in the environment. 
+		*/
+		if (SG(request_info).path_translated) {
+			file_handle.type = ZEND_HANDLE_FILENAME;
+			file_handle.filename = SG(request_info).path_translated;
+			file_handle.handle.fp = NULL;
+		}
+		file_handle.opened_path = NULL;
+		file_handle.free_filename = 0;
+
+		/* request startup only after we've done all we can to
+		   get path_translated */
+		if (php_request_startup(TSRMLS_C) == FAILURE) {
+			fcgi_finish_request(&request);
+			SG(server_context) = NULL;
+			php_module_shutdown(TSRMLS_C);
+			return FAILURE;
+		}
+
+		/* 
+			at this point path_translated will be set if:
+			1. we are running from shell and got filename was there
+			2. we are running as cgi or fastcgi
+		*/
+		retval = FAILURE;
+		if (SG(request_info).path_translated) {
+			if (!php_check_open_basedir(SG(request_info).path_translated TSRMLS_CC)) {
+				retval = php_fopen_primary_script(&file_handle TSRMLS_CC);
+			}
+		}
+		/* 
+			if we are unable to open path_translated and we are not
+			running from shell (so fp == NULL), then fail.
+		*/
+		if (retval == FAILURE && file_handle.handle.fp == NULL) {
+			if (errno == EACCES) {
+				SG(sapi_headers).http_response_code = 403;
+				PUTS("Access denied.\n");
+			} else {
+				SG(sapi_headers).http_response_code = 404;
+				PUTS("No input file specified.\n");
+			}
+			/* we want to serve more requests if this is fastcgi
+			   so cleanup and continue, request shutdown is
+			   handled later */
+			goto fastcgi_request_done;
+
+			STR_FREE(SG(request_info).path_translated);
+
+			if (free_query_string && SG(request_info).query_string) {
+				free(SG(request_info).query_string);
+				SG(request_info).query_string = NULL;
+			}
+
+			php_request_shutdown((void *) 0);
+			SG(server_context) = NULL;
+			php_module_shutdown(TSRMLS_C);
+			sapi_shutdown();
+#ifdef ZTS
+			tsrm_shutdown();
+#endif
+			return FAILURE;
+		}
+
+		fpm_request_executing();
+
+		php_execute_script(&file_handle TSRMLS_CC);
+
+fastcgi_request_done:
+
+		if (request_body_fd != -1) close(request_body_fd);
+
+		request_body_fd = -2;
+
+		{
+			char *path_translated;
+
+			/*	Go through this trouble so that the memory manager doesn't warn
+			 *	about SG(request_info).path_translated leaking
+			 */
+			if (SG(request_info).path_translated) {
+				path_translated = strdup(SG(request_info).path_translated);
+				STR_FREE(SG(request_info).path_translated);
+				SG(request_info).path_translated = path_translated;
+			}
+
+			if (EG(exit_status) == 255) {
+				if (CGIG(error_header) && *CGIG(error_header)) {
+					sapi_header_line ctr = {0};
+
+					ctr.line = CGIG(error_header);
+					ctr.line_len = strlen(CGIG(error_header));
+					sapi_header_op(SAPI_HEADER_REPLACE, &ctr TSRMLS_CC);
+				}
+			}
+			
+			php_request_shutdown((void *) 0);
+			if (exit_status == 0) {
+				exit_status = EG(exit_status);
+			}
+
+			if (SG(request_info).path_translated) {
+				free(SG(request_info).path_translated);
+				SG(request_info).path_translated = NULL;
+			}
+			if (free_query_string && SG(request_info).query_string) {
+				free(SG(request_info).query_string);
+				SG(request_info).query_string = NULL;
+			}
+
+		}
+
+		requests++;
+		if (max_requests && (requests == max_requests)) {
+			fcgi_finish_request(&request);
+			break;
+		}
+
+		/* end of fastcgi loop */
+		}
+
+		fcgi_shutdown();
+
+		if (fcgi_in_shutdown() || 								/* graceful shutdown by a signal */
+				(max_requests && (requests == max_requests))	/* we were told to process max_requests and we are done */
+			) {
+			exit_status = 0;
+		}
+		else {
+			exit_status = 255;
+		}
+
+		if (cgi_sapi_module.php_ini_path_override) {
+			free(cgi_sapi_module.php_ini_path_override);
+		}
+		if (cgi_sapi_module.ini_entries) {
+			free(cgi_sapi_module.ini_entries);
+		}
+	} zend_catch {
+		exit_status = 255;
+	} zend_end_try();
+
+out:
+
+	SG(server_context) = NULL;
+	php_module_shutdown(TSRMLS_C);
+	sapi_shutdown();
+
+#ifdef ZTS
+	/*tsrm_shutdown();*/
+#endif
+
+#if defined(PHP_WIN32) && ZEND_DEBUG && 0
+	_CrtDumpMemoryLeaks();
+#endif
+
+	return exit_status;
+}
+/* }}} */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: sw=4 ts=4 fdm=marker
+ * vim<600: sw=4 ts=4
+ */
diff -Naur php-src-vanilla/sapi/fpm/cgi/CREDITS php-src/sapi/fpm/cgi/CREDITS
--- php-src-vanilla/sapi/fpm/cgi/CREDITS	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/cgi/CREDITS	2009-10-18 21:05:39.302497288 +0100
@@ -0,0 +1,2 @@
+CGI / FastCGI
+Rasmus Lerdorf, Stig Bakken, Shane Caraveo, Dmitry Stogov
diff -Naur php-src-vanilla/sapi/fpm/cgi/fastcgi.c php-src/sapi/fpm/cgi/fastcgi.c
--- php-src-vanilla/sapi/fpm/cgi/fastcgi.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/cgi/fastcgi.c	2009-10-18 21:05:39.302497288 +0100
@@ -0,0 +1,1319 @@
+/*
+   +----------------------------------------------------------------------+
+   | PHP Version 5                                                        |
+   +----------------------------------------------------------------------+
+   | Copyright (c) 1997-2008 The PHP Group                                |
+   +----------------------------------------------------------------------+
+   | This source file is subject to version 3.01 of the PHP license,      |
+   | that is bundled with this package in the file LICENSE, and is        |
+   | available through the world-wide-web at the following url:           |
+   | http://www.php.net/license/3_01.txt                                  |
+   | If you did not receive a copy of the PHP license and are unable to   |
+   | obtain it through the world-wide-web, please send a note to          |
+   | license@php.net so we can mail you a copy immediately.               |
+   +----------------------------------------------------------------------+
+   | Authors: Dmitry Stogov <dmitry@zend.com>                             |
+   +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+
+#include <php.h>
+#include "fastcgi.h"
+
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <errno.h>
+
+#ifdef FPM_AUTOCONFIG_H
+#include <fpm_autoconfig.h>
+#else
+#include <php_config.h>
+#endif
+#include <fpm/fpm.h>
+#include <fpm/fpm_request.h>
+
+#ifdef _WIN32
+
+#include <windows.h>
+
+	typedef unsigned int in_addr_t;
+
+	struct sockaddr_un {
+		short   sun_family;
+		char    sun_path[MAXPATHLEN];
+	};
+
+	static HANDLE fcgi_accept_mutex = INVALID_HANDLE_VALUE;
+	static int is_impersonate = 0;
+
+#define FCGI_LOCK(fd) \
+	if (fcgi_accept_mutex != INVALID_HANDLE_VALUE) { \
+		DWORD ret; \
+		while ((ret = WaitForSingleObject(fcgi_accept_mutex, 1000)) == WAIT_TIMEOUT) { \
+			if (in_shutdown) return -1; \
+		} \
+		if (ret == WAIT_FAILED) { \
+			fprintf(stderr, "WaitForSingleObject() failed\n"); \
+			return -1; \
+		} \
+	}
+
+#define FCGI_UNLOCK(fd) \
+	if (fcgi_accept_mutex != INVALID_HANDLE_VALUE) { \
+		ReleaseMutex(fcgi_accept_mutex); \
+	}
+
+#else
+
+# include <sys/types.h>
+# include <sys/stat.h>
+# include <unistd.h>
+# include <fcntl.h>
+# include <sys/socket.h>
+# include <sys/un.h>
+# include <netinet/in.h>
+# include <arpa/inet.h>
+# include <netdb.h>
+# include <signal.h>
+
+# define closesocket(s) close(s)
+
+# if defined(HAVE_SYS_POLL_H) && defined(HAVE_POLL)
+#  include <sys/poll.h>
+# endif
+# if defined(HAVE_SYS_SELECT_H)
+#  include <sys/select.h>
+# endif
+
+#ifndef INADDR_NONE
+#define INADDR_NONE ((unsigned long) -1)
+#endif
+
+# ifndef HAVE_SOCKLEN_T
+	typedef unsigned int socklen_t;
+# endif
+
+# ifdef USE_LOCKING
+#  define FCGI_LOCK(fd)								\
+	do {											\
+		struct flock lock;							\
+		lock.l_type = F_WRLCK;						\
+		lock.l_start = 0;							\
+		lock.l_whence = SEEK_SET;					\
+		lock.l_len = 0;								\
+		if (fcntl(fd, F_SETLKW, &lock) != -1) {		\
+			break;									\
+		} else if (errno != EINTR || in_shutdown) {	\
+			return -1;								\
+		}											\
+	} while (1)
+
+#  define FCGI_UNLOCK(fd)							\
+	do {											\
+		int orig_errno = errno;						\
+		while (1) {									\
+			struct flock lock;						\
+			lock.l_type = F_UNLCK;					\
+			lock.l_start = 0;						\
+			lock.l_whence = SEEK_SET;				\
+			lock.l_len = 0;							\
+			if (fcntl(fd, F_SETLK, &lock) != -1) {	\
+				break;								\
+			} else if (errno != EINTR) {			\
+				return -1;							\
+			}										\
+		}											\
+		errno = orig_errno;							\
+	} while (0)
+# else
+#  define FCGI_LOCK(fd)
+#  define FCGI_UNLOCK(fd)
+# endif
+
+#endif
+
+typedef union _sa_t {
+	struct sockaddr     sa;
+	struct sockaddr_un  sa_unix;
+	struct sockaddr_in  sa_inet;
+} sa_t;
+
+static HashTable *fcgi_mgmt_vars;
+
+static int is_initialized = 0;
+static int is_fastcgi = 0;
+static int in_shutdown = 0;
+static in_addr_t *allowed_clients = NULL;
+
+#ifdef _WIN32
+
+static DWORD WINAPI fcgi_shutdown_thread(LPVOID arg)
+{
+	HANDLE shutdown_event = (HANDLE) arg;
+	WaitForSingleObject(shutdown_event, INFINITE);
+	in_shutdown = 1;
+	return 0;
+}
+
+#else
+
+static void fcgi_signal_handler(int signo)
+{
+	if (signo == SIGUSR1 || signo == SIGTERM) {
+		in_shutdown = 1;
+	}
+}
+
+static void fcgi_setup_signals(void)
+{
+	struct sigaction new_sa, old_sa;
+
+	sigemptyset(&new_sa.sa_mask);
+	new_sa.sa_flags = 0;
+	new_sa.sa_handler = fcgi_signal_handler;
+	sigaction(SIGUSR1, &new_sa, NULL);
+	sigaction(SIGTERM, &new_sa, NULL);
+	sigaction(SIGPIPE, NULL, &old_sa);
+	if (old_sa.sa_handler == SIG_DFL) {
+		sigaction(SIGPIPE, &new_sa, NULL);
+	}
+}
+#endif
+
+int fcgi_in_shutdown(void)
+{
+	return in_shutdown;
+}
+
+int fcgi_init(void)
+{
+	if (!is_initialized) {
+		fcgi_mgmt_vars = pemalloc(sizeof(HashTable), 1);
+		zend_hash_init(fcgi_mgmt_vars, 3, NULL, fcgi_free_mgmt_var_cb, 1);
+		fcgi_set_mgmt_var("FCGI_MAX_CONNS", sizeof("FCGI_MAX_CONNS")-1, "1", sizeof("1")-1);
+		fcgi_set_mgmt_var("FCGI_MAX_REQS",  sizeof("FCGI_MAX_REQS")-1, "1", sizeof("1")-1);
+		fcgi_set_mgmt_var("FCGI_MPXS_CONNS", sizeof("FCGI_MPXS_CONNS")-1, "0", sizeof("0")-1);
+#ifdef _WIN32
+# if 0
+		/* TODO: Support for TCP sockets */
+		WSADATA wsaData;
+
+		if (WSAStartup(MAKEWORD(2,0), &wsaData)) {
+			fprintf(stderr, "Error starting Windows Sockets.  Error: %d", WSAGetLastError());
+			return 0;
+		}
+# endif
+		is_initialized = 1;
+
+		if ((GetStdHandle(STD_OUTPUT_HANDLE) == INVALID_HANDLE_VALUE) &&
+		    (GetStdHandle(STD_ERROR_HANDLE)  == INVALID_HANDLE_VALUE) &&
+		    (GetStdHandle(STD_INPUT_HANDLE)  != INVALID_HANDLE_VALUE)) {
+			char *str;
+			DWORD pipe_mode = PIPE_READMODE_BYTE | PIPE_WAIT;
+			HANDLE pipe = GetStdHandle(STD_INPUT_HANDLE);
+
+			SetNamedPipeHandleState(pipe, &pipe_mode, NULL, NULL);
+
+			str = getenv("_FCGI_SHUTDOWN_EVENT_");
+			if (str != NULL) {
+				HANDLE shutdown_event = (HANDLE) atoi(str);
+				if (!CreateThread(NULL, 0, fcgi_shutdown_thread,
+				                  shutdown_event, 0, NULL)) {
+					return -1;
+				}
+			}
+			str = getenv("_FCGI_MUTEX_");
+			if (str != NULL) {
+				fcgi_accept_mutex = (HANDLE) atoi(str);
+			}
+			return is_fastcgi = 1;
+		} else {
+			return is_fastcgi = 0;
+		}
+#else
+		sa_t sa;
+		socklen_t len = sizeof(sa);
+
+		is_initialized = 1;
+		errno = 0;
+		if (getpeername(0, (struct sockaddr *)&sa, &len) != 0 && errno == ENOTCONN) {
+			fcgi_setup_signals();
+			return is_fastcgi = 1;
+		} else {
+			return is_fastcgi = 0;
+		}
+
+		fcgi_set_allowed_clients(getenv("FCGI_WEB_SERVER_ADDRS"));
+#endif
+	}
+	return is_fastcgi;
+}
+
+
+int fcgi_is_fastcgi(void)
+{
+	if (!is_initialized) {
+		return fcgi_init();
+	} else {
+		return is_fastcgi;
+	}
+}
+
+void fcgi_set_is_fastcgi(int new_value)
+{
+	is_fastcgi = new_value;
+}
+
+void fcgi_set_in_shutdown(int new_value)
+{
+	in_shutdown = new_value;
+}
+
+void fcgi_shutdown(void)
+{
+	if (is_initialized) {
+		zend_hash_destroy(fcgi_mgmt_vars);
+		pefree(fcgi_mgmt_vars, 1);
+	}
+	is_fastcgi = 0;
+
+	if (allowed_clients) {
+		free(allowed_clients);
+		allowed_clients = 0;
+	}
+}
+
+#ifdef _WIN32
+/* Do some black magic with the NT security API.
+ * We prepare a DACL (Discretionary Access Control List) so that
+ * we, the creator, are allowed all access, while "Everyone Else"
+ * is only allowed to read and write to the pipe.
+ * This avoids security issues on shared hosts where a luser messes
+ * with the lower-level pipe settings and screws up the FastCGI service.
+ */
+static PACL prepare_named_pipe_acl(PSECURITY_DESCRIPTOR sd, LPSECURITY_ATTRIBUTES sa)
+{
+  DWORD req_acl_size;
+  char everyone_buf[32], owner_buf[32];
+  PSID sid_everyone, sid_owner;
+  SID_IDENTIFIER_AUTHORITY
+    siaWorld = SECURITY_WORLD_SID_AUTHORITY,
+    siaCreator = SECURITY_CREATOR_SID_AUTHORITY;
+  PACL acl;
+
+  sid_everyone = (PSID)&everyone_buf;
+  sid_owner = (PSID)&owner_buf;
+
+  req_acl_size = sizeof(ACL) +
+    (2 * ((sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) + GetSidLengthRequired(1)));
+
+  acl = malloc(req_acl_size);
+
+  if (acl == NULL) {
+    return NULL;
+  }
+
+  if (!InitializeSid(sid_everyone, &siaWorld, 1)) {
+    goto out_fail;
+  }
+  *GetSidSubAuthority(sid_everyone, 0) = SECURITY_WORLD_RID;
+
+  if (!InitializeSid(sid_owner, &siaCreator, 1)) {
+    goto out_fail;
+  }
+  *GetSidSubAuthority(sid_owner, 0) = SECURITY_CREATOR_OWNER_RID;
+
+  if (!InitializeAcl(acl, req_acl_size, ACL_REVISION)) {
+    goto out_fail;
+  }
+
+  if (!AddAccessAllowedAce(acl, ACL_REVISION, FILE_GENERIC_READ | FILE_GENERIC_WRITE, sid_everyone)) {
+    goto out_fail;
+  }
+
+  if (!AddAccessAllowedAce(acl, ACL_REVISION, FILE_ALL_ACCESS, sid_owner)) {
+    goto out_fail;
+  }
+
+  if (!InitializeSecurityDescriptor(sd, SECURITY_DESCRIPTOR_REVISION)) {
+    goto out_fail;
+  }
+
+  if (!SetSecurityDescriptorDacl(sd, TRUE, acl, FALSE)) {
+    goto out_fail;
+  }
+
+  sa->lpSecurityDescriptor = sd;
+
+  return acl;
+
+out_fail:
+  free(acl);
+  return NULL;
+}
+#endif
+
+void fcgi_set_allowed_clients(char *ip)
+{
+    char *cur, *end;
+    int n;
+	    
+    if (ip) {
+    	ip = strdup(ip);
+    	cur = ip;
+    	n = 0;
+    	while (*cur) {
+    		if (*cur == ',') n++;
+    		cur++;
+    	}
+		if (allowed_clients) free(allowed_clients);
+    	allowed_clients = malloc(sizeof(in_addr_t) * (n+2));
+    	n = 0;
+    	cur = ip;
+    	while (cur) {
+	    	end = strchr(cur, ',');
+	    	if (end) {
+    			*end = 0;
+    			end++;
+    		}
+    		allowed_clients[n] = inet_addr(cur);
+    		if (allowed_clients[n] == INADDR_NONE) {
+				fprintf(stderr, "Wrong IP address '%s' in FCGI_WEB_SERVER_ADDRS\n", cur);
+    		}
+    		n++;
+    		cur = end;
+    	}
+    	allowed_clients[n] = INADDR_NONE;
+		free(ip);
+	}
+}
+
+static int is_port_number(const char *bindpath)
+{
+	while (*bindpath) {
+		if (*bindpath < '0' || *bindpath > '9') {
+			return 0;
+		}
+		bindpath++;
+	}
+	return 1;
+}
+
+int fcgi_listen(const char *path, int backlog)
+{
+	char     *s;
+	int       tcp = 0;
+	char      host[MAXPATHLEN];
+	short     port = 0;
+	int       listen_socket;
+	sa_t      sa;
+	socklen_t sock_len;
+#ifdef SO_REUSEADDR
+# ifdef _WIN32
+	BOOL reuse = 1;
+# else
+	int reuse = 1;
+# endif
+#endif
+
+	if ((s = strchr(path, ':'))) {
+		port = atoi(s+1);
+		if (port != 0 && (s-path) < MAXPATHLEN) {
+			strncpy(host, path, s-path);
+			host[s-path] = '\0';
+			tcp = 1;
+		}
+	} else if (is_port_number(path)) {
+		port = atoi(path);
+		if (port != 0) {
+			host[0] = '\0';
+			tcp = 1;
+		}
+	}
+
+	/* Prepare socket address */
+	if (tcp) {
+		memset(&sa.sa_inet, 0, sizeof(sa.sa_inet));
+		sa.sa_inet.sin_family = AF_INET;
+		sa.sa_inet.sin_port = htons(port);
+		sock_len = sizeof(sa.sa_inet);
+
+		if (!*host || !strncmp(host, "*", sizeof("*")-1)) {
+			sa.sa_inet.sin_addr.s_addr = htonl(INADDR_ANY);
+		} else {
+			sa.sa_inet.sin_addr.s_addr = inet_addr(host);
+			if (sa.sa_inet.sin_addr.s_addr == INADDR_NONE) {
+				struct hostent *hep;
+
+				hep = gethostbyname(host);
+				if (!hep || hep->h_addrtype != AF_INET || !hep->h_addr_list[0]) {
+					fprintf(stderr, "Cannot resolve host name '%s'!\n", host);
+					return -1;
+				} else if (hep->h_addr_list[1]) {
+					fprintf(stderr, "Host '%s' has multiple addresses. You must choose one explicitly!\n", host);
+					return -1;
+				}
+				sa.sa_inet.sin_addr.s_addr = ((struct in_addr*)hep->h_addr_list[0])->s_addr;
+			}
+		}
+	} else {
+#ifdef _WIN32
+	    SECURITY_DESCRIPTOR  sd;
+    	SECURITY_ATTRIBUTES  sa;
+	    PACL                 acl;
+		HANDLE namedPipe;
+
+		memset(&sa, 0, sizeof(sa));
+		sa.nLength = sizeof(sa);
+		sa.bInheritHandle = FALSE;
+		acl = prepare_named_pipe_acl(&sd, &sa);
+
+		namedPipe = CreateNamedPipe(path,
+			PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
+			PIPE_TYPE_BYTE | PIPE_WAIT | PIPE_READMODE_BYTE,
+			PIPE_UNLIMITED_INSTANCES,
+			8192, 8192, 0, &sa);
+		if (namedPipe == INVALID_HANDLE_VALUE) {
+			return -1;
+		}		
+		listen_socket = _open_osfhandle((long)namedPipe, 0);
+		if (!is_initialized) {
+			fcgi_init();
+		}
+		is_fastcgi = 1;
+		return listen_socket;
+
+#else
+		int path_len = strlen(path);
+
+		if (path_len >= sizeof(sa.sa_unix.sun_path)) {
+			fprintf(stderr, "Listening socket's path name is too long.\n");
+			return -1;
+		}
+
+		memset(&sa.sa_unix, 0, sizeof(sa.sa_unix));
+		sa.sa_unix.sun_family = AF_UNIX;
+		memcpy(sa.sa_unix.sun_path, path, path_len + 1);
+		sock_len = (size_t)(((struct sockaddr_un *)0)->sun_path)	+ path_len;
+#ifdef HAVE_SOCKADDR_UN_SUN_LEN
+		sa.sa_unix.sun_len = sock_len;
+#endif
+		unlink(path);
+#endif
+	}
+
+	/* Create, bind socket and start listen on it */
+	if ((listen_socket = socket(sa.sa.sa_family, SOCK_STREAM, 0)) < 0 ||
+#ifdef SO_REUSEADDR
+	    setsockopt(listen_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&reuse, sizeof(reuse)) < 0 ||
+#endif
+	    bind(listen_socket, (struct sockaddr *) &sa, sock_len) < 0 ||
+	    listen(listen_socket, backlog) < 0) {
+
+		fprintf(stderr, "Cannot bind/listen socket - [%d] %s.\n",errno, strerror(errno));
+		return -1;
+	}
+
+	if (!tcp) {
+		chmod(path, 0777);
+	}
+
+	if (!is_initialized) {
+		fcgi_init();
+	}
+	is_fastcgi = 1;
+
+#ifdef _WIN32
+	if (tcp) {
+		listen_socket = _open_osfhandle((long)listen_socket, 0);
+	}
+#else
+	fcgi_setup_signals();
+#endif
+	return listen_socket;
+}
+
+void fcgi_init_request(fcgi_request *req, int listen_socket)
+{
+	memset(req, 0, sizeof(fcgi_request));
+	req->listen_socket = listen_socket;
+	req->fd = -1;
+	req->id = -1;
+
+	req->in_len = 0;
+	req->in_pad = 0;
+
+	req->out_hdr  = NULL;
+	req->out_pos  = req->out_buf;
+
+#ifdef _WIN32
+	req->tcp = !GetNamedPipeInfo((HANDLE)_get_osfhandle(req->listen_socket), NULL, NULL, NULL, NULL);
+#endif
+}
+
+static inline ssize_t safe_write(fcgi_request *req, const void *buf, size_t count)
+{
+	int    ret;
+	size_t n = 0;
+
+	do {
+		errno = 0;
+#ifdef _WIN32
+		if (!req->tcp) {
+			ret = write(req->fd, ((char*)buf)+n, count-n);
+		} else {
+			ret = send(req->fd, ((char*)buf)+n, count-n, 0);
+			if (ret <= 0) {
+				errno = WSAGetLastError();
+			}
+		}
+#else
+		ret = write(req->fd, ((char*)buf)+n, count-n);
+#endif
+		if (ret > 0) {
+			n += ret;
+		} else if (ret <= 0 && errno != 0 && errno != EINTR) {
+			return ret;
+		}
+	} while (n != count);
+	return n;
+}
+
+static inline ssize_t safe_read(fcgi_request *req, const void *buf, size_t count)
+{
+	int    ret;
+	size_t n = 0;
+
+	do {
+		errno = 0;
+#ifdef _WIN32
+		if (!req->tcp) {
+			ret = read(req->fd, ((char*)buf)+n, count-n);
+		} else {
+			ret = recv(req->fd, ((char*)buf)+n, count-n, 0);
+			if (ret <= 0) {
+				errno = WSAGetLastError();
+			}
+		}
+#else
+		ret = read(req->fd, ((char*)buf)+n, count-n);
+#endif
+		if (ret > 0) {
+			n += ret;
+		} else if (ret == 0 && errno == 0) {
+			return n;
+		} else if (ret <= 0 && errno != 0 && errno != EINTR) {
+			return ret;
+		}
+	} while (n != count);
+	return n;
+}
+
+static inline int fcgi_make_header(fcgi_header *hdr, fcgi_request_type type, int req_id, int len)
+{
+	int pad = ((len + 7) & ~7) - len;
+
+	hdr->contentLengthB0 = (unsigned char)(len & 0xff);
+	hdr->contentLengthB1 = (unsigned char)((len >> 8) & 0xff);
+	hdr->paddingLength = (unsigned char)pad;
+	hdr->requestIdB0 = (unsigned char)(req_id & 0xff);
+	hdr->requestIdB1 = (unsigned char)((req_id >> 8) & 0xff);
+	hdr->reserved = 0;
+	hdr->type = type;
+	hdr->version = FCGI_VERSION_1;
+	if (pad) {
+		memset(((unsigned char*)hdr) + sizeof(fcgi_header) + len, 0, pad);
+	}
+	return pad;
+}
+
+static int fcgi_get_params(fcgi_request *req, unsigned char *p, unsigned char *end)
+{
+	char buf[128];
+	char *tmp = buf;
+	int buf_size = sizeof(buf);
+	int name_len, val_len;
+	char *s;
+	int ret = 1;
+
+	while (p < end) {
+		name_len = *p++;
+		if (name_len >= 128) {
+			name_len = ((name_len & 0x7f) << 24);
+			name_len |= (*p++ << 16);
+			name_len |= (*p++ << 8);
+			name_len |= *p++;
+		}
+		val_len = *p++;
+		if (val_len >= 128) {
+			val_len = ((val_len & 0x7f) << 24);
+			val_len |= (*p++ << 16);
+			val_len |= (*p++ << 8);
+			val_len |= *p++;
+		}
+		if (name_len + val_len < 0 ||
+		    name_len + val_len > end - p) {
+			/* Malformated request */
+			ret = 0;
+			break;
+		}
+		if (name_len+1 >= buf_size) {
+			buf_size = name_len + 64;
+			tmp = (tmp == buf ? emalloc(buf_size): erealloc(tmp, buf_size));
+		}
+		memcpy(tmp, p, name_len);
+		tmp[name_len] = 0;
+		s = zend_strndup((char*)p + name_len, val_len);
+		zend_hash_update(&req->env, tmp, name_len+1, &s, sizeof(char*), NULL);
+		p += name_len + val_len;
+	}
+	if (tmp != buf && tmp != NULL) {
+		efree(tmp);
+	}
+	return ret;
+}
+
+static void fcgi_free_var(char **s)
+{
+	free(*s);
+}
+
+static int fcgi_read_request(fcgi_request *req)
+{
+	fcgi_header hdr;
+	int len, padding;
+	unsigned char buf[FCGI_MAX_LENGTH+8];
+
+	req->keep = 0;
+	req->in_len = 0;
+	req->out_hdr = NULL;
+	req->out_pos = req->out_buf;
+	zend_hash_init(&req->env, 0, NULL, (void (*)(void *)) fcgi_free_var, 1);
+
+	if (safe_read(req, &hdr, sizeof(fcgi_header)) != sizeof(fcgi_header) ||
+	    hdr.version < FCGI_VERSION_1) {
+		return 0;
+	}
+
+	len = (hdr.contentLengthB1 << 8) | hdr.contentLengthB0;
+	padding = hdr.paddingLength;
+
+	while (hdr.type == FCGI_STDIN && len == 0) {
+		if (safe_read(req, &hdr, sizeof(fcgi_header)) != sizeof(fcgi_header) ||
+		    hdr.version < FCGI_VERSION_1) {
+			return 0;
+		}
+
+		len = (hdr.contentLengthB1 << 8) | hdr.contentLengthB0;
+		padding = hdr.paddingLength;
+	}
+
+	if (len + padding > FCGI_MAX_LENGTH) {
+		return 0;
+	}
+
+	req->id = (hdr.requestIdB1 << 8) + hdr.requestIdB0;
+
+	if (hdr.type == FCGI_BEGIN_REQUEST && len == sizeof(fcgi_begin_request)) {
+		char *val;
+
+		if (safe_read(req, buf, len+padding) != len+padding) {
+			return 0;
+		}
+
+		req->keep = (((fcgi_begin_request*)buf)->flags & FCGI_KEEP_CONN);
+		switch ((((fcgi_begin_request*)buf)->roleB1 << 8) + ((fcgi_begin_request*)buf)->roleB0) {
+			case FCGI_RESPONDER:
+				val = strdup("RESPONDER");
+				zend_hash_update(&req->env, "FCGI_ROLE", sizeof("FCGI_ROLE"), &val, sizeof(char*), NULL);
+				break;
+			case FCGI_AUTHORIZER:
+				val = strdup("AUTHORIZER");
+				zend_hash_update(&req->env, "FCGI_ROLE", sizeof("FCGI_ROLE"), &val, sizeof(char*), NULL);
+				break;
+			case FCGI_FILTER:
+				val = strdup("FILTER");
+				zend_hash_update(&req->env, "FCGI_ROLE", sizeof("FCGI_ROLE"), &val, sizeof(char*), NULL);
+				break;
+			default:
+				return 0;
+		}
+
+		if (safe_read(req, &hdr, sizeof(fcgi_header)) != sizeof(fcgi_header) ||
+		    hdr.version < FCGI_VERSION_1) {
+			return 0;
+		}
+
+		len = (hdr.contentLengthB1 << 8) | hdr.contentLengthB0;
+		padding = hdr.paddingLength;
+
+		while (hdr.type == FCGI_PARAMS && len > 0) {
+			if (len + padding > FCGI_MAX_LENGTH) {
+				return 0;
+			}
+
+			if (safe_read(req, buf, len+padding) != len+padding) {
+				req->keep = 0;
+				return 0;
+			}
+
+			if (!fcgi_get_params(req, buf, buf+len)) {
+				req->keep = 0;
+				return 0;
+			}
+
+			if (safe_read(req, &hdr, sizeof(fcgi_header)) != sizeof(fcgi_header) ||
+			    hdr.version < FCGI_VERSION_1) {
+				req->keep = 0;
+				return 0;
+			}
+			len = (hdr.contentLengthB1 << 8) | hdr.contentLengthB0;
+			padding = hdr.paddingLength;
+		}
+	} else if (hdr.type == FCGI_GET_VALUES) {
+		unsigned char *p = buf + sizeof(fcgi_header);
+		HashPosition pos;
+		char * str_index;
+		uint str_length;
+		ulong num_index;
+		int key_type;
+		zval ** value;
+
+		if (safe_read(req, buf, len+padding) != len+padding) {
+			req->keep = 0;
+			return 0;
+		}
+
+		if (!fcgi_get_params(req, buf, buf+len)) {
+			req->keep = 0;
+			return 0;
+		}
+
+		zend_hash_internal_pointer_reset_ex(&req->env, &pos);
+		while ((key_type = zend_hash_get_current_key_ex(&req->env, &str_index, &str_length, &num_index, 0, &pos)) != HASH_KEY_NON_EXISTANT) {
+			int zlen;
+			zend_hash_move_forward_ex(&req->env, &pos);
+			if (key_type != HASH_KEY_IS_STRING) {
+				continue;
+			}
+			if (zend_hash_find(fcgi_mgmt_vars, str_index, str_length, (void**) &value) != SUCCESS) {
+				continue;
+			}
+			--str_length;
+			zlen = Z_STRLEN_PP(value);
+			if ((p + 4 + 4 + str_length + zlen) >= (buf + sizeof(buf))) {
+				break;
+			}
+			if (str_length < 0x80) {
+				*p++ = str_length;
+			} else {
+				*p++ = ((str_length >> 24) & 0xff) | 0x80;
+				*p++ = (str_length >> 16) & 0xff;
+				*p++ = (str_length >> 8) & 0xff;
+				*p++ = str_length & 0xff;
+			}
+			if (zlen < 0x80) {
+				*p++ = zlen;
+			} else {
+				*p++ = ((zlen >> 24) & 0xff) | 0x80;
+				*p++ = (zlen >> 16) & 0xff;
+				*p++ = (zlen >> 8) & 0xff;
+				*p++ = zlen & 0xff;
+			}
+			memcpy(p, str_index, str_length);
+			p += str_length;
+			memcpy(p, Z_STRVAL_PP(value), zlen);
+			p += zlen;
+		}
+		len = p - buf - sizeof(fcgi_header);
+		len += fcgi_make_header((fcgi_header*)buf, FCGI_GET_VALUES_RESULT, 0, len);
+		if (safe_write(req, buf, sizeof(fcgi_header)+len) != (int)sizeof(fcgi_header)+len) {
+			req->keep = 0;
+			return 0;
+		}
+		return 0;
+	} else {
+		return 0;
+	}
+
+	return 1;
+}
+
+int fcgi_read(fcgi_request *req, char *str, int len)
+{
+	int ret, n, rest;
+	fcgi_header hdr;
+	unsigned char buf[255];
+
+	n = 0;
+	rest = len;
+	while (rest > 0) {
+		if (req->in_len == 0) {
+			if (safe_read(req, &hdr, sizeof(fcgi_header)) != sizeof(fcgi_header) ||
+			    hdr.version < FCGI_VERSION_1 ||
+			    hdr.type != FCGI_STDIN) {
+				req->keep = 0;
+				return 0;
+			}
+			req->in_len = (hdr.contentLengthB1 << 8) | hdr.contentLengthB0;
+			req->in_pad = hdr.paddingLength;
+			if (req->in_len == 0) {
+				return n;
+			}
+		}
+
+		if (req->in_len >= rest) {
+			ret = safe_read(req, str, rest);
+		} else {
+			ret = safe_read(req, str, req->in_len);
+		}
+		if (ret < 0) {
+			req->keep = 0;
+			return ret;
+		} else if (ret > 0) {
+			req->in_len -= ret;
+			rest -= ret;
+			n += ret;
+			str += ret;
+			if (req->in_len == 0) {
+				if (req->in_pad) {
+					if (safe_read(req, buf, req->in_pad) != req->in_pad) {
+						req->keep = 0;
+						return ret;
+					}
+				}
+			} else {
+				return n;
+			}
+		} else {
+			return n;
+		}
+	}
+	return n;
+}
+
+void fcgi_close(fcgi_request *req, int force, int destroy)
+{
+	if (destroy) {
+		zend_hash_destroy(&req->env);
+	}
+
+#ifdef _WIN32
+	if (is_impersonate && !req->tcp) {
+		RevertToSelf();
+	}
+#endif
+
+	if ((force || !req->keep) && req->fd >= 0) {
+#ifdef _WIN32
+		if (!req->tcp) {
+			HANDLE pipe = (HANDLE)_get_osfhandle(req->fd);
+
+			if (!force) {
+				FlushFileBuffers(pipe);
+			}
+			DisconnectNamedPipe(pipe);
+		} else {
+			if (!force) {
+				char buf[8];
+
+				shutdown(req->fd, 1);
+				while (recv(req->fd, buf, sizeof(buf), 0) > 0) {}
+			}
+			closesocket(req->fd);
+		}
+#else
+		if (!force) {
+			char buf[8];
+
+			shutdown(req->fd, 1);
+			while (recv(req->fd, buf, sizeof(buf), 0) > 0) {}
+		}
+		close(req->fd);
+#endif
+		req->fd = -1;
+
+		fpm_request_finished();
+	}
+}
+
+int fcgi_accept_request(fcgi_request *req)
+{
+#ifdef _WIN32
+	HANDLE pipe;
+	OVERLAPPED ov;
+#endif
+	fcgi_finish_request(req);
+
+	while (1) {
+		if (req->fd < 0) {
+			while (1) {
+				if (in_shutdown) {
+					return -1;
+				}
+#ifdef _WIN32
+				if (!req->tcp) {
+					pipe = (HANDLE)_get_osfhandle(req->listen_socket);
+					FCGI_LOCK(req->listen_socket);
+					ov.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
+					if (!ConnectNamedPipe(pipe, &ov)) {
+						errno = GetLastError();
+						if (errno == ERROR_IO_PENDING) {
+							while (WaitForSingleObject(ov.hEvent, 1000) == WAIT_TIMEOUT) {
+								if (in_shutdown) {
+									CloseHandle(ov.hEvent);
+									FCGI_UNLOCK(req->listen_socket);
+									return -1;
+								}
+							}
+						} else if (errno != ERROR_PIPE_CONNECTED) {
+						}
+					}
+					CloseHandle(ov.hEvent);
+					req->fd = req->listen_socket;
+					FCGI_UNLOCK(req->listen_socket);
+				} else {
+					SOCKET listen_socket = (SOCKET)_get_osfhandle(req->listen_socket);
+#else
+				{
+					int listen_socket = req->listen_socket;
+#endif
+					sa_t sa;
+					socklen_t len = sizeof(sa);
+
+					fpm_request_accepting();
+
+					FCGI_LOCK(req->listen_socket);
+					req->fd = accept(listen_socket, (struct sockaddr *)&sa, &len);
+					FCGI_UNLOCK(req->listen_socket);
+					if (req->fd >= 0 && allowed_clients) {
+						int n = 0;
+						int allowed = 0;
+
+			    		while (allowed_clients[n] != INADDR_NONE) {
+			    			if (allowed_clients[n] == sa.sa_inet.sin_addr.s_addr) {
+			    				allowed = 1;
+			    				break;
+			    			}
+			    			n++;
+			    		}
+						if (!allowed) {
+							fprintf(stderr, "Connection from disallowed IP address '%s' is dropped.\n", inet_ntoa(sa.sa_inet.sin_addr));
+							closesocket(req->fd);
+							req->fd = -1;
+							continue;
+						}
+					}
+				}
+
+#ifdef _WIN32
+				if (req->fd < 0 && (in_shutdown || errno != EINTR)) {
+#else
+				if (req->fd < 0 && (in_shutdown || (errno != EINTR && errno != ECONNABORTED))) {
+#endif
+					return -1;
+				}
+
+#ifdef _WIN32
+				break;
+#else
+				if (req->fd >= 0) {
+
+					fpm_request_reading_headers();
+
+#if defined(HAVE_SYS_POLL_H) && defined(HAVE_POLL)
+					struct pollfd fds;
+					int ret;
+
+					fds.fd = req->fd;
+					fds.events = POLLIN;
+					fds.revents = 0;
+					do {
+						errno = 0;
+						ret = poll(&fds, 1, 5000);
+					} while (ret < 0 && errno == EINTR);
+					if (ret > 0 && (fds.revents & POLLIN)) {
+						break;
+					}
+					fcgi_close(req, 1, 0);
+#else
+					if (req->fd < FD_SETSIZE) {
+						struct timeval tv = {5,0};
+						fd_set set;
+						int ret;
+
+						FD_ZERO(&set);
+						FD_SET(req->fd, &set);
+						do {
+							errno = 0;
+							ret = select(req->fd + 1, &set, NULL, NULL, &tv) >= 0;
+						} while (ret < 0 && errno == EINTR);
+						if (ret > 0 && FD_ISSET(req->fd, &set)) {
+							break;
+						}
+						fcgi_close(req, 1, 0);
+					} else {
+						fprintf(stderr, "Too many open file descriptors. FD_SETSIZE limit exceeded.");
+						fcgi_close(req, 1, 0);
+					}
+#endif
+				}
+#endif
+			}
+		} else if (in_shutdown) {
+			return -1;
+		}
+		if (fcgi_read_request(req)) {
+#ifdef _WIN32
+			if (is_impersonate && !req->tcp) {
+				pipe = (HANDLE)_get_osfhandle(req->fd);
+				if (!ImpersonateNamedPipeClient(pipe)) {
+					fcgi_close(req, 1, 1);
+					continue;
+				}
+			}
+#endif
+			return req->fd;
+		} else {
+			fcgi_close(req, 1, 1);
+		}
+	}
+}
+
+static inline fcgi_header* open_packet(fcgi_request *req, fcgi_request_type type)
+{
+	req->out_hdr = (fcgi_header*) req->out_pos;
+	req->out_hdr->type = type;
+	req->out_pos += sizeof(fcgi_header);
+	return req->out_hdr;
+}
+
+static inline void close_packet(fcgi_request *req)
+{
+	if (req->out_hdr) {
+		int len = req->out_pos - ((unsigned char*)req->out_hdr + sizeof(fcgi_header));
+
+		req->out_pos += fcgi_make_header(req->out_hdr, (fcgi_request_type)req->out_hdr->type, req->id, len);
+		req->out_hdr = NULL;
+	}
+}
+
+int fcgi_flush(fcgi_request *req, int close)
+{
+	int len;
+
+	close_packet(req);
+
+	len = req->out_pos - req->out_buf;
+
+	if (close) {
+		fcgi_end_request_rec *rec = (fcgi_end_request_rec*)(req->out_pos);
+
+		fcgi_make_header(&rec->hdr, FCGI_END_REQUEST, req->id, sizeof(fcgi_end_request));
+		rec->body.appStatusB3 = 0;
+		rec->body.appStatusB2 = 0;
+		rec->body.appStatusB1 = 0;
+		rec->body.appStatusB0 = 0;
+		rec->body.protocolStatus = FCGI_REQUEST_COMPLETE;
+		len += sizeof(fcgi_end_request_rec);
+	}
+
+	if (safe_write(req, req->out_buf, len) != len) {
+		req->keep = 0;
+		return 0;
+	}
+
+	req->out_pos = req->out_buf;
+	return 1;
+}
+
+int fcgi_write(fcgi_request *req, fcgi_request_type type, const char *str, int len)
+{
+	int limit, rest;
+
+	if (len <= 0) {
+		return 0;
+	}
+
+	if (req->out_hdr && req->out_hdr->type != type) {
+		close_packet(req);
+	}
+#if 0
+	/* Unoptimized, but clear version */
+	rest = len;
+	while (rest > 0) {
+		limit = sizeof(req->out_buf) - (req->out_pos - req->out_buf);
+
+		if (!req->out_hdr) {
+			if (limit < sizeof(fcgi_header)) {
+				if (!fcgi_flush(req, 0)) {
+					return -1;
+				}
+			}
+			open_packet(req, type);
+		}
+		limit = sizeof(req->out_buf) - (req->out_pos - req->out_buf);
+		if (rest < limit) {
+			memcpy(req->out_pos, str, rest);
+			req->out_pos += rest;
+			return len;
+		} else {
+			memcpy(req->out_pos, str, limit);
+			req->out_pos += limit;
+			rest -= limit;
+			str += limit;
+			if (!fcgi_flush(req, 0)) {
+				return -1;
+			}
+		}
+	}
+#else
+	/* Optimized version */
+	limit = sizeof(req->out_buf) - (req->out_pos - req->out_buf);
+	if (!req->out_hdr) {
+		limit -= sizeof(fcgi_header);
+		if (limit < 0) limit = 0;
+	}
+
+	if (len < limit) {
+		if (!req->out_hdr) {
+			open_packet(req, type);
+		}
+		memcpy(req->out_pos, str, len);
+		req->out_pos += len;
+	} else if (len - limit < sizeof(req->out_buf) - sizeof(fcgi_header)) {
+		if (!req->out_hdr) {
+			open_packet(req, type);
+		}
+		if (limit > 0) {
+			memcpy(req->out_pos, str, limit);
+			req->out_pos += limit;
+		}
+		if (!fcgi_flush(req, 0)) {
+			return -1;
+		}
+		if (len > limit) {
+			open_packet(req, type);
+			memcpy(req->out_pos, str + limit, len - limit);
+			req->out_pos += len - limit;
+		}
+	} else {
+		int pos = 0;
+		int pad;
+
+		close_packet(req);
+		while ((len - pos) > 0xffff) {
+			open_packet(req, type);
+			fcgi_make_header(req->out_hdr, type, req->id, 0xfff8);
+			req->out_hdr = NULL;
+			if (!fcgi_flush(req, 0)) {
+				return -1;
+			}
+			if (safe_write(req, str + pos, 0xfff8) != 0xfff8) {
+				req->keep = 0;
+				return -1;
+			}
+			pos += 0xfff8;
+		}		
+		
+		pad = (((len - pos) + 7) & ~7) - (len - pos);
+		rest = pad ? 8 - pad : 0;
+
+		open_packet(req, type);
+		fcgi_make_header(req->out_hdr, type, req->id, (len - pos) - rest);
+		req->out_hdr = NULL;
+		if (!fcgi_flush(req, 0)) {
+			return -1;
+		}
+		if (safe_write(req, str + pos, (len - pos) - rest) != (len - pos) - rest) {
+			req->keep = 0;
+			return -1;
+		}
+		if (pad) {
+			open_packet(req, type);
+			memcpy(req->out_pos, str + len - rest,  rest);
+			req->out_pos += rest;
+		}
+	}
+#endif
+	return len;
+}
+
+int fcgi_finish_request(fcgi_request *req)
+{
+	if (req->fd >= 0) {
+		fcgi_flush(req, 1);
+		fcgi_close(req, 0, 1);
+	}
+	return 1;
+}
+
+char* fcgi_getenv(fcgi_request *req, const char* var, int var_len)
+{
+	char **val;
+
+	if (!req) return NULL;
+
+	if (zend_hash_find(&req->env, (char*)var, var_len+1, (void**)&val) == SUCCESS) {
+		return *val;
+	}
+	return NULL;
+}
+
+char* fcgi_putenv(fcgi_request *req, char* var, int var_len, char* val)
+{
+	if (var && req) {
+		if (val == NULL) {
+			zend_hash_del(&req->env, var, var_len+1);
+		} else {
+			char **ret;
+
+			val = strdup(val);
+			if (zend_hash_update(&req->env, var, var_len+1, &val, sizeof(char*), (void**)&ret) == SUCCESS) {
+				return *ret;
+			}
+		}
+	}
+	return NULL;
+}
+
+#ifdef _WIN32
+void fcgi_impersonate(void)
+{
+	char *os_name;
+
+	os_name = getenv("OS");
+	if (os_name && stricmp(os_name, "Windows_NT") == 0) {
+		is_impersonate = 1;
+	}
+}
+#endif
+
+void fcgi_set_mgmt_var(char * name, size_t name_len, const char * value, size_t value_len)
+{
+	zval * zvalue;
+	zvalue = pemalloc(sizeof(*zvalue), 1);
+	Z_TYPE_P(zvalue) = IS_STRING;
+	Z_STRVAL_P(zvalue) = pestrndup(value, value_len, 1);
+	Z_STRLEN_P(zvalue) = value_len;
+	zend_hash_update(fcgi_mgmt_vars, name, name_len + 1, &zvalue, sizeof(zvalue), NULL);
+}
+
+void fcgi_free_mgmt_var_cb(void * ptr)
+{
+	zval ** var = (zval **)ptr;
+	pefree(Z_STRVAL_PP(var), 1);
+	pefree(*var, 1);
+}
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: sw=4 ts=4 fdm=marker
+ * vim<600: sw=4 ts=4
+ */
diff -Naur php-src-vanilla/sapi/fpm/cgi/fastcgi.h php-src/sapi/fpm/cgi/fastcgi.h
--- php-src-vanilla/sapi/fpm/cgi/fastcgi.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/cgi/fastcgi.h	2009-10-18 21:05:39.302497288 +0100
@@ -0,0 +1,150 @@
+/*
+   +----------------------------------------------------------------------+
+   | PHP Version 5                                                        |
+   +----------------------------------------------------------------------+
+   | Copyright (c) 1997-2008 The PHP Group                                |
+   +----------------------------------------------------------------------+
+   | This source file is subject to version 3.01 of the PHP license,      |
+   | that is bundled with this package in the file LICENSE, and is        |
+   | available through the world-wide-web at the following url:           |
+   | http://www.php.net/license/3_01.txt                                  |
+   | If you did not receive a copy of the PHP license and are unable to   |
+   | obtain it through the world-wide-web, please send a note to          |
+   | license@php.net so we can mail you a copy immediately.               |
+   +----------------------------------------------------------------------+
+   | Authors: Dmitry Stogov <dmitry@zend.com>                             |
+   +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+
+/* FastCGI protocol */
+
+#define FCGI_VERSION_1 1
+
+#define FCGI_MAX_LENGTH 0xffff
+
+#define FCGI_KEEP_CONN  1
+
+typedef enum _fcgi_role {
+	FCGI_RESPONDER	= 1,
+	FCGI_AUTHORIZER	= 2,
+	FCGI_FILTER		= 3
+} fcgi_role;
+
+typedef enum _fcgi_request_type {
+	FCGI_BEGIN_REQUEST		=  1, /* [in]                              */
+	FCGI_ABORT_REQUEST		=  2, /* [in]  (not supported)             */
+	FCGI_END_REQUEST		=  3, /* [out]                             */
+	FCGI_PARAMS				=  4, /* [in]  environment variables       */
+	FCGI_STDIN				=  5, /* [in]  post data                   */
+	FCGI_STDOUT				=  6, /* [out] response                    */
+	FCGI_STDERR				=  7, /* [out] errors                      */
+	FCGI_DATA				=  8, /* [in]  filter data (not supported) */
+	FCGI_GET_VALUES			=  9, /* [in]                              */
+	FCGI_GET_VALUES_RESULT	= 10  /* [out]                             */
+} fcgi_request_type;
+
+typedef enum _fcgi_protocol_status {
+	FCGI_REQUEST_COMPLETE	= 0,
+	FCGI_CANT_MPX_CONN		= 1,
+	FCGI_OVERLOADED			= 2,
+	FCGI_UNKNOWN_ROLE		= 3
+} dcgi_protocol_status;
+
+typedef struct _fcgi_header {
+	unsigned char version;
+	unsigned char type;
+	unsigned char requestIdB1;
+	unsigned char requestIdB0;
+	unsigned char contentLengthB1;
+	unsigned char contentLengthB0;
+	unsigned char paddingLength;
+	unsigned char reserved;
+} fcgi_header;
+
+typedef struct _fcgi_begin_request {
+	unsigned char roleB1;
+	unsigned char roleB0;
+	unsigned char flags;
+	unsigned char reserved[5];
+} fcgi_begin_request;
+
+typedef struct _fcgi_begin_request_rec {
+	fcgi_header hdr;
+	fcgi_begin_request body;
+} fcgi_begin_request_rec;
+
+typedef struct _fcgi_end_request {
+    unsigned char appStatusB3;
+    unsigned char appStatusB2;
+    unsigned char appStatusB1;
+    unsigned char appStatusB0;
+    unsigned char protocolStatus;
+    unsigned char reserved[3];
+} fcgi_end_request;
+
+typedef struct _fcgi_end_request_rec {
+	fcgi_header hdr;
+	fcgi_end_request body;
+} fcgi_end_request_rec;
+
+/* FastCGI client API */
+
+typedef struct _fcgi_request {
+	int            listen_socket;
+#ifdef _WIN32
+	int            tcp;
+#endif
+	int            fd;
+	int            id;
+	int            keep;
+
+	int            in_len;
+	int            in_pad;
+
+	fcgi_header   *out_hdr;
+	unsigned char *out_pos;
+	unsigned char  out_buf[1024*8];
+	unsigned char  reserved[sizeof(fcgi_end_request_rec)];
+
+	HashTable      env;
+} fcgi_request;
+
+int fcgi_init(void);
+void fcgi_shutdown(void);
+int fcgi_is_fastcgi(void);
+void fcgi_set_is_fastcgi(int);
+void fcgi_set_in_shutdown(int);
+void fcgi_set_allowed_clients(char *);
+int fcgi_in_shutdown(void);
+int fcgi_listen(const char *path, int backlog);
+void fcgi_init_request(fcgi_request *req, int listen_socket);
+int fcgi_accept_request(fcgi_request *req);
+int fcgi_finish_request(fcgi_request *req);
+
+char* fcgi_getenv(fcgi_request *req, const char* var, int var_len);
+char* fcgi_putenv(fcgi_request *req, char* var, int var_len, char* val);
+
+int fcgi_read(fcgi_request *req, char *str, int len);
+
+int fcgi_write(fcgi_request *req, fcgi_request_type type, const char *str, int len);
+int fcgi_flush(fcgi_request *req, int close);
+
+void fcgi_close(fcgi_request *req, int force, int destroy);
+
+#ifdef PHP_WIN32
+void fcgi_impersonate(void);
+#endif
+
+void fcgi_set_mgmt_var(char * name, size_t name_len, const char * value, size_t value_len);
+void fcgi_free_mgmt_var_cb(void * ptr);
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: sw=4 ts=4 fdm=marker
+ * vim<600: sw=4 ts=4
+ */
diff -Naur php-src-vanilla/sapi/fpm/cgi/php_getopt.h php-src/sapi/fpm/cgi/php_getopt.h
--- php-src-vanilla/sapi/fpm/cgi/php_getopt.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/cgi/php_getopt.h	2009-10-18 21:05:39.302497288 +0100
@@ -0,0 +1,39 @@
+/*
+   +----------------------------------------------------------------------+
+   | PHP Version 5                                                        |
+   +----------------------------------------------------------------------+
+   | Copyright (c) 1997-2008 The PHP Group                                |
+   +----------------------------------------------------------------------+
+   | This source file is subject to version 3.01 of the PHP license,      |
+   | that is bundled with this package in the file LICENSE, and is        |
+   | available through the world-wide-web at the following url:           |
+   | http://www.php.net/license/3_01.txt                                  |
+   | If you did not receive a copy of the PHP license and are unable to   |
+   | obtain it through the world-wide-web, please send a note to          |
+   | license@php.net so we can mail you a copy immediately.               |
+   +----------------------------------------------------------------------+
+   | Author: Marcus Boerger <helly@php.net>                               |
+   +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+
+#include <php.h>
+
+#ifdef NETWARE
+/*
+As NetWare LibC has optind and optarg macros defined in unistd.h our local variables were getting mistakenly preprocessed so undeffing optind and optarg
+*/
+#undef optarg
+#undef optind
+#endif
+/* Define structure for one recognized option (both single char and long name).
+ * If short_open is '-' this is the last option.
+ */
+typedef struct _opt_struct {
+	const char opt_char;
+	const int  need_param;
+	const char * opt_name;
+} opt_struct;
+
+int php_getopt(int argc, char* const *argv, const opt_struct opts[], char **optarg, int *optind, int show_err);
diff -Naur php-src-vanilla/sapi/fpm/conf/init.d.php-fpm.in php-src/sapi/fpm/conf/init.d.php-fpm.in
--- php-src-vanilla/sapi/fpm/conf/init.d.php-fpm.in	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/conf/init.d.php-fpm.in	2009-10-18 21:05:39.298456068 +0100
@@ -0,0 +1,135 @@
+#! /bin/sh
+
+### BEGIN INIT INFO
+# Provides:          @php_fpm_bin@
+# Required-Start:    $all
+# Required-Stop:     $all
+# Default-Start:     2 3 4 5
+# Default-Stop:      0 1 6
+# Short-Description: starts @php_fpm_bin@
+# Description:       starts the PHP FastCGI Process Manager daemon
+### END INIT INFO
+
+php_fpm_BIN=@php_fpm_bin_path@
+php_fpm_CONF=@php_fpm_conf_path@
+php_fpm_PID=@php_fpm_pid_path@
+
+
+php_opts="--fpm-config $php_fpm_CONF"
+
+
+wait_for_pid () {
+	try=0
+
+	while test $try -lt 35 ; do
+
+		case "$1" in
+			'created')
+			if [ -f "$2" ] ; then
+				try=''
+				break
+			fi
+			;;
+
+			'removed')
+			if [ ! -f "$2" ] ; then
+				try=''
+				break
+			fi
+			;;
+		esac
+
+		echo -n .
+		try=`expr $try + 1`
+		sleep 1
+
+	done
+
+}
+
+case "$1" in
+	start)
+		echo -n "Starting @php_fpm_bin@ "
+
+		$php_fpm_BIN $php_opts
+
+		if [ "$?" != 0 ] ; then
+			echo " failed"
+			exit 1
+		fi
+
+		wait_for_pid created $php_fpm_PID
+
+		if [ -n "$try" ] ; then
+			echo " failed"
+			exit 1
+		else
+			echo " done"
+		fi
+	;;
+
+	stop)
+		echo -n "Gracefully shutting down @php_fpm_bin@ "
+
+		if [ ! -r $php_fpm_PID ] ; then
+			echo "warning, no pid file found - php-fpm is not running ?"
+			exit 1
+		fi
+
+		kill -QUIT `cat $php_fpm_PID`
+
+		wait_for_pid removed $php_fpm_PID
+
+		if [ -n "$try" ] ; then
+			echo " failed. Use force-exit"
+			exit 1
+		else
+			echo " done"
+		fi
+	;;
+
+	force-quit)
+		echo -n "Terminating @php_fpm_bin@ "
+
+		if [ ! -r $php_fpm_PID ] ; then
+			echo "warning, no pid file found - php-fpm is not running ?"
+			exit 1
+		fi
+
+		kill -TERM `cat $php_fpm_PID`
+
+		wait_for_pid removed $php_fpm_PID
+
+		if [ -n "$try" ] ; then
+			echo " failed"
+			exit 1
+		else
+			echo " done"
+		fi
+	;;
+
+	restart)
+		$0 stop
+		$0 start
+	;;
+
+	reload)
+
+		echo -n "Reload service @php_fpm_bin@ "
+
+		if [ ! -r $php_fpm_PID ] ; then
+			echo "warning, no pid file found - @php_fpm_bin@ is not running ?"
+			exit 1
+		fi
+
+		kill -USR2 `cat $php_fpm_PID`
+
+		echo " done"
+	;;
+
+	*)
+		echo "Usage: $0 {start|stop|force-quit|restart|reload}"
+		exit 1
+	;;
+
+esac
diff -Naur php-src-vanilla/sapi/fpm/conf/nginx-site-conf.sample.in php-src/sapi/fpm/conf/nginx-site-conf.sample.in
--- php-src-vanilla/sapi/fpm/conf/nginx-site-conf.sample.in	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/conf/nginx-site-conf.sample.in	2009-10-18 21:05:39.298456068 +0100
@@ -0,0 +1,46 @@
+# @php_fpm_bin@ - PHP FastCGI Process Manager 'PHP-FPM'
+# 
+# nginx-site-conf.sample:
+# Php Site configuration for nginx webserver
+# 
+# 1. set server root /path/to/your/website;
+# 2. Rename this file. Copy it to /etc/nginx/sites-available, /etc/nginx/sites-enabled
+#    or otherwise ensure that this file is included by the nginx.conf
+# 3. Restart nginx webserver, and @php_fpm_bin@ service.
+# 
+
+server {
+
+	root  /var/www/nginx-site;
+
+	server_name     localhost;
+	listen          80;
+
+	access_log  /var/log/nginx/localhost.access.log;
+
+	location / {
+		index  index.html index.htm;
+	}
+
+	#error_page  404  /404.html;
+
+	# redirect server error pages to the static page /50x.html
+	#
+	error_page   500 502 503 504  /50x.html;
+	location = /50x.html {
+		root   /var/www/nginx-default;
+	}
+
+	# pass the *.php scripts to @php_fpm_bin@ listening on tcp port @php_fpm_port@
+	#
+	location ~ \.php$ {
+
+		fastcgi_pass   127.0.0.1:@php_fpm_port@;
+		fastcgi_index  index.php;
+
+		include fastcgi_params;
+        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
+        fastcgi_param SERVER_NAME $http_host;
+        fastcgi_ignore_client_abort on;
+	}
+}
diff -Naur php-src-vanilla/sapi/fpm/conf/php-fpm.conf.in php-src/sapi/fpm/conf/php-fpm.conf.in
--- php-src-vanilla/sapi/fpm/conf/php-fpm.conf.in	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/conf/php-fpm.conf.in	2009-10-18 21:05:39.298456068 +0100
@@ -0,0 +1,159 @@
+<?xml version="1.0" ?>
+<configuration>
+
+	All relative paths in this config are relative to php's install prefix
+
+	<section name="global_options">
+
+		Pid file
+		<value name="pid_file">@php_fpm_pid_path@</value>
+
+		Error log file
+		<value name="error_log">@php_fpm_log_path@</value>
+
+		Log level
+		<value name="log_level">notice</value>
+
+		When this amount of php processes exited with SIGSEGV or SIGBUS ...
+		<value name="emergency_restart_threshold">10</value>
+
+		... in a less than this interval of time, a graceful restart will be initiated.
+		Useful to work around accidental curruptions in accelerator's shared memory.
+		<value name="emergency_restart_interval">1m</value>
+
+		Time limit on waiting child's reaction on signals from master
+		<value name="process_control_timeout">5s</value>
+
+		Set to 'no' to debug fpm
+		<value name="daemonize">yes</value>
+
+	</section>
+
+	<workers>
+
+		<section name="pool">
+
+			Name of pool. Used in logs and stats.
+			<value name="name">default</value>
+
+			Address to accept fastcgi requests on.
+			Valid syntax is 'ip.ad.re.ss:port' or just 'port' or '/path/to/unix/socket'
+			<value name="listen_address">127.0.0.1:@php_fpm_port@</value>
+
+			<value name="listen_options">
+
+				Set listen(2) backlog
+				<value name="backlog">-1</value>
+
+				Set permissions for unix socket, if one used.
+				In Linux read/write permissions must be set in order to allow connections from web server.
+				Many BSD-derrived systems allow connections regardless of permissions.
+				<value name="owner">@php_fpm_user@</value>
+				<value name="group">@php_fpm_group@</value>
+				<value name="mode">0666</value>
+			</value>
+
+			Additional php.ini defines, specific to this pool of workers.
+			These settings overwrite the values previously defined in the php.ini.
+			<value name="php_defines">
+				<!-- <value name="sendmail_path">/usr/sbin/sendmail -t -i</value> -->
+				<!-- <value name="display_errors">0</value> -->
+				<!-- <value name="error_log">/var/log/php-error.log</value> -->
+        		<!-- <value name="log_errors">true</value> -->
+			</value>
+
+			Unix user of processes
+			<value name="user">@php_fpm_user@</value>
+
+			Unix group of processes
+			<value name="group">@php_fpm_group@</value>
+
+			Process manager settings
+			<value name="pm">
+
+				Sets style of controling worker process count.
+				Valid values are 'static' and 'apache-like'
+				<value name="style">static</value>
+
+				Sets the limit on the number of simultaneous requests that will be served.
+				Equivalent to Apache MaxClients directive.
+				Equivalent to PHP_FCGI_CHILDREN environment in original php.fcgi
+				Used with any pm_style.
+				<value name="max_children">5</value>
+
+				Settings group for 'apache-like' pm style
+				<value name="apache_like">
+
+					Sets the number of server processes created on startup.
+					Used only when 'apache-like' pm_style is selected
+					<value name="StartServers">20</value>
+
+					Sets the desired minimum number of idle server processes.
+					Used only when 'apache-like' pm_style is selected
+					<value name="MinSpareServers">5</value>
+
+					Sets the desired maximum number of idle server processes.
+					Used only when 'apache-like' pm_style is selected
+					<value name="MaxSpareServers">35</value>
+
+				</value>
+
+			</value>
+
+			The timeout (in seconds) for serving a single request after which the worker process will be terminated
+			Should be used when 'max_execution_time' ini option does not stop script execution for some reason
+			'0s' means 'off'
+			<value name="request_terminate_timeout">0s</value>
+
+			The timeout (in seconds) for serving of single request after which a php backtrace will be dumped to slow.log file
+			'0s' means 'off'
+			<value name="request_slowlog_timeout">0s</value>
+
+			The log file for slow requests
+			<value name="slowlog">@php_fpm_log_path@.slow</value>
+
+			Set open file desc rlimit
+			<value name="rlimit_files">1024</value>
+
+			Set max core size rlimit
+			<value name="rlimit_core">0</value>
+
+			Chroot to this directory at the start, absolute path
+			<value name="chroot"></value>
+
+			Chdir to this directory at the start, absolute path
+			<value name="chdir"></value>
+
+			Redirect workers' stdout and stderr into main error log.
+			If not set, they will be redirected to /dev/null, according to FastCGI specs
+			<value name="catch_workers_output">yes</value>
+
+			How much requests each process should execute before respawn.
+			Useful to work around memory leaks in 3rd party libraries.
+			For endless request processing please specify 0
+			Equivalent to PHP_FCGI_MAX_REQUESTS
+			<value name="max_requests">500</value>
+
+			Comma separated list of ipv4 addresses of FastCGI clients that allowed to connect.
+			Equivalent to FCGI_WEB_SERVER_ADDRS environment in original php.fcgi (5.2.2+)
+			Makes sense only with AF_INET listening socket.
+			<value name="allowed_clients">127.0.0.1</value>
+
+			Pass environment variables like LD_LIBRARY_PATH
+			All $VARIABLEs are taken from current environment
+			<value name="environment">
+				<value name="HOSTNAME">$HOSTNAME</value>
+				<value name="PATH">/usr/local/bin:/usr/bin:/bin</value>
+				<value name="TMP">/tmp</value>
+				<value name="TMPDIR">/tmp</value>
+				<value name="TEMP">/tmp</value>
+				<value name="OSTYPE">$OSTYPE</value>
+				<value name="MACHTYPE">$MACHTYPE</value>
+				<value name="MALLOC_CHECK_">2</value>
+			</value>
+
+		</section>
+
+	</workers>
+
+</configuration>
diff -Naur php-src-vanilla/sapi/fpm/config.m4 php-src/sapi/fpm/config.m4
--- php-src-vanilla/sapi/fpm/config.m4	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/config.m4	2009-10-18 21:05:39.302497288 +0100
@@ -0,0 +1,26 @@
+dnl
+dnl $Id$
+dnl
+
+PHP_ARG_WITH(fpm,,
+[  --with-fpm              Build PHP FastCGI - FPM executable], no)
+
+if test "$PHP_FPM" != "no"; then
+
+	PHP_CONFIGURE_PART(Configuring fpm)
+	
+	sinclude(sapi/fpm/ac/fpm_libevent.m4)
+		AC_LIB_EVENT([1.4.3],[1.4.11])
+
+	sinclude(sapi/fpm/ac/fpm_checks.m4)
+		AC_FPM_CHECKS
+
+	sinclude(sapi/fpm/ac/fpm_conf.m4)
+		fpm_version="0.6"
+		AC_FPM_CONF
+
+	sinclude(sapi/fpm/ac/fpm_build.m4)
+		AC_FPM_BUILD_SAPI
+
+	AC_MSG_RESULT()
+fi
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_arrays.h php-src/sapi/fpm/fpm/fpm_arrays.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_arrays.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_arrays.h	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,110 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_ARRAYS_H
+#define FPM_ARRAYS_H 1
+
+#include <stdlib.h>
+#include <string.h>
+
+struct fpm_array_s {
+	void *data;
+	size_t sz;
+	size_t used;
+	size_t allocated;
+};
+
+static inline struct fpm_array_s *fpm_array_init(struct fpm_array_s *a, unsigned int sz, unsigned int initial_num)
+{
+	void *allocated = 0;
+
+	if (!a) {
+		a = malloc(sizeof(struct fpm_array_s));
+
+		if (!a) {
+			return 0;
+		}
+
+		allocated = a;
+	}
+
+	a->sz = sz;
+
+	a->data = calloc(sz, initial_num);
+
+	if (!a->data) {
+		free(allocated);
+		return 0;
+	}
+
+	a->allocated = initial_num;
+	a->used = 0;
+
+	return a;
+}
+
+static inline void *fpm_array_item(struct fpm_array_s *a, unsigned int n)
+{
+	char *ret;
+
+	ret = (char *) a->data + a->sz * n;
+
+	return ret;
+}
+
+static inline void *fpm_array_item_last(struct fpm_array_s *a)
+{
+	return fpm_array_item(a, a->used - 1);
+}
+
+static inline int fpm_array_item_remove(struct fpm_array_s *a, unsigned int n)
+{
+	int ret = -1;
+
+	if (n < a->used - 1) {
+		void *last = fpm_array_item(a, a->used - 1);
+		void *to_remove = fpm_array_item(a, n);
+
+		memcpy(to_remove, last, a->sz);
+
+		ret = n;
+	}
+
+	--a->used;
+
+	return ret;
+}
+
+static inline void *fpm_array_push(struct fpm_array_s *a)
+{
+	void *ret;
+
+	if (a->used == a->allocated) {
+		size_t new_allocated = a->allocated ? a->allocated * 2 : 20;
+		void *new_ptr = realloc(a->data, a->sz * new_allocated);
+
+		if (!new_ptr) {
+			return 0;
+		}
+
+		a->data = new_ptr;
+		a->allocated = new_allocated;
+	}
+
+	ret = fpm_array_item(a, a->used);
+
+	++a->used;
+
+	return ret;
+}
+
+static inline void fpm_array_free(struct fpm_array_s *a)
+{
+	free(a->data);
+	a->data = 0;
+	a->sz = 0;
+	a->used = a->allocated = 0;
+}
+
+#endif
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_atomic.h php-src/sapi/fpm/fpm/fpm_atomic.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_atomic.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_atomic.h	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,139 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_ATOMIC_H
+#define FPM_ATOMIC_H 1
+
+#if HAVE_INTTYPES_H
+#include <inttypes.h>
+#else
+#include <stdint.h>
+#endif
+#include <sched.h>
+
+#if ( __i386__ || __i386 )
+
+typedef int32_t                     atomic_int_t;
+typedef uint32_t                    atomic_uint_t;
+typedef volatile atomic_uint_t      atomic_t;
+
+
+static inline atomic_int_t atomic_fetch_add(atomic_t *value, atomic_int_t add)
+{
+	__asm__ volatile ( "lock;" "xaddl %0, %1;" :
+		"+r" (add) : "m" (*value) : "memory");
+
+	return add;
+}
+
+static inline atomic_uint_t atomic_cmp_set(atomic_t *lock, atomic_uint_t old, atomic_uint_t set)
+{
+	unsigned char res;
+
+	__asm__ volatile ( "lock;" "cmpxchgl %3, %1;" "sete %0;" :
+		"=a" (res) : "m" (*lock), "a" (old), "r" (set) : "memory");
+
+    return res;
+}
+
+#elif ( __amd64__ || __amd64 )
+
+typedef int64_t                     atomic_int_t;
+typedef uint64_t                    atomic_uint_t;
+typedef volatile atomic_uint_t      atomic_t;
+
+static inline atomic_int_t atomic_fetch_add(atomic_t *value, atomic_int_t add)
+{
+	__asm__ volatile ( "lock;" "xaddq %0, %1;" :
+		"+r" (add) : "m" (*value) : "memory");
+
+	return add;
+}
+
+static inline atomic_uint_t atomic_cmp_set(atomic_t *lock, atomic_uint_t old, atomic_uint_t set)
+{
+	unsigned char res;
+
+	__asm__ volatile ( "lock;" "cmpxchgq %3, %1;" "sete %0;" :
+		"=a" (res) : "m" (*lock), "a" (old), "r" (set) : "memory");
+
+	return res;
+}
+
+#if (__GNUC__) && (__GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 2))
+
+#elif ( __arm__ || __arm ) /* W-Mark Kubacki */
+
+#if (__arch64__ || __arch64)
+typedef int64_t                     atomic_int_t;
+typedef uint64_t                    atomic_uint_t;
+#else
+typedef int32_t                     atomic_int_t;
+typedef uint32_t                    atomic_uint_t;
+#endif
+
+#define atomic_cmp_set(a,b,c) __sync_bool_compare_and_swap(a,b,c)
+
+#endif /* defined (__GNUC__) &&... */
+
+#elif ( __sparc__ || __sparc ) /* Marcin Ochab */
+
+#if (__arch64__ || __arch64)
+typedef uint64_t                    atomic_uint_t;
+typedef volatile atomic_uint_t      atomic_t;
+
+static inline int atomic_cas_64(atomic_t *lock, atomic_uint_t old, atomic_uint_t new)
+{
+        __asm__ __volatile__("casx [%2], %3, %0 " : "=&r"(new)  : "0"(new), "r"(lock), "r"(old): "memory");
+
+    return new;
+}
+
+static inline atomic_uint_t atomic_cmp_set(atomic_t *lock, atomic_uint_t old, atomic_uint_t set)
+{
+       return (atomic_cas_64(lock, old, set)==old);
+}
+#else
+typedef uint32_t                    atomic_uint_t;
+typedef volatile atomic_uint_t      atomic_t;
+
+static inline int atomic_cas_32(atomic_t *lock, atomic_uint_t old, atomic_uint_t new)
+{
+        __asm__ __volatile__("cas [%2], %3, %0 " : "=&r"(new)  : "0"(new), "r"(lock), "r"(old): "memory");
+
+    return new;
+}
+
+static inline atomic_uint_t atomic_cmp_set(atomic_t *lock, atomic_uint_t old, atomic_uint_t set)
+{
+       return (atomic_cas_32(lock, old, set)==old);
+}
+#endif
+
+#else
+
+#error unsupported architecture. please write a patch and send it in
+
+#endif
+
+static inline int fpm_spinlock(atomic_t *lock, int try_once)
+{
+	if (try_once) {
+		return atomic_cmp_set(lock, 0, 1) ? 0 : -1;
+	}
+
+	for (;;) {
+
+		if (atomic_cmp_set(lock, 0, 1)) {
+			break;
+		}
+
+		sched_yield();
+	}
+
+	return 0;
+}
+
+#endif
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm.c php-src/sapi/fpm/fpm/fpm.c
--- php-src-vanilla/sapi/fpm/fpm/fpm.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm.c	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,82 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#include <stdlib.h> /* for exit */
+
+#include "fpm.h"
+#include "fpm_children.h"
+#include "fpm_signals.h"
+#include "fpm_env.h"
+#include "fpm_events.h"
+#include "fpm_cleanup.h"
+#include "fpm_php.h"
+#include "fpm_sockets.h"
+#include "fpm_unix.h"
+#include "fpm_process_ctl.h"
+#include "fpm_conf.h"
+#include "fpm_worker_pool.h"
+#include "fpm_stdio.h"
+#include "zlog.h"
+
+struct fpm_globals_s fpm_globals;
+
+int fpm_init(int argc, char **argv, char *config)
+{
+	fpm_globals.argc = argc;
+	fpm_globals.argv = argv;
+	fpm_globals.config = config;
+
+	if (0 > fpm_php_init_main()              ||
+		0 > fpm_stdio_init_main()            ||
+		0 > fpm_conf_init_main()             ||
+		0 > fpm_unix_init_main()             ||
+		0 > fpm_env_init_main()              ||
+		0 > fpm_signals_init_main()          ||
+		0 > fpm_pctl_init_main()             ||
+		0 > fpm_children_init_main()         ||
+		0 > fpm_sockets_init_main()          ||
+		0 > fpm_worker_pool_init_main()      ||
+		0 > fpm_event_init_main()) {
+		return -1;
+	}
+
+	if (0 > fpm_conf_write_pid()) {
+		return -1;
+	}
+
+	zlog(ZLOG_STUFF, ZLOG_NOTICE, "fpm is running, pid %d", (int) fpm_globals.parent_pid);
+
+	return 0;
+}
+
+/*	children: return listening socket
+	parent: never return */
+int fpm_run(int *max_requests)
+{
+	struct fpm_worker_pool_s *wp;
+
+	/* create initial children in all pools */
+	for (wp = fpm_worker_all_pools; wp; wp = wp->next) {
+		int is_parent;
+
+		is_parent = fpm_children_create_initial(wp);
+
+		if (!is_parent) {
+			goto run_child;
+		}
+	}
+
+	/* run event loop forever */
+	fpm_event_loop();
+
+run_child: /* only workers reach this point */
+
+	fpm_cleanups_run(FPM_CLEANUP_CHILD);
+
+	*max_requests = fpm_globals.max_requests;
+	return fpm_globals.listening_socket;
+}
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_children.c php-src/sapi/fpm/fpm/fpm_children.c
--- php-src-vanilla/sapi/fpm/fpm/fpm_children.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_children.c	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,387 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <time.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "fpm.h"
+#include "fpm_children.h"
+#include "fpm_signals.h"
+#include "fpm_worker_pool.h"
+#include "fpm_sockets.h"
+#include "fpm_process_ctl.h"
+#include "fpm_php.h"
+#include "fpm_conf.h"
+#include "fpm_cleanup.h"
+#include "fpm_events.h"
+#include "fpm_clock.h"
+#include "fpm_stdio.h"
+#include "fpm_unix.h"
+#include "fpm_env.h"
+#include "fpm_shm_slots.h"
+
+#include "zlog.h"
+
+static time_t *last_faults;
+static int fault;
+
+static int fpm_children_make(struct fpm_worker_pool_s *wp, int in_event_loop);
+
+static void fpm_children_cleanup(int which, void *arg)
+{
+	free(last_faults);
+}
+
+static struct fpm_child_s *fpm_child_alloc()
+{
+	struct fpm_child_s *ret;
+
+	ret = malloc(sizeof(struct fpm_child_s));
+
+	if (!ret) { return 0; }
+
+	memset(ret, 0, sizeof(*ret));
+
+	return ret;
+}
+
+static void fpm_child_free(struct fpm_child_s *child)
+{
+	free(child);
+}
+
+static void fpm_child_close(struct fpm_child_s *child, int in_event_loop)
+{
+	if (child->fd_stdout != -1) {
+		if (in_event_loop) {
+			fpm_event_fire(&child->ev_stdout);
+		}
+		if (child->fd_stdout != -1) {
+			close(child->fd_stdout);
+		}
+	}
+
+	if (child->fd_stderr != -1) {
+		if (in_event_loop) {
+			fpm_event_fire(&child->ev_stderr);
+		}
+		if (child->fd_stderr != -1) {
+			close(child->fd_stderr);
+		}
+	}
+
+	fpm_child_free(child);
+}
+
+static void fpm_child_link(struct fpm_child_s *child)
+{
+	struct fpm_worker_pool_s *wp = child->wp;
+
+	++wp->running_children;
+	++fpm_globals.running_children;
+
+	child->next = wp->children;
+	if (child->next) { child->next->prev = child; }
+	child->prev = 0;
+	wp->children = child;
+}
+
+static void fpm_child_unlink(struct fpm_child_s *child)
+{
+	--child->wp->running_children;
+	--fpm_globals.running_children;
+
+	if (child->prev) { child->prev->next = child->next; }
+	else { child->wp->children = child->next; }
+	if (child->next) { child->next->prev = child->prev; }
+
+}
+
+static struct fpm_child_s *fpm_child_find(pid_t pid)
+{
+	struct fpm_worker_pool_s *wp;
+	struct fpm_child_s *child = 0;
+
+	for (wp = fpm_worker_all_pools; wp; wp = wp->next) {
+
+		for (child = wp->children; child; child = child->next) {
+			if (child->pid == pid) {
+				break;
+			}
+		}
+
+		if (child) {
+			break;
+		}
+	}
+
+	if (!child) {
+		return 0;
+	}
+
+	return child;
+}
+
+static void fpm_child_init(struct fpm_worker_pool_s *wp)
+{
+	fpm_globals.max_requests = wp->config->max_requests;
+
+	if (0 > fpm_stdio_init_child(wp) ||
+		0 > fpm_unix_init_child(wp) ||
+		0 > fpm_signals_init_child() ||
+		0 > fpm_env_init_child(wp) ||
+		0 > fpm_php_init_child(wp)) {
+
+		zlog(ZLOG_STUFF, ZLOG_ERROR, "child failed to initialize (pool %s)", wp->config->name);
+		exit(255);
+	}
+}
+
+int fpm_children_free(struct fpm_child_s *child)
+{
+	struct fpm_child_s *next;
+
+	for (; child; child = next) {
+		next = child->next;
+		fpm_child_close(child, 0 /* in_event_loop */);
+	}
+
+	return 0;
+}
+
+void fpm_children_bury()
+{
+	int status;
+	pid_t pid;
+	struct fpm_child_s *child;
+
+	while ( (pid = waitpid(-1, &status, WNOHANG | WUNTRACED)) > 0) {
+		char buf[128];
+		int severity = ZLOG_NOTICE;
+
+		child = fpm_child_find(pid);
+
+		if (WIFEXITED(status)) {
+
+			snprintf(buf, sizeof(buf), "with code %d", WEXITSTATUS(status));
+
+			if (WEXITSTATUS(status) != 0) {
+				severity = ZLOG_WARNING;
+			}
+
+		}
+		else if (WIFSIGNALED(status)) {
+			const char *signame = fpm_signal_names[WTERMSIG(status)];
+			const char *have_core = WCOREDUMP(status) ? " (core dumped)" : "";
+
+			if (signame == NULL) {
+				signame = "";
+			}
+
+			snprintf(buf, sizeof(buf), "on signal %d %s%s", WTERMSIG(status), signame, have_core);
+
+			if (WTERMSIG(status) != SIGQUIT) { /* possible request loss */
+				severity = ZLOG_WARNING;
+			}
+		}
+		else if (WIFSTOPPED(status)) {
+
+			zlog(ZLOG_STUFF, ZLOG_NOTICE, "child %d stopped for tracing", (int) pid);
+
+			if (child && child->tracer) {
+				child->tracer(child);
+			}
+
+			continue;
+		}
+
+		if (child) {
+			struct fpm_worker_pool_s *wp = child->wp;
+			struct timeval tv1, tv2;
+
+			fpm_child_unlink(child);
+
+			fpm_shm_slots_discard_slot(child);
+
+			fpm_clock_get(&tv1);
+
+			timersub(&tv1, &child->started, &tv2);
+
+			zlog(ZLOG_STUFF, severity, "child %d (pool %s) exited %s after %ld.%06d seconds from start", (int) pid,
+						child->wp->config->name, buf, tv2.tv_sec, (int) tv2.tv_usec);
+
+			fpm_child_close(child, 1 /* in event_loop */);
+
+			fpm_pctl_child_exited();
+
+			if (last_faults && (WTERMSIG(status) == SIGSEGV || WTERMSIG(status) == SIGBUS)) {
+				time_t now = tv1.tv_sec;
+				int restart_condition = 1;
+				int i;
+
+				last_faults[fault++] = now;
+
+				if (fault == fpm_global_config.emergency_restart_threshold) {
+					fault = 0;
+				}
+
+				for (i = 0; i < fpm_global_config.emergency_restart_threshold; i++) {
+					if (now - last_faults[i] > fpm_global_config.emergency_restart_interval) {
+						restart_condition = 0;
+						break;
+					}
+				}
+
+				if (restart_condition) {
+
+					zlog(ZLOG_STUFF, ZLOG_WARNING, "failed processes threshold (%d in %d sec) is reached, initiating reload",
+						fpm_global_config.emergency_restart_threshold, fpm_global_config.emergency_restart_interval);
+
+					fpm_pctl(FPM_PCTL_STATE_RELOADING, FPM_PCTL_ACTION_SET);
+				}
+			}
+
+			fpm_children_make(wp, 1 /* in event loop */);
+
+			if (fpm_globals.is_child) {
+				break;
+			}
+		}
+		else {
+			zlog(ZLOG_STUFF, ZLOG_ALERT, "oops, unknown child exited %s", buf);
+		}
+	}
+
+}
+
+static struct fpm_child_s *fpm_resources_prepare(struct fpm_worker_pool_s *wp)
+{
+	struct fpm_child_s *c;
+
+	c = fpm_child_alloc();
+
+	if (!c) {
+		zlog(ZLOG_STUFF, ZLOG_ERROR, "malloc failed (pool %s)", wp->config->name);
+		return 0;
+	}
+
+	c->wp = wp;
+	c->fd_stdout = -1; c->fd_stderr = -1;
+
+	if (0 > fpm_stdio_prepare_pipes(c)) {
+		fpm_child_free(c);
+		return 0;
+	}
+
+	if (0 > fpm_shm_slots_prepare_slot(c)) {
+		fpm_stdio_discard_pipes(c);
+		fpm_child_free(c);
+		return 0;
+	}
+
+	return c;
+}
+
+static void fpm_resources_discard(struct fpm_child_s *child)
+{
+	fpm_shm_slots_discard_slot(child);
+	fpm_stdio_discard_pipes(child);
+	fpm_child_free(child);
+}
+
+static void fpm_child_resources_use(struct fpm_child_s *child)
+{
+	fpm_shm_slots_child_use_slot(child);
+	fpm_stdio_child_use_pipes(child);
+	fpm_child_free(child);
+}
+
+static void fpm_parent_resources_use(struct fpm_child_s *child)
+{
+	fpm_shm_slots_parent_use_slot(child);
+	fpm_stdio_parent_use_pipes(child);
+	fpm_child_link(child);
+}
+
+static int fpm_children_make(struct fpm_worker_pool_s *wp, int in_event_loop)
+{
+	int enough = 0;
+	pid_t pid;
+	struct fpm_child_s *child;
+
+	while (!enough && fpm_pctl_can_spawn_children() && wp->running_children < wp->config->pm->max_children) {
+
+		child = fpm_resources_prepare(wp);
+
+		if (!child) {
+			enough = 1;
+			break;
+		}
+
+		pid = fork();
+
+		switch (pid) {
+
+			case 0 :
+				fpm_child_resources_use(child);
+				fpm_globals.is_child = 1;
+				if (in_event_loop) {
+					fpm_event_exit_loop();
+				}
+				fpm_child_init(wp);
+				return 0;
+
+			case -1 :
+				zlog(ZLOG_STUFF, ZLOG_SYSERROR, "fork() failed");
+				enough = 1;
+
+				fpm_resources_discard(child);
+
+				break; /* dont try any more on error */
+
+			default :
+				child->pid = pid;
+				fpm_clock_get(&child->started);
+				fpm_parent_resources_use(child);
+
+				zlog(ZLOG_STUFF, ZLOG_NOTICE, "child %d (pool %s) started", (int) pid, wp->config->name);
+		}
+
+	}
+
+	return 1; /* we are done */
+}
+
+int fpm_children_create_initial(struct fpm_worker_pool_s *wp)
+{
+	return fpm_children_make(wp, 0 /* not in event loop yet */);
+}
+
+int fpm_children_init_main()
+{
+	if (fpm_global_config.emergency_restart_threshold &&
+		fpm_global_config.emergency_restart_interval) {
+
+		last_faults = malloc(sizeof(time_t) * fpm_global_config.emergency_restart_threshold);
+
+		if (!last_faults) {
+			return -1;
+		}
+
+		memset(last_faults, 0, sizeof(time_t) * fpm_global_config.emergency_restart_threshold);
+	}
+
+	if (0 > fpm_cleanup_add(FPM_CLEANUP_ALL, fpm_children_cleanup, 0)) {
+		return -1;
+	}
+
+	return 0;
+}
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_children.h php-src/sapi/fpm/fpm/fpm_children.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_children.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_children.h	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,33 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_CHILDREN_H
+#define FPM_CHILDREN_H 1
+
+#include <sys/time.h>
+#include <sys/types.h>
+#include <event.h>
+
+#include "fpm_worker_pool.h"
+
+int fpm_children_create_initial(struct fpm_worker_pool_s *wp);
+int fpm_children_free(struct fpm_child_s *child);
+void fpm_children_bury();
+int fpm_children_init_main();
+
+struct fpm_child_s;
+
+struct fpm_child_s {
+	struct fpm_child_s *prev, *next;
+	struct timeval started;
+	struct fpm_worker_pool_s *wp;
+	struct event ev_stdout, ev_stderr;
+	int shm_slot_i;
+	int fd_stdout, fd_stderr;
+	void (*tracer)(struct fpm_child_s *);
+	struct timeval slow_logged;
+	pid_t pid;
+};
+
+#endif
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_cleanup.c php-src/sapi/fpm/fpm/fpm_cleanup.c
--- php-src-vanilla/sapi/fpm/fpm/fpm_cleanup.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_cleanup.c	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,51 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#include <stdlib.h>
+
+#include "fpm_arrays.h"
+#include "fpm_cleanup.h"
+#include "zlog.h"
+
+struct cleanup_s {
+	int type;
+	void (*cleanup)(int, void *);
+	void *arg;
+};
+
+static struct fpm_array_s cleanups = { .sz = sizeof(struct cleanup_s) };
+
+int fpm_cleanup_add(int type, void (*cleanup)(int, void *), void *arg)
+{
+	struct cleanup_s *c;
+
+	c = fpm_array_push(&cleanups);
+
+	if (!c) {
+		return -1;
+	}
+
+	c->type = type;
+	c->cleanup = cleanup;
+	c->arg = arg;
+
+	return 0;
+}
+
+void fpm_cleanups_run(int type)
+{
+	struct cleanup_s *c = fpm_array_item_last(&cleanups);
+	int cl = cleanups.used;
+
+	for ( ; cl--; c--) {
+		if (c->type & type) {
+			c->cleanup(type, c->arg);
+		}
+	}
+
+	fpm_array_free(&cleanups);
+}
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_cleanup.h php-src/sapi/fpm/fpm/fpm_cleanup.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_cleanup.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_cleanup.h	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,21 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_CLEANUP_H
+#define FPM_CLEANUP_H 1
+
+int fpm_cleanup_add(int type, void (*cleanup)(int, void *), void *);
+void fpm_cleanups_run(int type);
+
+enum {
+	FPM_CLEANUP_CHILD					= (1 << 0),
+	FPM_CLEANUP_PARENT_EXIT				= (1 << 1),
+	FPM_CLEANUP_PARENT_EXIT_MAIN		= (1 << 2),
+	FPM_CLEANUP_PARENT_EXEC				= (1 << 3),
+	FPM_CLEANUP_PARENT					= (1 << 1) | (1 << 2) | (1 << 3),
+	FPM_CLEANUP_ALL						= ~0,
+};
+
+#endif
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_clock.c php-src/sapi/fpm/fpm/fpm_clock.c
--- php-src-vanilla/sapi/fpm/fpm/fpm_clock.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_clock.c	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,115 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#if defined(HAVE_CLOCK_GETTIME)
+#include <time.h> /* for CLOCK_MONOTONIC */
+#endif
+
+#include "fpm_clock.h"
+#include "zlog.h"
+
+
+/* posix monotonic clock - preferred source of time */
+#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
+
+static int monotonic_works;
+
+int fpm_clock_init()
+{
+	struct timespec ts;
+
+	monotonic_works = 0;
+
+	if (0 == clock_gettime(CLOCK_MONOTONIC, &ts)) {
+		monotonic_works = 1;
+	}
+
+	return 0;
+}
+
+int fpm_clock_get(struct timeval *tv)
+{
+	if (monotonic_works) {
+		struct timespec ts;
+
+		if (0 > clock_gettime(CLOCK_MONOTONIC, &ts)) {
+			zlog(ZLOG_STUFF, ZLOG_SYSERROR, "clock_gettime() failed");
+			return -1;
+		}
+
+		tv->tv_sec = ts.tv_sec;
+		tv->tv_usec = ts.tv_nsec / 1000;
+		return 0;
+	}
+
+	return gettimeofday(tv, 0);
+}
+
+/* macosx clock */
+#elif defined(HAVE_CLOCK_GET_TIME)
+
+#include <mach/mach.h>
+#include <mach/clock.h>
+#include <mach/mach_error.h>
+
+static clock_serv_t mach_clock;
+
+/* this code borrowed from here: http://lists.apple.com/archives/Darwin-development/2002/Mar/msg00746.html */
+/* mach_clock also should be re-initialized in child process after fork */
+int fpm_clock_init()
+{
+	kern_return_t ret;
+	mach_timespec_t aTime;
+
+	ret = host_get_clock_service(mach_host_self(), REALTIME_CLOCK, &mach_clock);
+
+	if (ret != KERN_SUCCESS) {
+		zlog(ZLOG_STUFF, ZLOG_ERROR, "host_get_clock_service() failed: %s", mach_error_string(ret));
+		return -1;
+	}
+
+	/* test if it works */
+	ret = clock_get_time(mach_clock, &aTime);
+
+	if (ret != KERN_SUCCESS) {
+		zlog(ZLOG_STUFF, ZLOG_ERROR, "clock_get_time() failed: %s", mach_error_string(ret));
+		return -1;
+	}
+
+	return 0;
+}
+
+int fpm_clock_get(struct timeval *tv)
+{
+	kern_return_t ret;
+	mach_timespec_t aTime;
+
+	ret = clock_get_time(mach_clock, &aTime);
+
+	if (ret != KERN_SUCCESS) {
+		zlog(ZLOG_STUFF, ZLOG_ERROR, "clock_get_time() failed: %s", mach_error_string(ret));
+		return -1;
+	}
+
+	tv->tv_sec = aTime.tv_sec;
+	tv->tv_usec = aTime.tv_nsec / 1000;
+
+	return 0;
+}
+
+#else /* no clock */
+
+int fpm_clock_init()
+{
+	return 0;
+}
+
+int fpm_clock_get(struct timeval *tv)
+{
+	return gettimeofday(tv, 0);
+}
+
+#endif
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_clock.h php-src/sapi/fpm/fpm/fpm_clock.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_clock.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_clock.h	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,13 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_CLOCK_H
+#define FPM_CLOCK_H 1
+
+#include <sys/time.h>
+
+int fpm_clock_init();
+int fpm_clock_get(struct timeval *tv);
+
+#endif
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_conf.c php-src/sapi/fpm/fpm/fpm_conf.c
--- php-src-vanilla/sapi/fpm/fpm/fpm_conf.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_conf.c	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,537 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stddef.h>
+#if HAVE_INTTYPES_H
+#include <inttypes.h>
+#else
+#include <stdint.h>
+#endif
+
+#include <stdio.h>
+#include <unistd.h>
+
+#include "fpm.h"
+#include "fpm_conf.h"
+#include "fpm_stdio.h"
+#include "fpm_worker_pool.h"
+#include "fpm_cleanup.h"
+#include "fpm_php.h"
+#include "fpm_sockets.h"
+#include "xml_config.h"
+#include "zlog.h"
+
+
+struct fpm_global_config_s fpm_global_config;
+
+static void *fpm_global_config_ptr()
+{
+	return &fpm_global_config;
+}
+
+static char *fpm_conf_set_log_level(void **conf, char *name, void *vv, intptr_t offset)
+{
+	char *value = vv;
+
+	if (!strcmp(value, "debug")) {
+		fpm_globals.log_level = ZLOG_DEBUG;
+	}
+	else if (!strcmp(value, "notice")) {
+		fpm_globals.log_level = ZLOG_NOTICE;
+	}
+	else if (!strcmp(value, "warn")) {
+		fpm_globals.log_level = ZLOG_WARNING;
+	}
+	else if (!strcmp(value, "error")) {
+		fpm_globals.log_level = ZLOG_ERROR;
+	}
+	else if (!strcmp(value, "alert")) {
+		fpm_globals.log_level = ZLOG_ALERT;
+	}
+	else {
+		return "invalid value for 'log_level'";
+	}
+
+	return NULL;
+}
+
+static struct xml_conf_section xml_section_fpm_global_options = {
+	.conf = &fpm_global_config_ptr,
+	.path = "/configuration/global_options",
+	.parsers = (struct xml_value_parser []) {
+		{ XML_CONF_SCALAR,	"emergency_restart_threshold",		&xml_conf_set_slot_integer,		offsetof(struct fpm_global_config_s, emergency_restart_threshold) },
+		{ XML_CONF_SCALAR,	"emergency_restart_interval",		&xml_conf_set_slot_time,		offsetof(struct fpm_global_config_s, emergency_restart_interval) },
+		{ XML_CONF_SCALAR,	"process_control_timeout",			&xml_conf_set_slot_time,		offsetof(struct fpm_global_config_s, process_control_timeout) },
+		{ XML_CONF_SCALAR,	"daemonize",						&xml_conf_set_slot_boolean,		offsetof(struct fpm_global_config_s, daemonize) },
+		{ XML_CONF_SCALAR,	"pid_file",							&xml_conf_set_slot_string,		offsetof(struct fpm_global_config_s, pid_file) },
+		{ XML_CONF_SCALAR,	"error_log",						&xml_conf_set_slot_string,		offsetof(struct fpm_global_config_s, error_log) },
+		{ XML_CONF_SCALAR,  "log_level",						&fpm_conf_set_log_level,		0 },
+		{ 0, 0, 0, 0 }
+	}
+};
+
+static char *fpm_conf_set_pm_style(void **conf, char *name, void *vv, intptr_t offset)
+{
+	char *value = vv;
+	struct fpm_pm_s *c = *conf;
+
+	if (!strcmp(value, "static")) {
+		c->style = PM_STYLE_STATIC;
+	}
+	else if (!strcmp(value, "apache-like")) {
+		c->style = PM_STYLE_APACHE_LIKE;
+	}
+	else {
+		return "invalid value for 'style'";
+	}
+
+	return NULL;
+}
+
+static char *fpm_conf_set_rlimit_core(void **conf, char *name, void *vv, intptr_t offset)
+{
+	char *value = vv;
+	struct fpm_worker_pool_config_s *c = *conf;
+
+	if (!strcmp(value, "unlimited")) {
+		c->rlimit_core = -1;
+	}
+	else {
+		int int_value;
+		void *subconf = &int_value;
+		char *error;
+
+		error = xml_conf_set_slot_integer(&subconf, name, vv, 0);
+
+		if (error) { return error; }
+
+		if (int_value < 0) { return "invalid value for 'rlimit_core'"; }
+
+		c->rlimit_core = int_value;
+	}
+
+	return NULL;
+}
+
+static char *fpm_conf_set_catch_workers_output(void **conf, char *name, void *vv, intptr_t offset)
+{
+	struct fpm_worker_pool_config_s *c = *conf;
+	int int_value;
+	void *subconf = &int_value;
+	char *error;
+
+	error = xml_conf_set_slot_boolean(&subconf, name, vv, 0);
+
+	if (error) { return error; }
+
+	c->catch_workers_output = int_value;
+
+	return NULL;
+}
+
+static struct xml_conf_section fpm_conf_set_apache_like_subsection_conf = {
+	.path = "apache_like somewhere", /* fixme */
+	.parsers = (struct xml_value_parser []) {
+		{ XML_CONF_SCALAR, "StartServers",		&xml_conf_set_slot_integer, offsetof(struct fpm_pm_s, options_apache_like.StartServers) },
+		{ XML_CONF_SCALAR, "MinSpareServers",	&xml_conf_set_slot_integer, offsetof(struct fpm_pm_s, options_apache_like.MinSpareServers) },
+		{ XML_CONF_SCALAR, "MaxSpareServers",	&xml_conf_set_slot_integer, offsetof(struct fpm_pm_s, options_apache_like.MaxSpareServers) },
+		{ 0, 0, 0, 0 }
+	}
+};
+
+static char *fpm_conf_set_apache_like_subsection(void **conf, char *name, void *xml_node, intptr_t offset)
+{
+	return xml_conf_parse_section(conf, &fpm_conf_set_apache_like_subsection_conf, xml_node);
+}
+
+static struct xml_conf_section fpm_conf_set_listen_options_subsection_conf = {
+	.path = "listen options somewhere", /* fixme */
+	.parsers = (struct xml_value_parser []) {
+		{ XML_CONF_SCALAR,		"backlog",		&xml_conf_set_slot_integer,		offsetof(struct fpm_listen_options_s, backlog) },
+		{ XML_CONF_SCALAR,		"owner",		&xml_conf_set_slot_string,		offsetof(struct fpm_listen_options_s, owner) },
+		{ XML_CONF_SCALAR,		"group",		&xml_conf_set_slot_string,		offsetof(struct fpm_listen_options_s, group) },
+		{ XML_CONF_SCALAR,		"mode",			&xml_conf_set_slot_string,		offsetof(struct fpm_listen_options_s, mode) },
+		{ 0, 0, 0, 0 }
+	}
+};
+
+static char *fpm_conf_set_listen_options_subsection(void **conf, char *name, void *xml_node, intptr_t offset)
+{
+	void *subconf = (char *) *conf + offset;
+	struct fpm_listen_options_s *lo;
+
+	lo = malloc(sizeof(*lo));
+
+	if (!lo) {
+		return "malloc() failed";
+	}
+
+	memset(lo, 0, sizeof(*lo));
+
+	lo->backlog = -1;
+
+	* (struct fpm_listen_options_s **) subconf = lo;
+
+	subconf = lo;
+
+	return xml_conf_parse_section(&subconf, &fpm_conf_set_listen_options_subsection_conf, xml_node);
+}
+
+static struct xml_conf_section fpm_conf_set_pm_subsection_conf = {
+	.path = "pm settings somewhere", /* fixme */
+	.parsers = (struct xml_value_parser []) {
+		{ XML_CONF_SCALAR,		"style",				&fpm_conf_set_pm_style,						0 },
+		{ XML_CONF_SCALAR,		"max_children",			&xml_conf_set_slot_integer,					offsetof(struct fpm_pm_s, max_children) },
+		{ XML_CONF_SUBSECTION,	"apache_like",			&fpm_conf_set_apache_like_subsection,		offsetof(struct fpm_pm_s, options_apache_like) },
+		{ 0, 0, 0, 0 }
+	}
+};
+
+static char *fpm_conf_set_pm_subsection(void **conf, char *name, void *xml_node, intptr_t offset)
+{
+	void *subconf = (char *) *conf + offset;
+	struct fpm_pm_s *pm;
+
+	pm = malloc(sizeof(*pm));
+
+	if (!pm) {
+		return "fpm_conf_set_pm_subsection(): malloc failed";
+	}
+
+	memset(pm, 0, sizeof(*pm));
+
+	* (struct fpm_pm_s **) subconf = pm;
+
+	subconf = pm;
+
+	return xml_conf_parse_section(&subconf, &fpm_conf_set_pm_subsection_conf, xml_node);
+}
+
+static char *xml_conf_set_slot_key_value_pair(void **conf, char *name, void *vv, intptr_t offset)
+{
+	char *value = vv;
+	struct key_value_s *kv;
+	struct key_value_s ***parent = (struct key_value_s ***) conf;
+
+	kv = malloc(sizeof(*kv));
+
+	if (!kv) {
+		return "malloc() failed";
+	}
+
+	memset(kv, 0, sizeof(*kv));
+
+	kv->key = strdup(name);
+	kv->value = strdup(value);
+
+	if (!kv->key || !kv->value) {
+		return "xml_conf_set_slot_key_value_pair(): strdup() failed";
+	}
+
+	**parent = kv;
+
+	*parent = &kv->next;
+
+	return NULL;
+}
+
+static struct xml_conf_section fpm_conf_set_key_value_pairs_subsection_conf = {
+	.path = "key_value_pairs somewhere", /* fixme */
+	.parsers = (struct xml_value_parser []) {
+		{ XML_CONF_SCALAR, 0, &xml_conf_set_slot_key_value_pair, 0 },
+		{ 0, 0, 0, 0 }
+	}
+};
+
+static char *fpm_conf_set_key_value_pairs_subsection(void **conf, char *name, void *xml_node, intptr_t offset)
+{
+	void *next_kv = (char *) *conf + offset;
+
+	return xml_conf_parse_section(&next_kv, &fpm_conf_set_key_value_pairs_subsection_conf, xml_node);
+}
+
+static void *fpm_worker_pool_config_alloc()
+{
+	static struct fpm_worker_pool_s *current_wp = 0;
+	struct fpm_worker_pool_s *wp;
+
+	wp = fpm_worker_pool_alloc();
+
+	if (!wp) { return 0; }
+
+	wp->config = malloc(sizeof(struct fpm_worker_pool_config_s));
+
+	if (!wp->config) { return 0; }
+
+	memset(wp->config, 0, sizeof(struct fpm_worker_pool_config_s));
+
+	if (current_wp) { current_wp->next = wp; }
+
+	current_wp = wp;
+
+	return wp->config;
+}
+
+int fpm_worker_pool_config_free(struct fpm_worker_pool_config_s *wpc)
+{
+	struct key_value_s *kv, *kv_next;
+
+	free(wpc->name);
+	free(wpc->listen_address);
+	if (wpc->listen_options) {
+		free(wpc->listen_options->owner);
+		free(wpc->listen_options->group);
+		free(wpc->listen_options->mode);
+		free(wpc->listen_options);
+	}
+	for (kv = wpc->php_defines; kv; kv = kv_next) {
+		kv_next = kv->next;
+		free(kv->key);
+		free(kv->value);
+		free(kv);
+	}
+	for (kv = wpc->environment; kv; kv = kv_next) {
+		kv_next = kv->next;
+		free(kv->key);
+		free(kv->value);
+		free(kv);
+	}
+	free(wpc->pm);
+	free(wpc->user);
+	free(wpc->group);
+	free(wpc->chroot);
+	free(wpc->chdir);
+	free(wpc->allowed_clients);
+	free(wpc->slowlog);
+
+	return 0;
+}
+
+static struct xml_conf_section xml_section_fpm_worker_pool_config = {
+	.conf = &fpm_worker_pool_config_alloc,
+	.path = "/configuration/workers/pool",
+	.parsers = (struct xml_value_parser []) {
+		{ XML_CONF_SCALAR,		"name",							&xml_conf_set_slot_string,					offsetof(struct fpm_worker_pool_config_s, name) },
+		{ XML_CONF_SCALAR,		"listen_address",				&xml_conf_set_slot_string,					offsetof(struct fpm_worker_pool_config_s, listen_address) },
+		{ XML_CONF_SUBSECTION,	"listen_options",				&fpm_conf_set_listen_options_subsection,	offsetof(struct fpm_worker_pool_config_s, listen_options) },
+		{ XML_CONF_SUBSECTION,	"php_defines",					&fpm_conf_set_key_value_pairs_subsection,	offsetof(struct fpm_worker_pool_config_s, php_defines) },
+		{ XML_CONF_SCALAR,		"user",							&xml_conf_set_slot_string,					offsetof(struct fpm_worker_pool_config_s, user) },
+		{ XML_CONF_SCALAR,		"group",						&xml_conf_set_slot_string,					offsetof(struct fpm_worker_pool_config_s, group) },
+		{ XML_CONF_SCALAR,		"chroot",						&xml_conf_set_slot_string,					offsetof(struct fpm_worker_pool_config_s, chroot) },
+		{ XML_CONF_SCALAR,		"chdir",						&xml_conf_set_slot_string,					offsetof(struct fpm_worker_pool_config_s, chdir) },
+		{ XML_CONF_SCALAR,		"allowed_clients",				&xml_conf_set_slot_string,					offsetof(struct fpm_worker_pool_config_s, allowed_clients) },
+		{ XML_CONF_SUBSECTION,	"environment",					&fpm_conf_set_key_value_pairs_subsection,	offsetof(struct fpm_worker_pool_config_s, environment) },
+		{ XML_CONF_SCALAR,		"request_terminate_timeout",	&xml_conf_set_slot_time,					offsetof(struct fpm_worker_pool_config_s, request_terminate_timeout) },
+		{ XML_CONF_SCALAR,		"request_slowlog_timeout",		&xml_conf_set_slot_time,					offsetof(struct fpm_worker_pool_config_s, request_slowlog_timeout) },
+		{ XML_CONF_SCALAR,		"slowlog",						&xml_conf_set_slot_string,					offsetof(struct fpm_worker_pool_config_s, slowlog) },
+		{ XML_CONF_SCALAR,		"rlimit_files",					&xml_conf_set_slot_integer,					offsetof(struct fpm_worker_pool_config_s, rlimit_files) },
+		{ XML_CONF_SCALAR,		"rlimit_core",					&fpm_conf_set_rlimit_core,					0 },
+		{ XML_CONF_SCALAR,		"max_requests",					&xml_conf_set_slot_integer,					offsetof(struct fpm_worker_pool_config_s, max_requests) },
+		{ XML_CONF_SCALAR,		"catch_workers_output",			&fpm_conf_set_catch_workers_output,			0 },
+		{ XML_CONF_SUBSECTION,	"pm",							&fpm_conf_set_pm_subsection,				offsetof(struct fpm_worker_pool_config_s, pm) },
+		{ 0, 0, 0, 0 }
+	}
+};
+
+static struct xml_conf_section *fpm_conf_all_sections[] = {
+	&xml_section_fpm_global_options,
+	&xml_section_fpm_worker_pool_config,
+	0
+};
+
+static int fpm_evaluate_full_path(char **path)
+{
+	if (**path != '/') {
+		char *full_path;
+
+		full_path = malloc(sizeof(PHP_PREFIX) + strlen(*path) + 1);
+
+		if (!full_path) { return -1; }
+
+		sprintf(full_path, "%s/%s", PHP_PREFIX, *path);
+
+		free(*path);
+
+		*path = full_path;
+	}
+
+	return 0;
+}
+
+static int fpm_conf_process_all_pools()
+{
+	struct fpm_worker_pool_s *wp;
+
+	if (!fpm_worker_all_pools) {
+		zlog(ZLOG_STUFF, ZLOG_ERROR, "at least one pool section must be specified in config file");
+		return -1;
+	}
+
+	for (wp = fpm_worker_all_pools; wp; wp = wp->next) {
+
+		if (wp->config->listen_address && *wp->config->listen_address) {
+
+			wp->listen_address_domain = fpm_sockets_domain_from_address(wp->config->listen_address);
+
+			if (wp->listen_address_domain == FPM_AF_UNIX && *wp->config->listen_address != '/') {
+				fpm_evaluate_full_path(&wp->config->listen_address);
+			}
+
+		}
+		else {
+
+			wp->is_template = 1;
+
+		}
+
+		if (wp->config->request_slowlog_timeout) {
+#if HAVE_FPM_TRACE
+			if (! (wp->config->slowlog && *wp->config->slowlog)) {
+				zlog(ZLOG_STUFF, ZLOG_ERROR, "pool %s: 'slowlog' must be specified for use with 'request_slowlog_timeout'",
+					wp->config->name);
+				return -1;
+			}
+#else
+			static int warned = 0;
+
+			if (!warned) {
+				zlog(ZLOG_STUFF, ZLOG_WARNING, "pool %s: 'request_slowlog_timeout' is not supported on your system",
+					wp->config->name);
+				warned = 1;
+			}
+
+			wp->config->request_slowlog_timeout = 0;
+#endif
+		}
+
+		if (wp->config->request_slowlog_timeout && wp->config->slowlog && *wp->config->slowlog) {
+			int fd;
+
+			fpm_evaluate_full_path(&wp->config->slowlog);
+
+			if (wp->config->request_slowlog_timeout) {
+				fd = open(wp->config->slowlog, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR);
+
+				if (0 > fd) {
+					zlog(ZLOG_STUFF, ZLOG_SYSERROR, "open(%s) failed", wp->config->slowlog);
+					return -1;
+				}
+				close(fd);
+			}
+		}
+	}
+
+	return 0;
+}
+
+int fpm_conf_unlink_pid()
+{
+	if (fpm_global_config.pid_file) {
+
+		if (0 > unlink(fpm_global_config.pid_file)) {
+			zlog(ZLOG_STUFF, ZLOG_SYSERROR, "unlink(\"%s\") failed", fpm_global_config.pid_file);
+			return -1;
+		}
+
+	}
+
+	return 0;
+}
+
+int fpm_conf_write_pid()
+{
+	int fd;
+
+	if (fpm_global_config.pid_file) {
+		char buf[64];
+		int len;
+
+		unlink(fpm_global_config.pid_file);
+
+		fd = creat(fpm_global_config.pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+
+		if (fd < 0) {
+			zlog(ZLOG_STUFF, ZLOG_SYSERROR, "creat(\"%s\") failed", fpm_global_config.pid_file);
+			return -1;
+		}
+
+		len = sprintf(buf, "%d", (int) fpm_globals.parent_pid);
+
+		if (len != write(fd, buf, len)) {
+			zlog(ZLOG_STUFF, ZLOG_SYSERROR, "write() failed");
+			return -1;
+		}
+
+		close(fd);
+	}
+
+	return 0;
+}
+
+static int fpm_conf_post_process()
+{
+	if (fpm_global_config.pid_file) {
+		fpm_evaluate_full_path(&fpm_global_config.pid_file);
+	}
+
+	if (!fpm_global_config.error_log) {
+		fpm_global_config.error_log = strdup(PHP_FPM_LOG_PATH);
+	}
+
+	fpm_evaluate_full_path(&fpm_global_config.error_log);
+
+	if (0 > fpm_stdio_open_error_log(0)) {
+		return -1;
+	}
+
+	return fpm_conf_process_all_pools();
+}
+
+static void fpm_conf_cleanup(int which, void *arg)
+{
+	free(fpm_global_config.pid_file);
+	free(fpm_global_config.error_log);
+	fpm_global_config.pid_file = 0;
+	fpm_global_config.error_log = 0;
+}
+
+int fpm_conf_init_main()
+{
+	char *filename = fpm_globals.config;
+	char *err;
+
+	if (0 > xml_conf_sections_register(fpm_conf_all_sections)) {
+		return -1;
+	}
+
+	if (filename == NULL) {
+		filename = PHP_FPM_CONF_PATH;
+	}
+
+	err = xml_conf_load_file(filename);
+
+	if (err) {
+		zlog(ZLOG_STUFF, ZLOG_ERROR, "failed to load configuration file: %s", err);
+		return -1;
+	}
+
+	if (0 > fpm_conf_post_process()) {
+		return -1;
+	}
+
+	xml_conf_clean();
+
+	if (0 > fpm_cleanup_add(FPM_CLEANUP_ALL, fpm_conf_cleanup, 0)) {
+		return -1;
+	}
+
+	return 0;
+}
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_conf.h php-src/sapi/fpm/fpm/fpm_conf.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_conf.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_conf.h	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,73 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_CONF_H
+#define FPM_CONF_H 1
+
+struct key_value_s;
+
+struct key_value_s {
+	struct key_value_s *next;
+	char *key;
+	char *value;
+};
+
+struct fpm_global_config_s {
+	int emergency_restart_threshold;
+	int emergency_restart_interval;
+	int process_control_timeout;
+	int daemonize;
+	char *pid_file;
+	char *error_log;
+};
+
+extern struct fpm_global_config_s fpm_global_config;
+
+struct fpm_pm_s {
+	int style;
+	int max_children;
+	struct {
+		int StartServers;
+		int MinSpareServers;
+		int MaxSpareServers;
+	} options_apache_like;
+};
+
+struct fpm_listen_options_s {
+	int backlog;
+	char *owner;
+	char *group;
+	char *mode;
+};
+
+struct fpm_worker_pool_config_s {
+	char *name;
+	char *listen_address;
+	struct fpm_listen_options_s *listen_options;
+	struct key_value_s *php_defines;
+	char *user;
+	char *group;
+	char *chroot;
+	char *chdir;
+	char *allowed_clients;
+	struct key_value_s *environment;
+	struct fpm_pm_s *pm;
+	int request_terminate_timeout;
+	int request_slowlog_timeout;
+	char *slowlog;
+	int max_requests;
+	int rlimit_files;
+	int rlimit_core;
+	unsigned catch_workers_output:1;
+};
+
+enum { PM_STYLE_STATIC = 1, PM_STYLE_APACHE_LIKE = 2 };
+
+int fpm_conf_init_main();
+int fpm_worker_pool_config_free(struct fpm_worker_pool_config_s *wpc);
+int fpm_conf_write_pid();
+int fpm_conf_unlink_pid();
+
+#endif
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_config.h php-src/sapi/fpm/fpm/fpm_config.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_config.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_config.h	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,40 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include <php_config.h>
+#ifdef FPM_AUTOCONFIG_H
+#include <fpm_autoconfig.h>
+#endif
+
+/* Solaris does not have it */
+#ifndef INADDR_NONE
+#define INADDR_NONE (-1)
+#endif
+
+
+/* If we're not using GNU C, elide __attribute__ */
+#ifndef __GNUC__
+#  define  __attribute__(x)  /*NOTHING*/
+#endif
+
+
+/* Solaris does not have it */
+#ifndef timersub
+#define	timersub(tvp, uvp, vvp)						\
+	do {								\
+		(vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec;		\
+		(vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec;	\
+		if ((vvp)->tv_usec < 0) {				\
+			(vvp)->tv_sec--;				\
+			(vvp)->tv_usec += 1000000;			\
+		}							\
+	} while (0)
+#endif
+
+#if defined(HAVE_PTRACE) || defined(PROC_MEM_FILE) || defined(HAVE_MACH_VM_READ)
+#define HAVE_FPM_TRACE 1
+#else
+#define HAVE_FPM_TRACE 0
+#endif
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_env.c php-src/sapi/fpm/fpm/fpm_env.c
--- php-src-vanilla/sapi/fpm/fpm/fpm_env.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_env.c	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,175 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#ifdef HAVE_ALLOCA_H
+#include <alloca.h>
+#endif
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "fpm_env.h"
+#include "zlog.h"
+
+#ifndef HAVE_SETENV
+#ifdef (__sparc__ || __sparc)
+int     setenv(name, value, clobber)
+char   *name;
+char   *value;
+int     clobber;
+{
+    char   *malloc();
+    char   *getenv();
+    char   *cp;
+
+    if (clobber == 0 && getenv(name) != 0)
+        { return (0); }
+    if ((cp = malloc(strlen(name) + strlen(value) + 2)) == 0)
+        { return (1); }
+    sprintf(cp, "%s=%s", name, value);
+    return (putenv(cp));
+}
+#else
+int setenv(char *name, char *value, int overwrite)
+{
+	int name_len = strlen(name);
+	int value_len = strlen(value);
+	char *var = alloca(name_len + 1 + value_len + 1);
+
+	memcpy(var, name, name_len);
+
+	var[name_len] = '=';
+
+	memcpy(var + name_len + 1, value, value_len);
+
+	var[name_len + 1 + value_len] = '\0';
+
+	return putenv(var);
+}
+#endif
+#endif
+
+#ifndef HAVE_CLEARENV
+void clearenv()
+{
+	char **envp;
+	char *s;
+
+	/* this algo is the only one known to me
+		that works well on all systems */
+	while (*(envp = environ)) {
+		char *eq = strchr(*envp, '=');
+
+		s = strdup(*envp);
+
+		if (eq) { s[eq - *envp] = '\0'; }
+
+		unsetenv(s);
+		free(s);
+	}
+
+}
+#endif
+
+#ifndef HAVE_UNSETENV
+void unsetenv(const char *name)
+{
+    if(getenv(name)!=NULL)
+    {
+        int ct=0;
+        int del=0;
+
+        while(environ[ct] != NULL)
+        {
+            if (nvmatch(name, environ[ct])  != 0) del=ct;
+                { ct++; }
+        }
+    /* isn't needed free here?? */
+    environ[del]=environ[ct-1];
+    environ[ct-1]=NULL;
+    }
+}
+static char * nvmatch(s1, s2)
+register char *s1, *s2;
+{
+    while(*s1 == *s2++)
+	{
+		if(*s1++ == '=')
+		    { return(s2); }
+	}
+    if(*s1 == '\0' && *(s2-1) == '=')
+	    { return(s2); }
+    return(NULL);
+}
+#endif
+
+int fpm_env_init_child(struct fpm_worker_pool_s *wp)
+{
+	struct key_value_s *kv;
+
+	clearenv();
+
+	for (kv = wp->config->environment; kv; kv = kv->next) {
+		setenv(kv->key, kv->value, 1);
+	}
+
+	if (wp->user) {
+		setenv("USER", wp->user, 1);
+	}
+
+	if (wp->home) {
+		setenv("HOME", wp->home, 1);
+	}
+
+	return 0;
+}
+
+static int fpm_env_conf_wp(struct fpm_worker_pool_s *wp)
+{
+	struct key_value_s *kv;
+
+	kv = wp->config->environment;
+
+	for (kv = wp->config->environment; kv; kv = kv->next) {
+		if (*kv->value == '$') {
+			char *value = getenv(kv->value + 1);
+
+			if (!value) { value = ""; }
+
+			free(kv->value);
+			kv->value = strdup(value);
+		}
+
+		/* autodetected values should be removed
+			if these vars specified in config */
+		if (!strcmp(kv->key, "USER")) {
+			free(wp->user);
+			wp->user = 0;
+		}
+
+		if (!strcmp(kv->key, "HOME")) {
+			free(wp->home);
+			wp->home = 0;
+		}
+	}
+
+	return 0;
+}
+
+int fpm_env_init_main()
+{
+	struct fpm_worker_pool_s *wp;
+
+	for (wp = fpm_worker_all_pools; wp; wp = wp->next) {
+
+		if (0 > fpm_env_conf_wp(wp)) {
+			return -1;
+		}
+
+	}
+
+	return 0;
+}
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_env.h php-src/sapi/fpm/fpm/fpm_env.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_env.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_env.h	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,24 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_ENV_H
+#define FPM_ENV_H 1
+
+#include "fpm_worker_pool.h"
+
+int fpm_env_init_child(struct fpm_worker_pool_s *wp);
+int fpm_env_init_main();
+
+extern char **environ;
+
+#ifndef HAVE_SETENV
+int setenv(char *name, char *value, int overwrite);
+#endif
+
+#ifndef HAVE_CLEARENV
+void clearenv();
+#endif
+
+#endif
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_events.c php-src/sapi/fpm/fpm/fpm_events.c
--- php-src-vanilla/sapi/fpm/fpm/fpm_events.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_events.c	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,135 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#include <unistd.h>
+#include <errno.h>
+#include <stdlib.h> /* for putenv */
+#include <string.h>
+#include <sys/types.h> /* for event.h below */
+#include <event.h>
+
+#include "fpm.h"
+#include "fpm_process_ctl.h"
+#include "fpm_events.h"
+#include "fpm_cleanup.h"
+#include "fpm_stdio.h"
+#include "fpm_signals.h"
+#include "fpm_children.h"
+#include "zlog.h"
+
+static void fpm_event_cleanup(int which, void *arg)
+{
+	event_base_free(0);
+}
+
+static void fpm_got_signal(int fd, short ev, void *arg)
+{
+	char c;
+	int res;
+
+	do {
+
+		do {
+			res = read(fd, &c, 1);
+		} while (res == -1 && errno == EINTR);
+
+		if (res <= 0) {
+			if (res < 0 && errno != EAGAIN && errno != EWOULDBLOCK) {
+				zlog(ZLOG_STUFF, ZLOG_SYSERROR, "read() failed");
+			}
+			return;
+		}
+
+		switch (c) {
+			case 'C' :                  /* SIGCHLD */
+				zlog(ZLOG_STUFF, ZLOG_NOTICE, "received SIGCHLD");
+				fpm_children_bury();
+				break;
+			case 'I' :                  /* SIGINT  */
+				zlog(ZLOG_STUFF, ZLOG_NOTICE, "received SIGINT");
+				fpm_pctl(FPM_PCTL_STATE_TERMINATING, FPM_PCTL_ACTION_SET);
+				break;
+			case 'T' :                  /* SIGTERM */
+				zlog(ZLOG_STUFF, ZLOG_NOTICE, "received SIGTERM");
+				fpm_pctl(FPM_PCTL_STATE_TERMINATING, FPM_PCTL_ACTION_SET);
+				break;
+			case 'Q' :                  /* SIGQUIT */
+				zlog(ZLOG_STUFF, ZLOG_NOTICE, "received SIGQUIT");
+				fpm_pctl(FPM_PCTL_STATE_FINISHING, FPM_PCTL_ACTION_SET);
+				break;
+			case '1' :                  /* SIGUSR1 */
+				zlog(ZLOG_STUFF, ZLOG_NOTICE, "received SIGUSR1");
+				if (0 == fpm_stdio_open_error_log(1)) {
+					zlog(ZLOG_STUFF, ZLOG_NOTICE, "log file re-opened");
+				}
+				break;
+			case '2' :                  /* SIGUSR2 */
+				zlog(ZLOG_STUFF, ZLOG_NOTICE, "received SIGUSR2");
+				fpm_pctl(FPM_PCTL_STATE_RELOADING, FPM_PCTL_ACTION_SET);
+				break;
+		}
+
+		if (fpm_globals.is_child) {
+			break;
+		}
+
+	} while (1);
+
+	return;
+}
+
+int fpm_event_init_main()
+{
+	event_init();
+
+	zlog(ZLOG_STUFF, ZLOG_NOTICE, "libevent: using %s", event_get_method());
+
+	if (0 > fpm_cleanup_add(FPM_CLEANUP_ALL, fpm_event_cleanup, 0)) {
+		return -1;
+	}
+
+	return 0;
+}
+
+int fpm_event_loop()
+{
+	static struct event signal_fd_event;
+
+	event_set(&signal_fd_event, fpm_signals_get_fd(), EV_PERSIST | EV_READ, &fpm_got_signal, 0);
+
+	event_add(&signal_fd_event, 0);
+
+	fpm_pctl_heartbeat(-1, 0, 0);
+
+	zlog(ZLOG_STUFF, ZLOG_NOTICE, "libevent: entering main loop");
+
+	event_loop(0);
+
+	return 0;
+}
+
+int fpm_event_add(int fd, struct event *ev, void (*callback)(int, short, void *), void *arg)
+{
+	event_set(ev, fd, EV_PERSIST | EV_READ, callback, arg);
+
+	return event_add(ev, 0);
+}
+
+int fpm_event_del(struct event *ev)
+{
+	return event_del(ev);
+}
+
+void fpm_event_exit_loop()
+{
+	event_loopbreak();
+}
+
+void fpm_event_fire(struct event *ev)
+{
+	(*ev->ev_callback)( (int) ev->ev_fd, (short) ev->ev_res, ev->ev_arg);	
+}
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_events.h php-src/sapi/fpm/fpm/fpm_events.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_events.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_events.h	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,16 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_EVENTS_H
+#define FPM_EVENTS_H 1
+
+void fpm_event_exit_loop();
+int fpm_event_loop();
+int fpm_event_add(int fd, struct event *ev, void (*callback)(int, short, void *), void *arg);
+int fpm_event_del(struct event *ev);
+void fpm_event_fire(struct event *ev);
+int fpm_event_init_main();
+
+
+#endif
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm.h php-src/sapi/fpm/fpm/fpm.h
--- php-src-vanilla/sapi/fpm/fpm/fpm.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm.h	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,28 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_H
+#define FPM_H 1
+
+#include <unistd.h>
+
+int fpm_run(int *max_requests);
+int fpm_init(int argc, char **argv, char *config);
+
+struct fpm_globals_s {
+	pid_t parent_pid;
+	int argc;
+	char **argv;
+	char *config;
+	int running_children;
+	int error_log_fd;
+	int log_level;
+	int listening_socket; /* for this child */
+	int max_requests; /* for this child */
+	int is_child;
+};
+
+extern struct fpm_globals_s fpm_globals;
+
+#endif
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_php.c php-src/sapi/fpm/fpm/fpm_php.c
--- php-src-vanilla/sapi/fpm/fpm/fpm_php.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_php.c	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,189 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "php.h"
+#include "php_main.h"
+#include "php_ini.h"
+#include "ext/standard/dl.h"
+
+#include "cgi/fastcgi.h"
+
+#include "fpm.h"
+#include "fpm_php.h"
+#include "fpm_cleanup.h"
+#include "fpm_worker_pool.h"
+
+static int zend_ini_alter_master(char *name, int name_length, char *new_value, int new_value_length, int stage TSRMLS_DC)
+{
+	zend_ini_entry *ini_entry;
+	char *duplicate;
+
+	if (zend_hash_find(EG(ini_directives), name, name_length, (void **) &ini_entry) == FAILURE) {
+		return FAILURE;
+	}
+
+	duplicate = strdup(new_value);
+
+	if (!ini_entry->on_modify
+		|| ini_entry->on_modify(ini_entry, duplicate, new_value_length,
+			ini_entry->mh_arg1, ini_entry->mh_arg2, ini_entry->mh_arg3, stage TSRMLS_CC) == SUCCESS) {
+		ini_entry->value = duplicate;
+		ini_entry->value_length = new_value_length;
+	} else {
+		free(duplicate);
+	}
+
+	return SUCCESS;
+}
+
+static void fpm_php_disable(char *value, int (*zend_disable)(char *, uint TSRMLS_DC) TSRMLS_DC)
+{
+	char *s = 0, *e = value;
+
+	while (*e) {
+		switch (*e) {
+			case ' ':
+			case ',':
+				if (s) {
+					*e = '\0';
+					zend_disable(s, e - s TSRMLS_CC);
+					s = 0;
+				}
+				break;
+			default:
+				if (!s) {
+					s = e;
+				}
+				break;
+		}
+		e++;
+	}
+
+	if (s) {
+		zend_disable(s, e - s TSRMLS_CC);
+	}
+}
+
+static int fpm_php_apply_defines(struct fpm_worker_pool_s *wp)
+{
+	TSRMLS_FETCH();
+	struct key_value_s *kv;
+
+	for (kv = wp->config->php_defines; kv; kv = kv->next) {
+		char *name = kv->key;
+		char *value = kv->value;
+		int name_len = strlen(name);
+		int value_len = strlen(value);
+
+		if (!strcmp(name, "extension") && *value) {
+			zval zv;
+
+#if defined(PHP_VERSION_ID) && (PHP_VERSION_ID >= 50300)
+			php_dl(value, MODULE_PERSISTENT, &zv, 1 TSRMLS_CC);
+#else
+			zval filename;
+			ZVAL_STRINGL(&filename, value, value_len, 0);
+#if (PHP_MAJOR_VERSION >= 5)
+			php_dl(&filename, MODULE_PERSISTENT, &zv, 1 TSRMLS_CC);
+#else
+			php_dl(&filename, MODULE_PERSISTENT, &zv TSRMLS_CC);
+#endif
+#endif
+			continue;
+		}
+
+		zend_ini_alter_master(name, name_len + 1, value, value_len, PHP_INI_STAGE_ACTIVATE TSRMLS_CC);
+
+		if (!strcmp(name, "disable_functions") && *value) {
+			char *v = strdup(value);
+#if (PHP_MAJOR_VERSION >= 5)
+			PG(disable_functions) = v;
+#endif
+			fpm_php_disable(v, zend_disable_function TSRMLS_CC);
+		}
+		else if (!strcmp(name, "disable_classes") && *value) {
+			char *v = strdup(value);
+#if (PHP_MAJOR_VERSION >= 5)
+			PG(disable_classes) = v;
+#endif
+			fpm_php_disable(v, zend_disable_class TSRMLS_CC);
+		}
+	}
+
+	return 0;
+}
+
+static int fpm_php_set_allowed_clients(struct fpm_worker_pool_s *wp)
+{
+	if (wp->listen_address_domain == FPM_AF_INET) {
+		fcgi_set_allowed_clients(wp->config->allowed_clients);
+	}
+
+	return 0;
+}
+
+static int fpm_php_set_fcgi_mgmt_vars(struct fpm_worker_pool_s *wp)
+{
+	char max_workers[10 + 1]; /* 4294967295 */
+	int len;
+
+	len = sprintf(max_workers, "%u", (unsigned int) wp->config->pm->max_children);
+
+	fcgi_set_mgmt_var("FCGI_MAX_CONNS", sizeof("FCGI_MAX_CONNS")-1, max_workers, len);
+	fcgi_set_mgmt_var("FCGI_MAX_REQS",  sizeof("FCGI_MAX_REQS")-1,  max_workers, len);
+
+	return 0;
+}
+
+char *fpm_php_script_filename(TSRMLS_D)
+{
+	return SG(request_info).path_translated;
+}
+
+char *fpm_php_request_method(TSRMLS_D)
+{
+	return (char *) SG(request_info).request_method;
+}
+
+size_t fpm_php_content_length(TSRMLS_D)
+{
+	return SG(request_info).content_length;
+}
+
+static void fpm_php_cleanup(int which, void *arg)
+{
+	TSRMLS_FETCH();
+	php_module_shutdown(TSRMLS_C);
+	sapi_shutdown();
+}
+
+void fpm_php_soft_quit()
+{
+	fcgi_set_in_shutdown(1);
+}
+
+int fpm_php_init_main()
+{
+	if (0 > fpm_cleanup_add(FPM_CLEANUP_PARENT, fpm_php_cleanup, 0)) {
+		return -1;
+	}
+
+	return 0;
+}
+
+int fpm_php_init_child(struct fpm_worker_pool_s *wp)
+{
+	if (0 > fpm_php_apply_defines(wp) ||
+		0 > fpm_php_set_allowed_clients(wp)) {
+		return -1;
+	}
+
+	return 0;
+}
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_php.h php-src/sapi/fpm/fpm/fpm_php.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_php.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_php.h	2009-10-18 21:05:39.302497288 +0100
@@ -0,0 +1,22 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_PHP_H
+#define FPM_PHP_H 1
+
+#include <TSRM.h>
+
+#include "build-defs.h" /* for PHP_ defines */
+
+struct fpm_worker_pool_s;
+
+int fpm_php_init_child(struct fpm_worker_pool_s *wp);
+char *fpm_php_script_filename(TSRMLS_D);
+char *fpm_php_request_method(TSRMLS_D);
+size_t fpm_php_content_length(TSRMLS_D);
+void fpm_php_soft_quit();
+int fpm_php_init_main();
+
+#endif
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_php_trace.c php-src/sapi/fpm/fpm/fpm_php_trace.c
--- php-src-vanilla/sapi/fpm/fpm/fpm_php_trace.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_php_trace.c	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,176 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#if HAVE_FPM_TRACE
+
+#include "php.h"
+#include "php_main.h"
+
+#include <stdio.h>
+#include <stddef.h>
+#if HAVE_INTTYPES_H
+#include <inttypes.h>
+#else
+#include <stdint.h>
+#endif
+
+#include <unistd.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <errno.h>
+
+#include "fpm_trace.h"
+#include "fpm_php_trace.h"
+#include "fpm_children.h"
+#include "fpm_worker_pool.h"
+#include "fpm_process_ctl.h"
+
+#include "zlog.h"
+
+
+#define valid_ptr(p) ((p) && 0 == ((p) & (sizeof(long) - 1)))
+
+#if SIZEOF_LONG == 4
+#define PTR_FMT "08"
+#elif SIZEOF_LONG == 8
+#define PTR_FMT "016"
+#endif
+
+
+static int fpm_php_trace_dump(struct fpm_child_s *child, FILE *slowlog TSRMLS_DC)
+{
+	int callers_limit = 20;
+	pid_t pid = child->pid;
+	struct timeval tv;
+	static const int buf_size = 1024;
+	char buf[buf_size];
+	long execute_data;
+	long l;
+
+	gettimeofday(&tv, 0);
+
+	zlog_print_time(&tv, buf, buf_size);
+
+	fprintf(slowlog, "\n%s pid %d (pool %s)\n", buf, (int) pid, child->wp->config->name);
+
+	if (0 > fpm_trace_get_strz(buf, buf_size, (long) &SG(request_info).path_translated)) {
+		return -1;
+	}
+
+	fprintf(slowlog, "script_filename = %s\n", buf);
+
+	if (0 > fpm_trace_get_long((long) &EG(current_execute_data), &l)) {
+		return -1;
+	}
+
+	execute_data = l;
+
+	while (execute_data) {
+		long function;
+		uint lineno = 0;
+
+		fprintf(slowlog, "[0x%" PTR_FMT "lx] ", execute_data);
+
+		if (0 > fpm_trace_get_long(execute_data + offsetof(zend_execute_data, function_state.function), &l)) {
+			return -1;
+		}
+
+		function = l;
+
+		if (valid_ptr(function)) {
+			if (0 > fpm_trace_get_strz(buf, buf_size, function + offsetof(zend_function, common.function_name))) {
+				return -1;
+			}
+
+			fprintf(slowlog, "%s()", buf);
+		}
+		else {
+			fprintf(slowlog, "???");
+		}
+
+		if (0 > fpm_trace_get_long(execute_data + offsetof(zend_execute_data, op_array), &l)) {
+			return -1;
+		}
+
+		*buf = '\0';
+
+		if (valid_ptr(l)) {
+			long op_array = l;
+
+			if (0 > fpm_trace_get_strz(buf, buf_size, op_array + offsetof(zend_op_array, filename))) {
+				return -1;
+			}
+		}
+
+		if (0 > fpm_trace_get_long(execute_data + offsetof(zend_execute_data, opline), &l)) {
+			return -1;
+		}
+
+		if (valid_ptr(l)) {
+			long opline = l;
+			uint *lu = (uint *) &l;
+
+			if (0 > fpm_trace_get_long(opline + offsetof(struct _zend_op, lineno), &l)) {
+				return -1;
+			}
+
+			lineno = *lu;
+		}
+
+		fprintf(slowlog, " %s:%u\n", *buf ? buf : "unknown", lineno);
+
+		if (0 > fpm_trace_get_long(execute_data + offsetof(zend_execute_data, prev_execute_data), &l)) {
+			return -1;
+		}
+
+		execute_data = l;
+
+		if (0 == --callers_limit) {
+			break;
+		}
+	}
+
+	return 0;
+}
+
+void fpm_php_trace(struct fpm_child_s *child)
+{
+	TSRMLS_FETCH();
+	FILE *slowlog;
+
+	zlog(ZLOG_STUFF, ZLOG_NOTICE, "about to trace %d", (int) child->pid);
+
+	slowlog = fopen(child->wp->config->slowlog, "a+");
+
+	if (!slowlog) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "fopen(%s) failed", child->wp->config->slowlog);
+		goto done0;
+	}
+
+	if (0 > fpm_trace_ready(child->pid)) {
+		goto done1;
+	}
+
+	if (0 > fpm_php_trace_dump(child, slowlog TSRMLS_CC)) {
+		fprintf(slowlog, "+++ dump failed\n");
+	}
+
+	if (0 > fpm_trace_close(child->pid)) {
+		goto done1;
+	}
+
+done1:
+	fclose(slowlog);
+
+done0:
+	fpm_pctl_kill(child->pid, FPM_PCTL_CONT);
+	child->tracer = 0;
+
+	zlog(ZLOG_STUFF, ZLOG_NOTICE, "finished trace of %d", (int) child->pid);
+}
+
+#endif
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_php_trace.h php-src/sapi/fpm/fpm/fpm_php_trace.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_php_trace.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_php_trace.h	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,13 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_PHP_TRACE_H
+#define FPM_PHP_TRACE_H 1
+
+struct fpm_child_s;
+
+void fpm_php_trace(struct fpm_child_s *);
+
+#endif
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_process_ctl.c php-src/sapi/fpm/fpm/fpm_process_ctl.c
--- php-src-vanilla/sapi/fpm/fpm/fpm_process_ctl.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_process_ctl.c	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,354 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#include <sys/types.h>
+#include <signal.h>
+#include <unistd.h>
+#include <stdlib.h>
+
+#include "fpm.h"
+#include "fpm_clock.h"
+#include "fpm_children.h"
+#include "fpm_signals.h"
+#include "fpm_events.h"
+#include "fpm_process_ctl.h"
+#include "fpm_cleanup.h"
+#include "fpm_request.h"
+#include "fpm_worker_pool.h"
+#include "zlog.h"
+
+
+static int fpm_state = FPM_PCTL_STATE_NORMAL;
+static int fpm_signal_sent = 0;
+
+
+static const char *fpm_state_names[] = {
+	[FPM_PCTL_STATE_NORMAL] = "normal",
+	[FPM_PCTL_STATE_RELOADING] = "reloading",
+	[FPM_PCTL_STATE_TERMINATING] = "terminating",
+	[FPM_PCTL_STATE_FINISHING] = "finishing"
+};
+
+static int saved_argc;
+static char **saved_argv;
+
+static void fpm_pctl_cleanup(int which, void *arg)
+{
+	int i;
+
+	if (which != FPM_CLEANUP_PARENT_EXEC) {
+
+		for (i = 0; i < saved_argc; i++) {
+			free(saved_argv[i]);
+		}
+
+		free(saved_argv);
+
+	}
+}
+
+static struct event pctl_event;
+
+static void fpm_pctl_action(int fd, short which, void *arg)
+{
+	evtimer_del(&pctl_event);
+
+	memset(&pctl_event, 0, sizeof(pctl_event));
+
+	fpm_pctl(FPM_PCTL_STATE_UNSPECIFIED, FPM_PCTL_ACTION_TIMEOUT);
+}
+
+static int fpm_pctl_timeout_set(int sec)
+{
+	struct timeval tv = { .tv_sec = sec, .tv_usec = 0 };
+
+	if (evtimer_initialized(&pctl_event)) {
+		evtimer_del(&pctl_event);
+	}
+
+	evtimer_set(&pctl_event, &fpm_pctl_action, 0);
+
+	evtimer_add(&pctl_event, &tv);
+
+	return 0;
+}
+
+static void fpm_pctl_exit()
+{
+	zlog(ZLOG_STUFF, ZLOG_NOTICE, "exiting, bye-bye!");
+
+	fpm_conf_unlink_pid();
+
+	fpm_cleanups_run(FPM_CLEANUP_PARENT_EXIT_MAIN);
+
+	exit(0);
+}
+
+#define optional_arg(c) (saved_argc > c ? ", \"" : ""), (saved_argc > c ? saved_argv[c] : ""), (saved_argc > c ? "\"" : "")
+
+static void fpm_pctl_exec()
+{
+
+	zlog(ZLOG_STUFF, ZLOG_NOTICE, "reloading: execvp(\"%s\", {\"%s\""
+			"%s%s%s" "%s%s%s" "%s%s%s" "%s%s%s" "%s%s%s"
+			"%s%s%s" "%s%s%s" "%s%s%s" "%s%s%s" "%s%s%s"
+		"})",
+		saved_argv[0], saved_argv[0],
+		optional_arg(1),
+		optional_arg(2),
+		optional_arg(3),
+		optional_arg(4),
+		optional_arg(5),
+		optional_arg(6),
+		optional_arg(7),
+		optional_arg(8),
+		optional_arg(9),
+		optional_arg(10)
+	);
+
+	fpm_cleanups_run(FPM_CLEANUP_PARENT_EXEC);
+
+	execvp(saved_argv[0], saved_argv);
+
+	zlog(ZLOG_STUFF, ZLOG_SYSERROR, "execvp() failed");
+
+	exit(1);
+}
+
+static void fpm_pctl_action_last()
+{
+	switch (fpm_state) {
+
+		case FPM_PCTL_STATE_RELOADING :
+
+			fpm_pctl_exec();
+			break;
+
+		case FPM_PCTL_STATE_FINISHING :
+
+		case FPM_PCTL_STATE_TERMINATING :
+
+			fpm_pctl_exit();
+			break;
+	}
+}
+
+int fpm_pctl_kill(pid_t pid, int how)
+{
+	int s = 0;
+
+	switch (how) {
+		case FPM_PCTL_TERM :
+			s = SIGTERM;
+			break;
+		case FPM_PCTL_STOP :
+			s = SIGSTOP;
+			break;
+		case FPM_PCTL_CONT :
+			s = SIGCONT;
+			break;
+		default :
+			break;
+	}
+
+	return kill(pid, s);
+}
+
+static void fpm_pctl_kill_all(int signo)
+{
+	struct fpm_worker_pool_s *wp;
+	int alive_children = 0;
+
+	for (wp = fpm_worker_all_pools; wp; wp = wp->next) {
+		struct fpm_child_s *child;
+
+		for (child = wp->children; child; child = child->next) {
+
+			int res = kill(child->pid, signo);
+
+			zlog(ZLOG_STUFF, ZLOG_NOTICE, "sending signal %d %s to child %d (pool %s)", signo,
+				fpm_signal_names[signo] ? fpm_signal_names[signo] : "",
+				(int) child->pid, child->wp->config->name);
+
+			if (res == 0) { ++alive_children; }
+		}
+	}
+
+	if (alive_children) {
+		zlog(ZLOG_STUFF, ZLOG_NOTICE, "%d %s still alive", alive_children, alive_children == 1 ? "child is" : "children are");
+	}
+}
+
+static void fpm_pctl_action_next()
+{
+	int sig, timeout;
+
+	if (!fpm_globals.running_children) { fpm_pctl_action_last(); }
+
+	if (fpm_signal_sent == 0) {
+		if (fpm_state == FPM_PCTL_STATE_TERMINATING) {
+			sig = SIGTERM;
+		}
+		else {
+			sig = SIGQUIT;
+		}
+		timeout = fpm_global_config.process_control_timeout;
+	}
+	else {
+		if (fpm_signal_sent == SIGQUIT) {
+			sig = SIGTERM;
+		}
+		else {
+			sig = SIGKILL;
+		}
+		timeout = 1;
+	}
+
+	fpm_pctl_kill_all(sig);
+
+	fpm_signal_sent = sig;
+
+	fpm_pctl_timeout_set(timeout);
+}
+
+void fpm_pctl(int new_state, int action)
+{
+	switch (action) {
+
+		case FPM_PCTL_ACTION_SET :
+
+			if (fpm_state == new_state) { /* already in progress - just ignore duplicate signal */
+				return;
+			}
+
+			switch (fpm_state) { /* check which states can be overridden */
+
+				case FPM_PCTL_STATE_NORMAL :
+
+					/* 'normal' can be overridden by any other state */
+					break;
+
+				case FPM_PCTL_STATE_RELOADING :
+
+					/* 'reloading' can be overridden by 'finishing' */
+					if (new_state == FPM_PCTL_STATE_FINISHING) { break; }
+
+				case FPM_PCTL_STATE_FINISHING :
+
+					/* 'reloading' and 'finishing' can be overridden by 'terminating' */
+					if (new_state == FPM_PCTL_STATE_TERMINATING) { break; }
+
+				case FPM_PCTL_STATE_TERMINATING :
+
+					/* nothing can override 'terminating' state */
+					zlog(ZLOG_STUFF, ZLOG_NOTICE, "not switching to '%s' state, because already in '%s' state",
+						fpm_state_names[new_state], fpm_state_names[fpm_state]);
+
+					return;
+			}
+
+			fpm_signal_sent = 0;
+			fpm_state = new_state;
+
+			zlog(ZLOG_STUFF, ZLOG_NOTICE, "switching to '%s' state", fpm_state_names[fpm_state]);
+
+			/* fall down */
+
+		case FPM_PCTL_ACTION_TIMEOUT :
+
+			fpm_pctl_action_next();
+
+			break;
+
+		case FPM_PCTL_ACTION_LAST_CHILD_EXITED :
+
+			fpm_pctl_action_last();
+
+			break;
+
+	}
+}
+
+int fpm_pctl_can_spawn_children()
+{
+	return fpm_state == FPM_PCTL_STATE_NORMAL;
+}
+
+int fpm_pctl_child_exited()
+{
+	if (fpm_state == FPM_PCTL_STATE_NORMAL) { return 0; }
+
+	if (!fpm_globals.running_children) {
+		fpm_pctl(FPM_PCTL_STATE_UNSPECIFIED, FPM_PCTL_ACTION_LAST_CHILD_EXITED);
+	}
+
+	return 0;
+}
+
+int fpm_pctl_init_main()
+{
+	int i;
+
+	saved_argc = fpm_globals.argc;
+
+	saved_argv = malloc(sizeof(char *) * (saved_argc + 1));
+
+	if (!saved_argv) {
+		return -1;
+	}
+
+	for (i = 0; i < saved_argc; i++) {
+		saved_argv[i] = strdup(fpm_globals.argv[i]);
+
+		if (!saved_argv[i]) {
+			return -1;
+		}
+	}
+
+	saved_argv[i] = 0;
+
+	if (0 > fpm_cleanup_add(FPM_CLEANUP_ALL, fpm_pctl_cleanup, 0)) {
+		return -1;
+	}
+
+	return 0;
+}
+
+static void fpm_pctl_check_request_timeout(struct timeval *now)
+{
+	struct fpm_worker_pool_s *wp;
+
+	for (wp = fpm_worker_all_pools; wp; wp = wp->next) {
+		int terminate_timeout = wp->config->request_terminate_timeout;
+		int slowlog_timeout = wp->config->request_slowlog_timeout;
+		struct fpm_child_s *child;
+
+		if (terminate_timeout || slowlog_timeout) {
+			for (child = wp->children; child; child = child->next) {
+				fpm_request_check_timed_out(child, now, terminate_timeout, slowlog_timeout);
+			}
+		}
+	}
+	
+}
+
+void fpm_pctl_heartbeat(int fd, short which, void *arg)
+{
+	static struct event heartbeat;
+	struct timeval tv = { .tv_sec = 0, .tv_usec = 130000 };
+	struct timeval now;
+
+	if (which == EV_TIMEOUT) {
+		evtimer_del(&heartbeat);
+		fpm_clock_get(&now);
+		fpm_pctl_check_request_timeout(&now);
+	}
+
+	evtimer_set(&heartbeat, &fpm_pctl_heartbeat, 0);
+
+	evtimer_add(&heartbeat, &tv);
+}
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_process_ctl.h php-src/sapi/fpm/fpm/fpm_process_ctl.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_process_ctl.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_process_ctl.h	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,39 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_PROCESS_CTL_H
+#define FPM_PROCESS_CTL_H 1
+
+struct fpm_child_s;
+
+void fpm_pctl(int new_state, int action);
+int fpm_pctl_can_spawn_children();
+int fpm_pctl_kill(pid_t pid, int how);
+void fpm_pctl_heartbeat(int fd, short which, void *arg);
+int fpm_pctl_child_exited();
+int fpm_pctl_init_main();
+
+
+enum {
+	FPM_PCTL_STATE_UNSPECIFIED,
+	FPM_PCTL_STATE_NORMAL,
+	FPM_PCTL_STATE_RELOADING,
+	FPM_PCTL_STATE_TERMINATING,
+	FPM_PCTL_STATE_FINISHING
+};
+
+enum {
+	FPM_PCTL_ACTION_SET,
+	FPM_PCTL_ACTION_TIMEOUT,
+	FPM_PCTL_ACTION_LAST_CHILD_EXITED
+};
+
+enum {
+	FPM_PCTL_TERM,
+	FPM_PCTL_STOP,
+	FPM_PCTL_CONT
+};
+
+#endif
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_request.c php-src/sapi/fpm/fpm/fpm_request.c
--- php-src-vanilla/sapi/fpm/fpm/fpm_request.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_request.c	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,164 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#include "fpm_php.h"
+#include "fpm_str.h"
+#include "fpm_clock.h"
+#include "fpm_conf.h"
+#include "fpm_trace.h"
+#include "fpm_php_trace.h"
+#include "fpm_process_ctl.h"
+#include "fpm_children.h"
+#include "fpm_shm_slots.h"
+#include "fpm_request.h"
+
+#include "zlog.h"
+
+void fpm_request_accepting()
+{
+	struct fpm_shm_slot_s *slot;
+
+	slot = fpm_shm_slots_acquire(0, 0);
+
+	slot->request_stage = FPM_REQUEST_ACCEPTING;
+
+	fpm_clock_get(&slot->tv);
+	memset(slot->request_method, 0, sizeof(slot->request_method));
+	slot->content_length = 0;
+	memset(slot->script_filename, 0, sizeof(slot->script_filename));
+
+	fpm_shm_slots_release(slot);
+}
+
+void fpm_request_reading_headers()
+{
+	struct fpm_shm_slot_s *slot;
+
+	slot = fpm_shm_slots_acquire(0, 0);
+
+	slot->request_stage = FPM_REQUEST_READING_HEADERS;
+
+	fpm_clock_get(&slot->tv);
+	slot->accepted = slot->tv;
+
+	fpm_shm_slots_release(slot);
+}
+
+void fpm_request_info()
+{
+	TSRMLS_FETCH();
+	struct fpm_shm_slot_s *slot;
+	char *request_method = fpm_php_request_method(TSRMLS_C);
+	char *script_filename = fpm_php_script_filename(TSRMLS_C);
+
+	slot = fpm_shm_slots_acquire(0, 0);
+
+	slot->request_stage = FPM_REQUEST_INFO;
+
+	fpm_clock_get(&slot->tv);
+
+	if (request_method) {
+		cpystrn(slot->request_method, request_method, sizeof(slot->request_method));
+	}
+
+	slot->content_length = fpm_php_content_length(TSRMLS_C);
+
+	/* if cgi.fix_pathinfo is set to "1" and script cannot be found (404)
+		the sapi_globals.request_info.path_translated is set to NULL */
+	if (script_filename) {
+		cpystrn(slot->script_filename, script_filename, sizeof(slot->script_filename));
+	}
+
+	fpm_shm_slots_release(slot);
+}
+
+void fpm_request_executing()
+{
+	struct fpm_shm_slot_s *slot;
+
+	slot = fpm_shm_slots_acquire(0, 0);
+
+	slot->request_stage = FPM_REQUEST_EXECUTING;
+
+	fpm_clock_get(&slot->tv);
+
+	fpm_shm_slots_release(slot);
+}
+
+void fpm_request_finished()
+{
+	struct fpm_shm_slot_s *slot;
+
+	slot = fpm_shm_slots_acquire(0, 0);
+
+	slot->request_stage = FPM_REQUEST_FINISHED;
+
+	fpm_clock_get(&slot->tv);
+	memset(&slot->accepted, 0, sizeof(slot->accepted));
+
+	fpm_shm_slots_release(slot);
+}
+
+void fpm_request_check_timed_out(struct fpm_child_s *child, struct timeval *now, int terminate_timeout, int slowlog_timeout)
+{
+	struct fpm_shm_slot_s *slot;
+	struct fpm_shm_slot_s slot_c;
+
+	slot = fpm_shm_slot(child);
+
+	if (!fpm_shm_slots_acquire(slot, 1)) {
+		return;
+	}
+
+	slot_c = *slot;
+
+	fpm_shm_slots_release(slot);
+
+#if HAVE_FPM_TRACE
+	if (child->slow_logged.tv_sec) {
+		if (child->slow_logged.tv_sec != slot_c.accepted.tv_sec || child->slow_logged.tv_usec != slot_c.accepted.tv_usec) {
+			child->slow_logged.tv_sec = 0;
+			child->slow_logged.tv_usec = 0;
+		}
+	}
+#endif
+
+	if (slot_c.request_stage > FPM_REQUEST_ACCEPTING && slot_c.request_stage < FPM_REQUEST_FINISHED) {
+		char purified_script_filename[sizeof(slot_c.script_filename)];
+		struct timeval tv;
+
+		timersub(now, &slot_c.accepted, &tv);
+
+#if HAVE_FPM_TRACE
+		if (child->slow_logged.tv_sec == 0 && slowlog_timeout &&
+				slot_c.request_stage == FPM_REQUEST_EXECUTING && tv.tv_sec >= slowlog_timeout) {
+			
+			str_purify_filename(purified_script_filename, slot_c.script_filename, sizeof(slot_c.script_filename));
+
+			child->slow_logged = slot_c.accepted;
+			child->tracer = fpm_php_trace;
+
+			fpm_trace_signal(child->pid);
+
+			zlog(ZLOG_STUFF, ZLOG_WARNING, "child %d, script '%s' (pool %s) executing too slow (%d.%06d sec), logging",
+				(int) child->pid, purified_script_filename, child->wp->config->name, (int) tv.tv_sec, (int) tv.tv_usec);
+		}
+
+		else
+#endif
+		if (terminate_timeout && tv.tv_sec >= terminate_timeout) {
+
+			str_purify_filename(purified_script_filename, slot_c.script_filename, sizeof(slot_c.script_filename));
+
+			fpm_pctl_kill(child->pid, FPM_PCTL_TERM);
+
+			zlog(ZLOG_STUFF, ZLOG_WARNING, "child %d, script '%s' (pool %s) execution timed out (%d.%06d sec), terminating",
+				(int) child->pid, purified_script_filename, child->wp->config->name, (int) tv.tv_sec, (int) tv.tv_usec);
+		}
+	}
+
+}
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_request.h php-src/sapi/fpm/fpm/fpm_request.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_request.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_request.h	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,27 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_REQUEST_H
+#define FPM_REQUEST_H 1
+
+void fpm_request_accepting();				/* hanging in accept() */
+void fpm_request_reading_headers();			/* start reading fastcgi request from very first byte */
+void fpm_request_info();					/* not a stage really but a point in the php code, where all request params have become known to sapi */
+void fpm_request_executing();				/* the script is executing */
+void fpm_request_finished();				/* request processed: script response have been sent to web server */
+
+struct fpm_child_s;
+struct timeval;
+
+void fpm_request_check_timed_out(struct fpm_child_s *child, struct timeval *tv, int terminate_timeout, int slowlog_timeout);
+
+enum fpm_request_stage_e {
+	FPM_REQUEST_ACCEPTING = 1,
+	FPM_REQUEST_READING_HEADERS,
+	FPM_REQUEST_INFO,
+	FPM_REQUEST_EXECUTING,
+	FPM_REQUEST_FINISHED
+};
+
+#endif
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_shm.c php-src/sapi/fpm/fpm/fpm_shm.c
--- php-src-vanilla/sapi/fpm/fpm/fpm_shm.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_shm.c	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,100 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#include <unistd.h>
+#include <sys/mman.h>
+#include <stdlib.h>
+
+#include "fpm_shm.h"
+#include "zlog.h"
+
+
+/* MAP_ANON is depricated, but not in macosx */
+#if defined(MAP_ANON) && !defined(MAP_ANONYMOUS)
+#define MAP_ANONYMOUS MAP_ANON
+#endif
+
+
+struct fpm_shm_s *fpm_shm_alloc(size_t sz)
+{
+	struct fpm_shm_s *shm;
+
+	shm = malloc(sizeof(*shm));
+
+	if (!shm) {
+		return 0;
+	}
+
+	shm->mem = mmap(0, sz, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, -1, 0);
+
+	if (!shm->mem) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "mmap(MAP_ANONYMOUS | MAP_SHARED) failed");
+		free(shm);
+		return 0;
+	}
+
+	shm->used = 0;
+	shm->sz = sz;
+
+	return shm;
+}
+
+static void fpm_shm_free(struct fpm_shm_s *shm, int do_unmap)
+{
+	if (do_unmap) {
+		munmap(shm->mem, shm->sz);
+	}
+
+	free(shm);	
+}
+
+void fpm_shm_free_list(struct fpm_shm_s *shm, void *mem)
+{
+	struct fpm_shm_s *next;
+
+	for (; shm; shm = next) {
+		next = shm->next;
+
+		fpm_shm_free(shm, mem != shm->mem);
+	}
+}
+
+void *fpm_shm_alloc_chunk(struct fpm_shm_s **head, size_t sz, void **mem)
+{
+	size_t pagesize = getpagesize();
+	static const size_t cache_line_size = 16;
+	size_t aligned_sz;
+	struct fpm_shm_s *shm;
+	void *ret;
+
+	sz = (sz + cache_line_size - 1) & -cache_line_size;
+
+	shm = *head;
+
+	if (0 == shm || shm->sz - shm->used < sz) {
+		/* allocate one more shm segment */
+
+		aligned_sz = (sz + pagesize - 1) & -pagesize;
+
+		shm = fpm_shm_alloc(aligned_sz);
+
+		if (!shm) {
+			return 0;
+		}
+
+		shm->next = *head;
+		if (shm->next) { shm->next->prev = shm; }
+		shm->prev = 0;
+		*head = shm;
+	}
+
+	*mem = shm->mem;
+	ret = (char *) shm->mem + shm->used;
+	shm->used += sz;
+
+	return ret;
+}
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_shm.h php-src/sapi/fpm/fpm/fpm_shm.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_shm.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_shm.h	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,22 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_SHM_H
+#define FPM_SHM_H 1
+
+struct fpm_shm_s;
+
+struct fpm_shm_s {
+	struct fpm_shm_s *prev, *next;
+	void *mem;
+	size_t sz;
+	size_t used;
+};
+
+struct fpm_shm_s *fpm_shm_alloc(size_t sz);
+void fpm_shm_free_list(struct fpm_shm_s *, void *);
+void *fpm_shm_alloc_chunk(struct fpm_shm_s **head, size_t sz, void **mem);
+
+#endif
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_shm_slots.c php-src/sapi/fpm/fpm/fpm_shm_slots.c
--- php-src-vanilla/sapi/fpm/fpm/fpm_shm_slots.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_shm_slots.c	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,127 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#include "fpm_atomic.h"
+#include "fpm_worker_pool.h"
+#include "fpm_children.h"
+#include "fpm_shm.h"
+#include "fpm_shm_slots.h"
+#include "zlog.h"
+
+static void *shm_mem;
+static struct fpm_shm_slot_s *shm_slot;
+
+int fpm_shm_slots_prepare_slot(struct fpm_child_s *child)
+{
+	struct fpm_worker_pool_s *wp = child->wp;
+	struct fpm_shm_slot_ptr_s *shm_slot_ptr;
+
+	child->shm_slot_i = wp->slots_used.used;
+
+	shm_slot_ptr = fpm_array_push(&wp->slots_used);
+
+	if (0 == shm_slot_ptr) {
+		return -1;
+	}
+
+	if (0 == wp->slots_free.used) {
+		shm_slot_ptr->shm_slot = fpm_shm_alloc_chunk(&wp->shm_list, sizeof(struct fpm_shm_slot_s), &shm_slot_ptr->mem);
+
+		if (!shm_slot_ptr->shm_slot) {
+			return -1;
+		}
+	}
+	else {
+		*shm_slot_ptr = *(struct fpm_shm_slot_ptr_s *) fpm_array_item_last(&wp->slots_free);
+
+		--wp->slots_free.used;
+	}
+
+	memset(shm_slot_ptr->shm_slot, 0, sizeof(struct fpm_shm_slot_s));
+
+	shm_slot_ptr->child = child;
+
+	return 0;
+}
+
+void fpm_shm_slots_discard_slot(struct fpm_child_s *child)
+{
+	struct fpm_shm_slot_ptr_s *shm_slot_ptr;
+	struct fpm_worker_pool_s *wp = child->wp;
+	int n;
+
+	shm_slot_ptr = fpm_array_push(&wp->slots_free);
+
+	if (shm_slot_ptr) {
+
+		struct fpm_shm_slot_ptr_s *shm_slot_ptr_used;
+
+		shm_slot_ptr_used = fpm_array_item(&wp->slots_used, child->shm_slot_i);
+
+		*shm_slot_ptr = *shm_slot_ptr_used;
+
+		shm_slot_ptr->child = 0;
+
+	}
+
+	n = fpm_array_item_remove(&wp->slots_used, child->shm_slot_i);
+
+	if (n > -1) {
+		shm_slot_ptr = fpm_array_item(&wp->slots_used, n);
+
+		shm_slot_ptr->child->shm_slot_i = n;
+	}
+}
+
+void fpm_shm_slots_child_use_slot(struct fpm_child_s *child)
+{
+	struct fpm_shm_slot_ptr_s *shm_slot_ptr;
+	struct fpm_worker_pool_s *wp = child->wp;
+
+	shm_slot_ptr = fpm_array_item(&wp->slots_used, child->shm_slot_i);
+
+	shm_slot = shm_slot_ptr->shm_slot;
+	shm_mem = shm_slot_ptr->mem;
+}
+
+void fpm_shm_slots_parent_use_slot(struct fpm_child_s *child)
+{
+	/* nothing to do */
+}
+
+void *fpm_shm_slots_mem()
+{
+	return shm_mem;
+}
+
+struct fpm_shm_slot_s *fpm_shm_slot(struct fpm_child_s *child)
+{
+	struct fpm_shm_slot_ptr_s *shm_slot_ptr;
+	struct fpm_worker_pool_s *wp = child->wp;
+
+	shm_slot_ptr = fpm_array_item(&wp->slots_used, child->shm_slot_i);
+
+	return shm_slot_ptr->shm_slot;
+}
+
+struct fpm_shm_slot_s *fpm_shm_slots_acquire(struct fpm_shm_slot_s *s, int nohang)
+{
+	if (s == 0) {
+		s = shm_slot;
+	}
+
+	if (0 > fpm_spinlock(&s->lock, nohang)) {
+		return 0;
+	}
+
+	return s;
+}
+
+void fpm_shm_slots_release(struct fpm_shm_slot_s *s)
+{
+	s->lock = 0;
+}
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_shm_slots.h php-src/sapi/fpm/fpm/fpm_shm_slots.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_shm_slots.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_shm_slots.h	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,43 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_SHM_SLOTS_H
+#define FPM_SHM_SLOTS_H 1
+
+#include "fpm_atomic.h"
+#include "fpm_worker_pool.h"
+#include "fpm_request.h"
+
+struct fpm_child_s;
+
+struct fpm_shm_slot_s {
+	union {
+		atomic_t lock;
+		char dummy[16];
+	};
+	enum fpm_request_stage_e request_stage;
+	struct timeval accepted;
+	struct timeval tv;
+	char request_method[16];
+	size_t content_length; /* used with POST only */
+	char script_filename[256];
+};
+
+struct fpm_shm_slot_ptr_s {
+	void *mem;
+	struct fpm_shm_slot_s *shm_slot;
+	struct fpm_child_s *child;
+};
+
+int fpm_shm_slots_prepare_slot(struct fpm_child_s *child);
+void fpm_shm_slots_discard_slot(struct fpm_child_s *child);
+void fpm_shm_slots_child_use_slot(struct fpm_child_s *child);
+void fpm_shm_slots_parent_use_slot(struct fpm_child_s *child);
+void *fpm_shm_slots_mem();
+struct fpm_shm_slot_s *fpm_shm_slot(struct fpm_child_s *child);
+struct fpm_shm_slot_s *fpm_shm_slots_acquire(struct fpm_shm_slot_s *, int nohang);
+void fpm_shm_slots_release(struct fpm_shm_slot_s *);
+
+#endif
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_signals.c php-src/sapi/fpm/fpm/fpm_signals.c
--- php-src-vanilla/sapi/fpm/fpm/fpm_signals.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_signals.c	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,252 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#include <signal.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include "fpm.h"
+#include "fpm_signals.h"
+#include "fpm_sockets.h"
+#include "fpm_php.h"
+#include "zlog.h"
+
+static int sp[2];
+
+const char *fpm_signal_names[NSIG + 1] = {
+#ifdef SIGHUP
+	[SIGHUP] 		= "SIGHUP",
+#endif
+#ifdef SIGINT
+	[SIGINT] 		= "SIGINT",
+#endif
+#ifdef SIGQUIT
+	[SIGQUIT] 		= "SIGQUIT",
+#endif
+#ifdef SIGILL
+	[SIGILL] 		= "SIGILL",
+#endif
+#ifdef SIGTRAP
+	[SIGTRAP] 		= "SIGTRAP",
+#endif
+#ifdef SIGABRT
+	[SIGABRT] 		= "SIGABRT",
+#endif
+#ifdef SIGEMT
+	[SIGEMT] 		= "SIGEMT",
+#endif
+#ifdef SIGBUS
+	[SIGBUS] 		= "SIGBUS",
+#endif
+#ifdef SIGFPE
+	[SIGFPE] 		= "SIGFPE",
+#endif
+#ifdef SIGKILL
+	[SIGKILL] 		= "SIGKILL",
+#endif
+#ifdef SIGUSR1
+	[SIGUSR1] 		= "SIGUSR1",
+#endif
+#ifdef SIGSEGV
+	[SIGSEGV] 		= "SIGSEGV",
+#endif
+#ifdef SIGUSR2
+	[SIGUSR2] 		= "SIGUSR2",
+#endif
+#ifdef SIGPIPE
+	[SIGPIPE] 		= "SIGPIPE",
+#endif
+#ifdef SIGALRM
+	[SIGALRM] 		= "SIGALRM",
+#endif
+#ifdef SIGTERM
+	[SIGTERM] 		= "SIGTERM",
+#endif
+#ifdef SIGCHLD
+	[SIGCHLD] 		= "SIGCHLD",
+#endif
+#ifdef SIGCONT
+	[SIGCONT] 		= "SIGCONT",
+#endif
+#ifdef SIGSTOP
+	[SIGSTOP] 		= "SIGSTOP",
+#endif
+#ifdef SIGTSTP
+	[SIGTSTP] 		= "SIGTSTP",
+#endif
+#ifdef SIGTTIN
+	[SIGTTIN] 		= "SIGTTIN",
+#endif
+#ifdef SIGTTOU
+	[SIGTTOU] 		= "SIGTTOU",
+#endif
+#ifdef SIGURG
+	[SIGURG] 		= "SIGURG",
+#endif
+#ifdef SIGXCPU
+	[SIGXCPU] 		= "SIGXCPU",
+#endif
+#ifdef SIGXFSZ
+	[SIGXFSZ] 		= "SIGXFSZ",
+#endif
+#ifdef SIGVTALRM
+	[SIGVTALRM] 	= "SIGVTALRM",
+#endif
+#ifdef SIGPROF
+	[SIGPROF] 		= "SIGPROF",
+#endif
+#ifdef SIGWINCH
+	[SIGWINCH] 		= "SIGWINCH",
+#endif
+#ifdef SIGINFO
+	[SIGINFO] 		= "SIGINFO",
+#endif
+#ifdef SIGIO
+	[SIGIO] 		= "SIGIO",
+#endif
+#ifdef SIGPWR
+	[SIGPWR] 		= "SIGPWR",
+#endif
+#ifdef SIGSYS
+	[SIGSYS] 		= "SIGSYS",
+#endif
+#ifdef SIGWAITING
+	[SIGWAITING] 	= "SIGWAITING",
+#endif
+#ifdef SIGLWP
+	[SIGLWP] 		= "SIGLWP",
+#endif
+#ifdef SIGFREEZE
+	[SIGFREEZE] 	= "SIGFREEZE",
+#endif
+#ifdef SIGTHAW
+	[SIGTHAW] 		= "SIGTHAW",
+#endif
+#ifdef SIGCANCEL
+	[SIGCANCEL] 	= "SIGCANCEL",
+#endif
+#ifdef SIGLOST
+	[SIGLOST] 		= "SIGLOST",
+#endif
+};
+
+static void sig_soft_quit(int signo)
+{
+	int saved_errno = errno;
+
+	/* closing fastcgi listening socket will force fcgi_accept() exit immediately */
+	close(0);
+	socket(AF_UNIX, SOCK_STREAM, 0);
+
+	fpm_php_soft_quit();
+
+	errno = saved_errno;
+}
+
+static void sig_handler(int signo)
+{
+	static const char sig_chars[NSIG + 1] = {
+		[SIGTERM] = 'T',
+		[SIGINT]  = 'I',
+		[SIGUSR1] = '1',
+		[SIGUSR2] = '2',
+		[SIGQUIT] = 'Q',
+		[SIGCHLD] = 'C'
+	};
+	char s;
+	int saved_errno;
+
+	if (fpm_globals.parent_pid != getpid()) {
+		/* prevent a signal race condition when child process
+			have not set up it's own signal handler yet */
+		return;
+	}
+
+	saved_errno = errno;
+
+	s = sig_chars[signo];
+
+	write(sp[1], &s, sizeof(s));
+
+	errno = saved_errno;
+}
+
+int fpm_signals_init_main()
+{
+	struct sigaction act;
+
+	if (0 > socketpair(AF_UNIX, SOCK_STREAM, 0, sp)) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "socketpair() failed");
+		return -1;
+	}
+
+	if (0 > fd_set_blocked(sp[0], 0) || 0 > fd_set_blocked(sp[1], 0)) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "fd_set_blocked() failed");
+		return -1;
+	}
+
+	if (0 > fcntl(sp[0], F_SETFD, FD_CLOEXEC) || 0 > fcntl(sp[1], F_SETFD, FD_CLOEXEC)) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "fcntl(F_SETFD, FD_CLOEXEC) failed");
+		return -1;
+	}
+
+	memset(&act, 0, sizeof(act));
+	act.sa_handler = sig_handler;
+	sigfillset(&act.sa_mask);
+
+	if (0 > sigaction(SIGTERM,  &act, 0) ||
+		0 > sigaction(SIGINT,   &act, 0) ||
+		0 > sigaction(SIGUSR1,  &act, 0) ||
+		0 > sigaction(SIGUSR2,  &act, 0) ||
+		0 > sigaction(SIGCHLD,  &act, 0) ||
+		0 > sigaction(SIGQUIT,  &act, 0)) {
+
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "sigaction() failed");
+		return -1;
+	}
+
+	return 0;
+}
+
+int fpm_signals_init_child()
+{
+	struct sigaction act, act_dfl;
+
+	memset(&act, 0, sizeof(act));
+	memset(&act_dfl, 0, sizeof(act_dfl));
+
+	act.sa_handler = &sig_soft_quit;
+	act.sa_flags |= SA_RESTART;
+
+	act_dfl.sa_handler = SIG_DFL;
+
+	close(sp[0]);
+	close(sp[1]);
+
+	if (0 > sigaction(SIGTERM,  &act_dfl,  0) ||
+		0 > sigaction(SIGINT,   &act_dfl,  0) ||
+		0 > sigaction(SIGUSR1,  &act_dfl,  0) ||
+		0 > sigaction(SIGUSR2,  &act_dfl,  0) ||
+		0 > sigaction(SIGCHLD,  &act_dfl,  0) ||
+		0 > sigaction(SIGQUIT,  &act,      0)) {
+
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "sigaction() failed");
+		return -1;
+	}
+
+	return 0;
+}
+
+int fpm_signals_get_fd()
+{
+	return sp[0];
+}
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_signals.h php-src/sapi/fpm/fpm/fpm_signals.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_signals.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_signals.h	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,16 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_SIGNALS_H
+#define FPM_SIGNALS_H 1
+
+#include <signal.h>
+
+int fpm_signals_init_main();
+int fpm_signals_init_child();
+int fpm_signals_get_fd();
+
+extern const char *fpm_signal_names[NSIG + 1];
+
+#endif
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_sockets.c php-src/sapi/fpm/fpm/fpm_sockets.c
--- php-src-vanilla/sapi/fpm/fpm/fpm_sockets.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_sockets.c	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,427 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#ifdef HAVE_ALLOCA_H
+#include <alloca.h>
+#endif
+#include <sys/types.h>
+#include <sys/stat.h> /* for chmod(2) */
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/un.h>
+#include <netdb.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include "zlog.h"
+#include "fpm_arrays.h"
+#include "fpm_sockets.h"
+#include "fpm_worker_pool.h"
+#include "fpm_unix.h"
+#include "fpm_str.h"
+#include "fpm_env.h"
+#include "fpm_cleanup.h"
+
+struct listening_socket_s {
+	int refcount;
+	int sock;
+	int type;
+	char *key;
+};
+
+static struct fpm_array_s sockets_list;
+
+static int fpm_sockets_resolve_af_inet(char *node, char *service, struct sockaddr_in *addr)
+{
+	struct addrinfo *res;
+	struct addrinfo hints;
+	int ret;
+
+	memset(&hints, 0, sizeof(hints));
+
+	hints.ai_family = AF_INET;
+
+	ret = getaddrinfo(node, service, &hints, &res);
+
+	if (ret != 0) {
+		zlog(ZLOG_STUFF, ZLOG_ERROR, "can't resolve hostname '%s%s%s': getaddrinfo said: %s%s%s\n",
+					node, service ? ":" : "", service ? service : "",
+					gai_strerror(ret), ret == EAI_SYSTEM ? ", system error: " : "", ret == EAI_SYSTEM ? strerror(errno) : "");
+		return -1;
+	}
+
+	*addr = *(struct sockaddr_in *) res->ai_addr;
+
+	freeaddrinfo(res);
+
+	return 0;
+}
+
+enum { FPM_GET_USE_SOCKET = 1, FPM_STORE_SOCKET = 2, FPM_STORE_USE_SOCKET = 3 };
+
+static void fpm_sockets_cleanup(int which, void *arg)
+{
+	int i;
+	char *env_value = 0;
+	int p = 0;
+	struct listening_socket_s *ls = sockets_list.data;
+
+	for (i = 0; i < sockets_list.used; i++, ls++) {
+
+		if (which != FPM_CLEANUP_PARENT_EXEC) {
+
+			close(ls->sock);
+
+		}
+		else { /* on PARENT EXEC we want socket fds to be inherited through environment variable */
+			char fd[32];
+			sprintf(fd, "%d", ls->sock);
+			env_value = realloc(env_value, p + (p ? 1 : 0) + strlen(ls->key) + 1 + strlen(fd) + 1);
+			p += sprintf(env_value + p, "%s%s=%s", p ? "," : "", ls->key, fd);
+		}
+
+		if (which == FPM_CLEANUP_PARENT_EXIT_MAIN) {
+
+			if (ls->type == FPM_AF_UNIX) {
+				unlink(ls->key);
+			}
+
+		}
+
+		free(ls->key);
+	}
+
+	if (env_value) {
+		setenv("FPM_SOCKETS", env_value, 1);
+		free(env_value);
+	}
+
+	fpm_array_free(&sockets_list);
+}
+
+static int fpm_sockets_hash_op(int sock, struct sockaddr *sa, char *key, int type, int op)
+{
+
+	if (key == NULL) {
+
+		switch (type) {
+
+			case FPM_AF_INET : {
+				struct sockaddr_in *sa_in = (struct sockaddr_in *) sa;
+
+				key = alloca(sizeof("xxx.xxx.xxx.xxx:ppppp"));
+
+				sprintf(key, "%u.%u.%u.%u:%u", IPQUAD(&sa_in->sin_addr), (unsigned int) ntohs(sa_in->sin_port));
+
+				break;
+			}
+
+			case FPM_AF_UNIX : {
+				struct sockaddr_un *sa_un = (struct sockaddr_un *) sa;
+
+				key = alloca(strlen(sa_un->sun_path) + 1);
+
+				strcpy(key, sa_un->sun_path);
+
+				break;
+			}
+
+			default :
+
+				return -1;
+		}
+
+	}
+
+	switch (op) {
+
+		case FPM_GET_USE_SOCKET :
+		{
+
+			int i;
+			struct listening_socket_s *ls = sockets_list.data;
+
+			for (i = 0; i < sockets_list.used; i++, ls++) {
+
+				if (!strcmp(ls->key, key)) {
+					++ls->refcount;
+					return ls->sock;
+				}
+			}
+
+			break;
+		}
+
+		case FPM_STORE_SOCKET :			/* inherited socket */
+		case FPM_STORE_USE_SOCKET :		/* just created */
+		{
+
+			struct listening_socket_s *ls;
+
+			ls = fpm_array_push(&sockets_list);
+
+			if (!ls) {
+				break;
+			}
+
+			if (op == FPM_STORE_SOCKET) {
+				ls->refcount = 0;
+			}
+			else {
+				ls->refcount = 1;
+			}
+			ls->type = type;
+			ls->sock = sock;
+			ls->key = strdup(key);
+
+			return 0;
+
+		}
+	}
+
+	return -1;
+
+}
+
+static int fpm_sockets_new_listening_socket(struct fpm_worker_pool_s *wp, struct sockaddr *sa, int socklen)
+{
+	int backlog = -1;
+	int flags = 1;
+	int sock;
+	mode_t saved_umask;
+
+	/* we have custom backlog value */
+	if (wp->config->listen_options) {
+		backlog = wp->config->listen_options->backlog;
+	}
+
+	sock = socket(sa->sa_family, SOCK_STREAM, 0);
+
+	if (0 > sock) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "socket() failed");
+		return -1;
+	}
+
+	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &flags, sizeof(flags));
+
+	if (wp->listen_address_domain == FPM_AF_UNIX) {
+		unlink( ((struct sockaddr_un *) sa)->sun_path);
+	}
+
+	saved_umask = umask(0777 ^ wp->socket_mode);
+
+	if (0 > bind(sock, sa, socklen)) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "bind() for address '%s' failed", wp->config->listen_address);
+		return -1;
+	}
+
+	if (wp->listen_address_domain == FPM_AF_UNIX) {
+
+		char *path = ((struct sockaddr_un *) sa)->sun_path;
+
+		if (wp->socket_uid != -1 || wp->socket_gid != -1) {
+
+			if (0 > chown(path, wp->socket_uid, wp->socket_gid)) {
+				zlog(ZLOG_STUFF, ZLOG_SYSERROR, "chown() for address '%s' failed", wp->config->listen_address);
+				return -1;
+			}
+
+		}
+
+	}
+
+	umask(saved_umask);
+
+	if (0 > listen(sock, backlog)) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "listen() for address '%s' failed", wp->config->listen_address);
+		return -1;
+	}
+
+	return sock;
+}
+
+static int fpm_sockets_get_listening_socket(struct fpm_worker_pool_s *wp, struct sockaddr *sa, int socklen)
+{
+	int sock;
+
+	sock = fpm_sockets_hash_op(0, sa, 0, wp->listen_address_domain, FPM_GET_USE_SOCKET);
+
+	if (sock >= 0) { return sock; }
+
+	sock = fpm_sockets_new_listening_socket(wp, sa, socklen);
+
+	fpm_sockets_hash_op(sock, sa, 0, wp->listen_address_domain, FPM_STORE_USE_SOCKET);
+
+	return sock;
+}
+
+enum fpm_address_domain fpm_sockets_domain_from_address(char *address)
+{
+	if (strchr(address, ':')) { return FPM_AF_INET; }
+
+	if (strlen(address) == strspn(address, "0123456789")) { return FPM_AF_INET; }
+
+	return FPM_AF_UNIX;
+}
+
+static int fpm_socket_af_inet_listening_socket(struct fpm_worker_pool_s *wp)
+{
+	struct sockaddr_in sa_in;
+	char *dup_address = strdup(wp->config->listen_address);
+	char *port_str = strchr(dup_address, ':');
+	char *addr = NULL;
+	int port = 0;
+
+	if (port_str) { /* this is host:port pair */
+		*port_str++ = '\0';
+		port = atoi(port_str);
+		addr = dup_address;
+	}
+	else if (strlen(dup_address) == strspn(dup_address, "0123456789")) { /* this is port */
+		port = atoi(dup_address);
+		port_str = dup_address;
+	}
+
+	if (port == 0) {
+		zlog(ZLOG_STUFF, ZLOG_ERROR, "invalid port value '%s'", port_str);
+		return -1;
+	}
+
+	memset(&sa_in, 0, sizeof(sa_in));
+
+	if (addr) {
+
+		sa_in.sin_addr.s_addr = inet_addr(addr);
+
+		if (sa_in.sin_addr.s_addr == INADDR_NONE) { /* do resolve */
+			if (0 > fpm_sockets_resolve_af_inet(addr, NULL, &sa_in)) {
+				return -1;
+			}
+			zlog(ZLOG_STUFF, ZLOG_NOTICE, "address '%s' resolved as %u.%u.%u.%u", addr, IPQUAD(&sa_in.sin_addr));
+		}
+	}
+	else {
+
+		sa_in.sin_addr.s_addr = htonl(INADDR_ANY);
+
+	}
+
+	sa_in.sin_family = AF_INET;
+	sa_in.sin_port = htons(port);
+
+	free(dup_address);
+
+	return fpm_sockets_get_listening_socket(wp, (struct sockaddr *) &sa_in, sizeof(struct sockaddr_in));
+}
+
+static int fpm_socket_af_unix_listening_socket(struct fpm_worker_pool_s *wp)
+{
+	struct sockaddr_un sa_un;
+
+	memset(&sa_un, 0, sizeof(sa_un));
+
+	cpystrn(sa_un.sun_path, wp->config->listen_address, sizeof(sa_un.sun_path));
+	sa_un.sun_family = AF_UNIX;
+
+	return fpm_sockets_get_listening_socket(wp, (struct sockaddr *) &sa_un, sizeof(struct sockaddr_un));
+}
+
+int fpm_sockets_init_main()
+{
+	int i;
+	struct fpm_worker_pool_s *wp;
+	char *inherited = getenv("FPM_SOCKETS");
+	struct listening_socket_s *ls;
+
+	if (0 == fpm_array_init(&sockets_list, sizeof(struct listening_socket_s), 10)) {
+		return -1;
+	}
+
+	/* import inherited sockets */
+	while (inherited && *inherited) {
+		char *comma = strchr(inherited, ',');
+		int type, fd_no;
+		char *eq;
+
+		if (comma) { *comma = '\0'; }
+
+		eq = strchr(inherited, '=');
+
+		if (eq) {
+			*eq = '\0';
+
+			fd_no = atoi(eq + 1);
+
+			type = fpm_sockets_domain_from_address(inherited);
+
+			zlog(ZLOG_STUFF, ZLOG_NOTICE, "using inherited socket fd=%d, \"%s\"", fd_no, inherited);
+
+			fpm_sockets_hash_op(fd_no, 0, inherited, type, FPM_STORE_SOCKET);
+		}
+
+		if (comma) { inherited = comma + 1; }
+		else { inherited = 0; }
+	}
+
+	/* create all required sockets */
+	for (wp = fpm_worker_all_pools; wp; wp = wp->next) {
+
+		if (!wp->is_template) {
+
+			switch (wp->listen_address_domain) {
+
+				case FPM_AF_INET :
+
+					wp->listening_socket = fpm_socket_af_inet_listening_socket(wp);
+					break;
+
+				case FPM_AF_UNIX :
+
+					if (0 > fpm_unix_resolve_socket_premissions(wp)) {
+						return -1;
+					}
+
+					wp->listening_socket = fpm_socket_af_unix_listening_socket(wp);
+					break;
+
+			}
+
+			if (wp->listening_socket == -1) {
+				return -1;
+			}
+		}
+
+	}
+
+	/* close unused sockets that was inherited */
+	ls = sockets_list.data;
+
+	for (i = 0; i < sockets_list.used; ) {
+
+		if (ls->refcount == 0) {
+			close(ls->sock);
+			if (ls->type == FPM_AF_UNIX) {
+				unlink(ls->key);
+			}
+			free(ls->key);
+			fpm_array_item_remove(&sockets_list, i);
+		}
+		else {
+			++i;
+			++ls;
+		}
+	}
+
+	if (0 > fpm_cleanup_add(FPM_CLEANUP_ALL, fpm_sockets_cleanup, 0)) {
+		return -1;
+	}
+
+	return 0;
+}
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_sockets.h php-src/sapi/fpm/fpm/fpm_sockets.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_sockets.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_sockets.h	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,37 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_MISC_H
+#define FPM_MISC_H 1
+
+#include <unistd.h>
+#include <fcntl.h>
+
+#include "fpm_worker_pool.h"
+
+enum fpm_address_domain fpm_sockets_domain_from_address(char *addr);
+int fpm_sockets_init_main();
+
+
+static inline int fd_set_blocked(int fd, int blocked)
+{
+	int flags = fcntl(fd, F_GETFL);
+
+	if (flags < 0) { return -1; }
+
+	if (blocked)
+		{ flags &= ~O_NONBLOCK; }
+	else
+		{ flags |= O_NONBLOCK; }
+
+	return fcntl(fd, F_SETFL, flags);
+}
+
+#define IPQUAD(sin_addr) \
+			(unsigned int) ((unsigned char *) &(sin_addr)->s_addr)[0], \
+			(unsigned int) ((unsigned char *) &(sin_addr)->s_addr)[1], \
+			(unsigned int) ((unsigned char *) &(sin_addr)->s_addr)[2], \
+			(unsigned int) ((unsigned char *) &(sin_addr)->s_addr)[3]
+
+#endif
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_stdio.c php-src/sapi/fpm/fpm/fpm_stdio.c
--- php-src-vanilla/sapi/fpm/fpm/fpm_stdio.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_stdio.c	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,286 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include "fpm.h"
+#include "fpm_children.h"
+#include "fpm_events.h"
+#include "fpm_sockets.h"
+#include "fpm_stdio.h"
+#include "zlog.h"
+
+static int fd_stdout[2];
+static int fd_stderr[2];
+
+int fpm_stdio_init_main()
+{
+	int fd = open("/dev/null", O_RDWR);
+
+	if (0 > fd) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "open(\"/dev/null\") failed");
+		return -1;
+	}
+
+	if (0 > dup2(fd, STDIN_FILENO) || 0 > dup2(fd, STDOUT_FILENO)) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "dup2() failed");
+		return -1;
+	}
+
+	close(fd);
+
+	return 0;
+}
+
+int fpm_stdio_init_final()
+{
+	if (fpm_global_config.daemonize) {
+
+		if (fpm_globals.error_log_fd != STDERR_FILENO) {
+			/* there might be messages to stderr from libevent, we need to log them all */
+			if (0 > dup2(fpm_globals.error_log_fd, STDERR_FILENO)) {
+				zlog(ZLOG_STUFF, ZLOG_SYSERROR, "dup2() failed");
+				return -1;
+			}
+		}
+
+		zlog_set_level(fpm_globals.log_level);
+
+		zlog_set_fd(fpm_globals.error_log_fd);
+	}
+
+	return 0;
+}
+
+int fpm_stdio_init_child(struct fpm_worker_pool_s *wp)
+{
+	close(fpm_globals.error_log_fd);
+	fpm_globals.error_log_fd = -1;
+	zlog_set_fd(-1);
+
+	if (wp->listening_socket != STDIN_FILENO) {
+		if (0 > dup2(wp->listening_socket, STDIN_FILENO)) {
+			zlog(ZLOG_STUFF, ZLOG_SYSERROR, "dup2() failed");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static void fpm_stdio_child_said(int fd, short which, void *arg)
+{
+	static const int max_buf_size = 1024;
+	char buf[max_buf_size];
+	struct fpm_child_s *child = arg;
+	int is_stdout = fd == child->fd_stdout;
+	struct event *ev = is_stdout ? &child->ev_stdout : &child->ev_stderr;
+	int fifo_in = 1, fifo_out = 1;
+	int is_last_message = 0;
+	int in_buf = 0;
+	int res;
+
+#if 0
+	zlog(ZLOG_STUFF, ZLOG_DEBUG, "child %d said %s", (int) child->pid, is_stdout ? "stdout" : "stderr");
+#endif
+
+	while (fifo_in || fifo_out) {
+
+		if (fifo_in) {
+
+			res = read(fd, buf + in_buf, max_buf_size - 1 - in_buf);
+
+			if (res <= 0) { /* no data */
+				fifo_in = 0;
+
+				if (res < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
+					/* just no more data ready */
+				}
+				else { /* error or pipe is closed */
+
+					if (res < 0) { /* error */
+						zlog(ZLOG_STUFF, ZLOG_SYSERROR, "read() failed");
+					}
+
+					fpm_event_del(ev);
+					is_last_message = 1;
+
+					if (is_stdout) {
+						close(child->fd_stdout);
+						child->fd_stdout = -1;
+					}
+					else {
+						close(child->fd_stderr);
+						child->fd_stderr = -1;
+					}
+
+#if 0
+					if (in_buf == 0 && !fpm_globals.is_child) {
+						zlog(ZLOG_STUFF, ZLOG_DEBUG, "child %d (pool %s) %s pipe is closed", (int) child->pid,
+							child->wp->config->name, is_stdout ? "stdout" : "stderr");
+					}
+#endif
+				}
+			}
+			else {
+				in_buf += res;
+			}
+		}
+
+		if (fifo_out) {
+			if (in_buf == 0) {
+				fifo_out = 0;
+			}
+			else {
+				char *nl;
+				int should_print = 0;
+				buf[in_buf] = '\0';
+
+				/* FIXME: there might be binary data */
+
+				/* we should print if no more space in the buffer */
+				if (in_buf == max_buf_size - 1) {
+					should_print = 1;
+				}
+
+				/* we should print if no more data to come */
+				if (!fifo_in) {
+					should_print = 1;
+				}
+
+				nl = strchr(buf, '\n');
+
+				if (nl || should_print) {
+
+					if (nl) {
+						*nl = '\0';
+					}
+
+					zlog(ZLOG_STUFF, ZLOG_WARNING, "child %d (pool %s) said into %s: \"%s\"%s", (int) child->pid,
+						child->wp->config->name, is_stdout ? "stdout" : "stderr", buf, is_last_message ? ", pipe is closed" : "");
+
+					if (nl) {
+						int out_buf = 1 + nl - buf;
+						memmove(buf, buf + out_buf, in_buf - out_buf);
+						in_buf -= out_buf;
+					}
+					else {
+						in_buf = 0;
+					}
+				}
+			}
+		}
+	}
+
+}
+
+int fpm_stdio_prepare_pipes(struct fpm_child_s *child)
+{
+	if (0 == child->wp->config->catch_workers_output) { /* not required */
+		return 0;
+	}
+
+	if (0 > pipe(fd_stdout)) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "pipe() failed");
+		return -1;
+	}
+
+	if (0 > pipe(fd_stderr)) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "pipe() failed");
+		close(fd_stdout[0]); close(fd_stdout[1]);
+		return -1;
+	}
+
+	if (0 > fd_set_blocked(fd_stdout[0], 0) || 0 > fd_set_blocked(fd_stderr[0], 0)) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "fd_set_blocked() failed");
+		close(fd_stdout[0]); close(fd_stdout[1]);
+		close(fd_stderr[0]); close(fd_stderr[1]);
+		return -1;
+	}
+
+	return 0;
+}
+
+int fpm_stdio_parent_use_pipes(struct fpm_child_s *child)
+{
+	if (0 == child->wp->config->catch_workers_output) { /* not required */
+		return 0;
+	}
+
+	close(fd_stdout[1]);
+	close(fd_stderr[1]);
+
+	child->fd_stdout = fd_stdout[0];
+	child->fd_stderr = fd_stderr[0];
+
+	fpm_event_add(child->fd_stdout, &child->ev_stdout, fpm_stdio_child_said, child);
+	fpm_event_add(child->fd_stderr, &child->ev_stderr, fpm_stdio_child_said, child);
+
+	return 0;
+}
+
+int fpm_stdio_discard_pipes(struct fpm_child_s *child)
+{
+	if (0 == child->wp->config->catch_workers_output) { /* not required */
+		return 0;
+	}
+
+	close(fd_stdout[1]);
+	close(fd_stderr[1]);
+
+	close(fd_stdout[0]);
+	close(fd_stderr[0]);
+
+	return 0;
+}
+
+void fpm_stdio_child_use_pipes(struct fpm_child_s *child)
+{
+	if (child->wp->config->catch_workers_output) {
+		dup2(fd_stdout[1], STDOUT_FILENO);
+		dup2(fd_stderr[1], STDERR_FILENO);
+		close(fd_stdout[0]); close(fd_stdout[1]);
+		close(fd_stderr[0]); close(fd_stderr[1]);
+	}
+	else {
+		/* stdout of parent is always /dev/null */
+		dup2(STDOUT_FILENO, STDERR_FILENO);
+	}
+}	
+
+int fpm_stdio_open_error_log(int reopen)
+{
+	int fd;
+
+	fd = open(fpm_global_config.error_log, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR);
+
+	if (0 > fd) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "open(\"%s\") failed", fpm_global_config.error_log);
+		return -1;
+	}
+
+	if (reopen) {
+		if (fpm_global_config.daemonize) {
+			dup2(fd, STDERR_FILENO);
+		}
+
+		dup2(fd, fpm_globals.error_log_fd);
+		close(fd);
+		fd = fpm_globals.error_log_fd; /* for FD_CLOSEXEC to work */
+	}
+	else {
+		fpm_globals.error_log_fd = fd;
+	}
+
+	fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);
+
+	return 0;
+}
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_stdio.h php-src/sapi/fpm/fpm/fpm_stdio.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_stdio.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_stdio.h	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,20 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_STDIO_H
+#define FPM_STDIO_H 1
+
+#include "fpm_worker_pool.h"
+
+int fpm_stdio_init_main();
+int fpm_stdio_init_final();
+int fpm_stdio_init_child(struct fpm_worker_pool_s *wp);
+int fpm_stdio_prepare_pipes(struct fpm_child_s *child);
+void fpm_stdio_child_use_pipes(struct fpm_child_s *child);
+int fpm_stdio_parent_use_pipes(struct fpm_child_s *child);
+int fpm_stdio_discard_pipes(struct fpm_child_s *child);
+int fpm_stdio_open_error_log(int reopen);
+
+#endif
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_str.h php-src/sapi/fpm/fpm/fpm_str.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_str.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_str.h	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,49 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_STR_H
+#define FPM_STR_H 1
+
+static inline char *cpystrn(char *dst, const char *src, size_t dst_size)
+{
+	char *d, *end;
+	
+	if (!dst_size) { return dst; }
+	
+	d = dst;
+	end = dst + dst_size - 1;
+	
+	for (; d < end; ++d, ++src) {
+		if (!(*d = *src)) {
+			return d;
+		}
+	}
+
+	*d = '\0';
+
+	return d;
+}
+
+static inline char *str_purify_filename(char *dst, char *src, size_t size)
+{
+	char *d, *end;
+
+	d = dst;
+	end = dst + size - 1;
+
+	for (; d < end && *src; ++d, ++src) {
+		if (* (unsigned char *) src < ' ' || * (unsigned char *) src > '\x7f') {
+			*d = '.';
+		}
+		else {
+			*d = *src;
+		}
+	}
+
+	*d = '\0';
+
+	return d;
+}
+
+#endif
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_trace.c php-src/sapi/fpm/fpm/fpm_trace.c
--- php-src-vanilla/sapi/fpm/fpm/fpm_trace.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_trace.c	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,46 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#include <sys/types.h>
+
+#include "fpm_trace.h"
+
+int fpm_trace_get_strz(char *buf, size_t sz, long addr)
+{
+	int i;
+	long l;
+	char *lc = (char *) &l;
+
+	if (0 > fpm_trace_get_long(addr, &l)) {
+		return -1;
+	}
+
+	i = l % SIZEOF_LONG;
+
+	l -= i;
+
+	for (addr = l; ; addr += SIZEOF_LONG) {
+
+		if (0 > fpm_trace_get_long(addr, &l)) {
+			return -1;
+		}
+
+		for ( ; i < SIZEOF_LONG; i++) {
+			--sz;
+
+			if (sz && lc[i]) {
+				*buf++ = lc[i];
+				continue;
+			}
+
+			*buf = '\0';
+			return 0;
+		}
+
+		i = 0;
+	}
+}
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_trace.h php-src/sapi/fpm/fpm/fpm_trace.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_trace.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_trace.h	2009-10-18 21:05:39.302497288 +0100
@@ -0,0 +1,17 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_TRACE_H
+#define FPM_TRACE_H 1
+
+#include <unistd.h>
+
+int fpm_trace_signal(pid_t pid);
+int fpm_trace_ready(pid_t pid);
+int fpm_trace_close(pid_t pid);
+int fpm_trace_get_long(long addr, long *data);
+int fpm_trace_get_strz(char *buf, size_t sz, long addr);
+
+#endif
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_trace_mach.c php-src/sapi/fpm/fpm/fpm_trace_mach.c
--- php-src-vanilla/sapi/fpm/fpm/fpm_trace_mach.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_trace_mach.c	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,102 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#include <mach/mach.h>
+#include <mach/mach_vm.h>
+
+#include <unistd.h>
+
+#include "fpm_trace.h"
+#include "fpm_process_ctl.h"
+#include "fpm_unix.h"
+#include "zlog.h"
+
+
+static mach_port_name_t target;
+static vm_offset_t target_page_base;
+static vm_offset_t local_page;
+static mach_msg_type_number_t local_size;
+
+static void fpm_mach_vm_deallocate()
+{
+	if (local_page) {
+		mach_vm_deallocate(mach_task_self(), local_page, local_size);
+		target_page_base = 0;
+		local_page = 0;
+		local_size = 0;
+	}
+}
+
+static int fpm_mach_vm_read_page(vm_offset_t page)
+{
+	kern_return_t kr;
+
+	kr = mach_vm_read(target, page, fpm_pagesize, &local_page, &local_size);
+
+	if (kr != KERN_SUCCESS) {
+		zlog(ZLOG_STUFF, ZLOG_ERROR, "mach_vm_read() failed: %s (%d)", mach_error_string(kr), kr);
+		return -1;
+	}
+
+	return 0;
+}
+
+int fpm_trace_signal(pid_t pid)
+{
+	if (0 > fpm_pctl_kill(pid, FPM_PCTL_STOP)) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "kill(SIGSTOP) failed");
+		return -1;
+	}
+
+	return 0;
+}
+
+int fpm_trace_ready(pid_t pid)
+{
+	kern_return_t kr;
+
+	kr = task_for_pid(mach_task_self(), pid, &target);
+
+	if (kr != KERN_SUCCESS) {
+		char *msg = "";
+
+		if (kr == KERN_FAILURE) {
+			msg = " It seems that master process does not have enough privileges to trace processes.";
+		}
+
+		zlog(ZLOG_STUFF, ZLOG_ERROR, "task_for_pid() failed: %s (%d)%s", mach_error_string(kr), kr, msg);
+		return -1;
+	}
+
+	return 0;
+}
+
+int fpm_trace_close(pid_t pid)
+{
+	fpm_mach_vm_deallocate();
+
+	target = 0;
+
+	return 0;
+}
+
+int fpm_trace_get_long(long addr, long *data)
+{
+	size_t offset = ((uintptr_t) (addr) % fpm_pagesize);
+	vm_offset_t base = (uintptr_t) (addr) - offset;
+
+	if (base != target_page_base) {
+		fpm_mach_vm_deallocate();
+		if (0 > fpm_mach_vm_read_page(base)) {
+			return -1;
+		}
+	}
+
+	*data = * (long *) (local_page + offset);
+
+	return 0;
+}
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_trace_pread.c php-src/sapi/fpm/fpm/fpm_trace_pread.c
--- php-src-vanilla/sapi/fpm/fpm/fpm_trace_pread.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_trace_pread.c	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,72 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#define _GNU_SOURCE
+#define _FILE_OFFSET_BITS 64
+
+#include "fpm_config.h"
+
+#include <unistd.h>
+
+#include <fcntl.h>
+#include <stdio.h>
+#if HAVE_INTTYPES_H
+#include <inttypes.h>
+#else
+#include <stdint.h>
+#endif
+
+
+#include "fpm_trace.h"
+#include "fpm_process_ctl.h"
+#include "zlog.h"
+
+
+static int mem_file = -1;
+
+int fpm_trace_signal(pid_t pid)
+{
+	if (0 > fpm_pctl_kill(pid, FPM_PCTL_STOP)) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "kill(SIGSTOP) failed");
+		return -1;
+	}
+
+	return 0;
+}
+
+int fpm_trace_ready(pid_t pid)
+{
+	char buf[128];
+
+	sprintf(buf, "/proc/%d/" PROC_MEM_FILE, (int) pid);
+
+	mem_file = open(buf, O_RDONLY);
+
+	if (0 > mem_file) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "open(%s) failed", buf);
+		return -1;
+	}
+
+	return 0;
+}
+
+int fpm_trace_close(pid_t pid)
+{
+	close(mem_file);
+
+	mem_file = -1;
+
+	return 0;
+}
+
+int fpm_trace_get_long(long addr, long *data)
+{
+	if (sizeof(*data) != pread(mem_file, (void *) data, sizeof(*data), (uintptr_t) addr)) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "pread() failed");
+		return -1;
+	}
+
+	return 0;
+}
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_trace_ptrace.c php-src/sapi/fpm/fpm/fpm_trace_ptrace.c
--- php-src-vanilla/sapi/fpm/fpm/fpm_trace_ptrace.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_trace_ptrace.c	2009-10-18 21:05:39.302497288 +0100
@@ -0,0 +1,85 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#include <sys/wait.h>
+#include <sys/ptrace.h>
+#include <unistd.h>
+#include <errno.h>
+
+#if defined(PT_ATTACH) && !defined(PTRACE_ATTACH)
+#define PTRACE_ATTACH PT_ATTACH
+#endif
+
+#if defined(PT_DETACH) && !defined(PTRACE_DETACH)
+#define PTRACE_DETACH PT_DETACH
+#endif
+
+#if defined(PT_READ_D) && !defined(PTRACE_PEEKDATA)
+#define PTRACE_PEEKDATA PT_READ_D
+#endif
+
+#include "fpm_trace.h"
+#include "zlog.h"
+
+static pid_t traced_pid;
+
+int fpm_trace_signal(pid_t pid)
+{
+	if (0 > ptrace(PTRACE_ATTACH, pid, 0, 0)) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "ptrace(ATTACH) failed");
+		return -1;
+	}
+
+	return 0;
+}
+
+int fpm_trace_ready(pid_t pid)
+{
+	traced_pid = pid;
+
+	return 0;
+}
+
+int fpm_trace_close(pid_t pid)
+{
+	if (0 > ptrace(PTRACE_DETACH, pid, (void *) 1, 0)) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "ptrace(DETACH) failed");
+		return -1;
+	}
+
+	traced_pid = 0;
+
+	return 0;
+}
+
+int fpm_trace_get_long(long addr, long *data)
+{
+#ifdef PT_IO
+	struct ptrace_io_desc ptio = {
+		.piod_op = PIOD_READ_D,
+		.piod_offs = (void *) addr,
+		.piod_addr = (void *) data,
+		.piod_len = sizeof(long)
+	};
+
+	if (0 > ptrace(PT_IO, traced_pid, (void *) &ptio, 0)) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "ptrace(PT_IO) failed");
+		return -1;
+	}
+#else
+	errno = 0;
+
+	*data = ptrace(PTRACE_PEEKDATA, traced_pid, (void *) addr, 0);
+
+	if (errno) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "ptrace(PEEKDATA) failed");
+		return -1;
+	}
+#endif
+
+	return 0;
+}
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_unix.c php-src/sapi/fpm/fpm/fpm_unix.c
--- php-src-vanilla/sapi/fpm/fpm/fpm_unix.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_unix.c	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,289 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#include <string.h>
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <pwd.h>
+#include <grp.h>
+
+#ifdef HAVE_PRCTL
+#include <sys/prctl.h>
+#endif
+
+#include "fpm.h"
+#include "fpm_conf.h"
+#include "fpm_cleanup.h"
+#include "fpm_clock.h"
+#include "fpm_stdio.h"
+#include "fpm_unix.h"
+#include "zlog.h"
+
+size_t fpm_pagesize;
+
+int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp)
+{
+	struct fpm_listen_options_s *lo = wp->config->listen_options;
+
+	/* uninitialized */
+	wp->socket_uid = -1;
+	wp->socket_gid = -1;
+	wp->socket_mode = 0666;
+
+	if (!lo) { return 0; }
+
+	if (lo->owner && *lo->owner) {
+		struct passwd *pwd;
+
+		pwd = getpwnam(lo->owner);
+
+		if (!pwd) {
+			zlog(ZLOG_STUFF, ZLOG_SYSERROR, "cannot get uid for user '%s', pool '%s'", lo->owner, wp->config->name);
+			return -1;
+		}
+
+		wp->socket_uid = pwd->pw_uid;
+		wp->socket_gid = pwd->pw_gid;
+	}
+
+	if (lo->group && *lo->group) {
+		struct group *grp;
+
+		grp = getgrnam(lo->group);
+
+		if (!grp) {
+			zlog(ZLOG_STUFF, ZLOG_SYSERROR, "cannot get gid for group '%s', pool '%s'", lo->group, wp->config->name);
+			return -1;
+		}
+
+		wp->socket_gid = grp->gr_gid;
+	}
+
+	if (lo->mode && *lo->mode) {
+		wp->socket_mode = strtoul(lo->mode, 0, 8);
+	}
+
+	return 0;
+}
+
+static int fpm_unix_conf_wp(struct fpm_worker_pool_s *wp)
+{
+	int is_root = !geteuid();
+
+	if (is_root) {
+		if (wp->config->user && *wp->config->user) {
+
+			if (strlen(wp->config->user) == strspn(wp->config->user, "0123456789")) {
+				wp->set_uid = strtoul(wp->config->user, 0, 10);
+			}
+			else {
+				struct passwd *pwd;
+
+				pwd = getpwnam(wp->config->user);
+
+				if (!pwd) {
+					zlog(ZLOG_STUFF, ZLOG_ERROR, "cannot get uid for user '%s', pool '%s'", wp->config->user, wp->config->name);
+					return -1;
+				}
+
+				wp->set_uid = pwd->pw_uid;
+				wp->set_gid = pwd->pw_gid;
+
+				wp->user = strdup(pwd->pw_name);
+				wp->home = strdup(pwd->pw_dir);
+			}
+		}
+
+		if (wp->config->group && *wp->config->group) {
+
+			if (strlen(wp->config->group) == strspn(wp->config->group, "0123456789")) {
+				wp->set_gid = strtoul(wp->config->group, 0, 10);
+			}
+			else {
+				struct group *grp;
+
+				grp = getgrnam(wp->config->group);
+
+				if (!grp) {
+					zlog(ZLOG_STUFF, ZLOG_ERROR, "cannot get gid for group '%s', pool '%s'", wp->config->group, wp->config->name);
+					return -1;
+				}
+
+				wp->set_gid = grp->gr_gid;
+			}
+		}
+
+#ifndef I_REALLY_WANT_ROOT_PHP
+		if (wp->set_uid == 0 || wp->set_gid == 0) {
+			zlog(ZLOG_STUFF, ZLOG_ERROR, "please specify user and group other than root, pool '%s'", wp->config->name);
+			return -1;
+		}
+#endif
+	}
+	else { /* not root */
+		if (wp->config->user && *wp->config->user) {
+			zlog(ZLOG_STUFF, ZLOG_WARNING, "'user' directive is ignored, pool '%s'", wp->config->name);
+		}
+		if (wp->config->group && *wp->config->group) {
+			zlog(ZLOG_STUFF, ZLOG_WARNING, "'group' directive is ignored, pool '%s'", wp->config->name);
+		}
+		if (wp->config->chroot && *wp->config->chroot) {
+			zlog(ZLOG_STUFF, ZLOG_WARNING, "'chroot' directive is ignored, pool '%s'", wp->config->name);
+		}
+
+		{ /* set up HOME and USER anyway */
+			struct passwd *pwd;
+
+			pwd = getpwuid(getuid());
+
+			if (pwd) {
+				wp->user = strdup(pwd->pw_name);
+				wp->home = strdup(pwd->pw_dir);
+			}
+		}
+	}
+
+	return 0;
+}
+
+int fpm_unix_init_child(struct fpm_worker_pool_s *wp)
+{
+	int is_root = !geteuid();
+	int made_chroot = 0;
+
+	if (wp->config->rlimit_files) {
+		struct rlimit r;
+
+		getrlimit(RLIMIT_NOFILE, &r);
+
+		r.rlim_cur = (rlim_t) wp->config->rlimit_files;
+
+		if (0 > setrlimit(RLIMIT_NOFILE, &r)) {
+			zlog(ZLOG_STUFF, ZLOG_SYSERROR, "setrlimit(RLIMIT_NOFILE) failed");
+		}
+	}
+
+	if (wp->config->rlimit_core) {
+		struct rlimit r;
+
+		getrlimit(RLIMIT_CORE, &r);
+
+		r.rlim_cur = wp->config->rlimit_core == -1 ? (rlim_t) RLIM_INFINITY : (rlim_t) wp->config->rlimit_core;
+
+		if (0 > setrlimit(RLIMIT_CORE, &r)) {
+			zlog(ZLOG_STUFF, ZLOG_SYSERROR, "setrlimit(RLIMIT_CORE) failed");
+		}
+	}
+
+	if (is_root && wp->config->chroot && *wp->config->chroot) {
+		if (0 > chroot(wp->config->chroot)) {
+			zlog(ZLOG_STUFF, ZLOG_SYSERROR, "chroot(%s) failed", wp->config->chroot);
+			return -1;
+		}
+		made_chroot = 1;
+	}
+
+	if (wp->config->chdir && *wp->config->chdir) {
+		if (0 > chdir(wp->config->chdir)) {
+			zlog(ZLOG_STUFF, ZLOG_SYSERROR, "chdir(%s) failed", wp->config->chdir);
+			return -1;
+		}
+	}
+	else if (made_chroot) {
+		chdir("/");
+	}
+
+	if (is_root) {
+		if (wp->set_gid) {
+			if (0 > setgid(wp->set_gid)) {
+				zlog(ZLOG_STUFF, ZLOG_SYSERROR, "setgid(%d) failed", wp->set_gid);
+				return -1;
+			}
+		}
+		if (wp->set_uid) {
+			if (0 > initgroups(wp->config->user, wp->set_gid)) {
+				zlog(ZLOG_STUFF, ZLOG_SYSERROR, "initgroups(%s, %d) failed", wp->config->user, wp->set_gid);
+				return -1;
+			}
+			if (0 > setuid(wp->set_uid)) {
+				zlog(ZLOG_STUFF, ZLOG_SYSERROR, "setuid(%d) failed", wp->set_uid);
+				return -1;
+			}
+		}
+	}
+
+#ifdef HAVE_PRCTL
+	if (0 > prctl(PR_SET_DUMPABLE, 1, 0, 0, 0)) {
+		zlog(ZLOG_STUFF, ZLOG_SYSERROR, "prctl(PR_SET_DUMPABLE) failed");
+	}
+#endif
+
+	if (0 > fpm_clock_init()) {
+		return -1;
+	}
+
+	return 0;
+}
+
+int fpm_unix_init_main()
+{
+	struct fpm_worker_pool_s *wp;
+
+	fpm_pagesize = getpagesize();
+
+	if (fpm_global_config.daemonize) {
+
+		switch (fork()) {
+
+			case -1 :
+
+				zlog(ZLOG_STUFF, ZLOG_SYSERROR, "fork() failed");
+				return -1;
+
+			case 0 :
+
+				break;
+
+			default :
+
+				fpm_cleanups_run(FPM_CLEANUP_PARENT_EXIT);
+				exit(0);
+
+		}
+
+	}
+
+	setsid();
+
+	if (0 > fpm_clock_init()) {
+		return -1;
+	}
+
+	fpm_globals.parent_pid = getpid();
+
+	for (wp = fpm_worker_all_pools; wp; wp = wp->next) {
+
+		if (0 > fpm_unix_conf_wp(wp)) {
+			return -1;
+		}
+
+	}
+
+	fpm_stdio_init_final();
+
+	{
+		struct rlimit r;
+		getrlimit(RLIMIT_NOFILE, &r);
+
+		zlog(ZLOG_STUFF, ZLOG_NOTICE, "getrlimit(nofile): max:%lld, cur:%lld",
+			(long long) r.rlim_max, (long long) r.rlim_cur);
+	}
+
+	return 0;
+}
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_unix.h php-src/sapi/fpm/fpm/fpm_unix.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_unix.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_unix.h	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,17 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_UNIX_H
+#define FPM_UNIX_H 1
+
+#include "fpm_worker_pool.h"
+
+int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp);
+int fpm_unix_init_child(struct fpm_worker_pool_s *wp);
+int fpm_unix_init_main();
+
+extern size_t fpm_pagesize;
+
+#endif
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_worker_pool.c php-src/sapi/fpm/fpm/fpm_worker_pool.c
--- php-src-vanilla/sapi/fpm/fpm/fpm_worker_pool.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_worker_pool.c	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,69 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "fpm_worker_pool.h"
+#include "fpm_cleanup.h"
+#include "fpm_children.h"
+#include "fpm_shm.h"
+#include "fpm_shm_slots.h"
+#include "fpm_conf.h"
+
+struct fpm_worker_pool_s *fpm_worker_all_pools;
+
+static void fpm_worker_pool_cleanup(int which, void *arg)
+{
+	struct fpm_worker_pool_s *wp, *wp_next;
+
+	for (wp = fpm_worker_all_pools; wp; wp = wp_next) {
+		wp_next = wp->next;
+		fpm_worker_pool_config_free(wp->config);
+		fpm_children_free(wp->children);
+		fpm_array_free(&wp->slots_used);
+		fpm_array_free(&wp->slots_free);
+		fpm_shm_free_list(wp->shm_list, which == FPM_CLEANUP_CHILD ? fpm_shm_slots_mem() : 0);
+		free(wp->config);
+		free(wp->user);
+		free(wp->home);
+		free(wp);
+	}
+
+	fpm_worker_all_pools = 0;
+}
+
+struct fpm_worker_pool_s *fpm_worker_pool_alloc()
+{
+	struct fpm_worker_pool_s *ret;
+
+	ret = malloc(sizeof(struct fpm_worker_pool_s));
+
+	if (!ret) {
+		return 0;
+	}
+
+	memset(ret, 0, sizeof(struct fpm_worker_pool_s));
+
+	if (!fpm_worker_all_pools) {
+		fpm_worker_all_pools = ret;
+	}
+
+	fpm_array_init(&ret->slots_used, sizeof(struct fpm_shm_slot_ptr_s), 50);
+	fpm_array_init(&ret->slots_free, sizeof(struct fpm_shm_slot_ptr_s), 50);
+
+	return ret;
+}
+
+int fpm_worker_pool_init_main()
+{
+	if (0 > fpm_cleanup_add(FPM_CLEANUP_ALL, fpm_worker_pool_cleanup, 0)) {
+		return -1;
+	}
+
+	return 0;
+}
diff -Naur php-src-vanilla/sapi/fpm/fpm/fpm_worker_pool.h php-src/sapi/fpm/fpm/fpm_worker_pool.h
--- php-src-vanilla/sapi/fpm/fpm/fpm_worker_pool.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/fpm_worker_pool.h	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,46 @@
+
+	/* $Id$ */
+	/* (c) 2007,2008 Andrei Nigmatulin */
+
+#ifndef FPM_WORKER_POOL_H
+#define FPM_WORKER_POOL_H 1
+
+#include "fpm_conf.h"
+#include "fpm_arrays.h"
+
+struct fpm_worker_pool_s;
+struct fpm_child_s;
+struct fpm_child_stat_s;
+struct fpm_shm_s;
+
+enum fpm_address_domain {
+	FPM_AF_UNIX = 1,
+	FPM_AF_INET = 2
+};
+
+struct fpm_worker_pool_s {
+	struct fpm_worker_pool_s *next;
+	struct fpm_worker_pool_config_s *config;
+	char *user, *home;									/* for setting env USER and HOME */
+	enum fpm_address_domain listen_address_domain;
+	int listening_socket;
+	int set_uid, set_gid;								/* config uid and gid */
+	unsigned is_template:1;									/* just config template, no processes will be created */
+	int socket_uid, socket_gid, socket_mode;
+
+	struct fpm_shm_s *shm_list;
+	struct fpm_array_s slots_used;
+	struct fpm_array_s slots_free;
+
+	/* runtime */
+	struct fpm_child_s *children;
+	int running_children;
+};
+
+struct fpm_worker_pool_s *fpm_worker_pool_alloc();
+int fpm_worker_pool_init_main();
+
+extern struct fpm_worker_pool_s *fpm_worker_all_pools;
+
+#endif
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/xml_config.c php-src/sapi/fpm/fpm/xml_config.c
--- php-src-vanilla/sapi/fpm/fpm/xml_config.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/xml_config.c	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,278 @@
+
+	/* $Id$ */
+	/* (c) 2004-2007 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#ifdef HAVE_ALLOCA_H
+#include <alloca.h>
+#endif
+#include <string.h>
+#include <stdio.h>
+#include <stddef.h>
+#include <stdlib.h>
+
+#include <libxml/parser.h>
+#include <libxml/tree.h>
+
+#include "xml_config.h"
+
+static struct xml_conf_section **xml_conf_sections = 0;
+static int xml_conf_sections_allocated = 0;
+static int xml_conf_sections_used = 0;
+
+char *xml_conf_set_slot_boolean(void **conf, char *name, void *vv, intptr_t offset)
+{
+	char *value = vv;
+	long value_y = !strcasecmp(value, "yes") || !strcmp(value,  "1") || !strcasecmp(value, "on");
+	long value_n = !strcasecmp(value, "no")  || !strcmp(value,  "0") || !strcasecmp(value, "off");
+
+	if (!value_y && !value_n) {
+		return "xml_conf_set_slot(): invalid boolean value";
+	}
+
+#ifdef XML_CONF_DEBUG
+	fprintf(stderr, "setting boolean '%s' => %s\n", name, value_y ? "TRUE" : "FALSE");
+#endif
+
+	* (int *) ((char *) *conf + offset) = value_y ? 1 : 0;
+
+	return NULL;
+}
+
+char *xml_conf_set_slot_string(void **conf, char *name, void *vv, intptr_t offset)
+{
+	char *value = vv;
+	char *v = strdup(value);
+
+	if (!v) { return "xml_conf_set_slot_string(): strdup() failed"; }
+
+#ifdef XML_CONF_DEBUG
+	fprintf(stderr, "setting string '%s' => '%s'\n", name, v);
+#endif
+
+	* (char **) ((char *) *conf + offset) = v;
+
+	return NULL;
+}
+
+char *xml_conf_set_slot_integer(void **conf, char *name, void *vv, intptr_t offset)
+{
+	char *value = vv;
+	int v = atoi(value);
+
+	* (int *) ((char *) *conf + offset) = v;
+
+#ifdef XML_CONF_DEBUG
+	fprintf(stderr, "setting integer '%s' => %d\n", name, v);
+#endif
+
+	return NULL;
+}
+
+char *xml_conf_set_slot_time(void **conf, char *name, void *vv, intptr_t offset)
+{
+	char *value = vv;
+	int len = strlen(value);
+	char suffix;
+	int seconds;
+
+	if (!len) { return "xml_conf_set_slot_timeval(): invalid timeval value"; }
+
+	suffix = value[len-1];
+
+	value[len-1] = '\0';
+
+	switch (suffix) {
+		case 's' :
+			seconds = atoi(value);
+			break;
+		case 'm' :
+			seconds = 60 * atoi(value);
+			break;
+		case 'h' :
+			seconds = 60 * 60 * atoi(value);
+			break;
+		case 'd' :
+			seconds = 24 * 60 * 60 * atoi(value);
+			break;
+		default :
+			return "xml_conf_set_slot_timeval(): unknown suffix used in timeval value";
+	}
+
+	* (int *) ((char *) *conf + offset) = seconds;
+
+#ifdef XML_CONF_DEBUG
+	fprintf(stderr, "setting time '%s' => %d:%02d:%02d:%02d\n", name, expand_dhms(seconds));
+#endif
+
+	return NULL;
+}
+
+char *xml_conf_parse_section(void **conf, struct xml_conf_section *section, void *xml_node)
+{
+	xmlNode *element = xml_node;
+	char *ret = 0;
+
+#ifdef XML_CONF_DEBUG
+	fprintf(stderr, "processing a section %s\n", section->path);
+#endif
+
+	for ( ; element; element = element->next) {
+		if (element->type == XML_ELEMENT_NODE && !strcmp((const char *) element->name, "value") && element->children) {
+			xmlChar *name = xmlGetProp(element, (unsigned char *) "name");
+
+			if (name) {
+				int i;
+
+#ifdef XML_CONF_DEBUG
+				fprintf(stderr, "found a value: %s\n", name);
+#endif
+				for (i = 0; section->parsers[i].parser; i++) {
+					if (!section->parsers[i].name || !strcmp(section->parsers[i].name, (char *) name)) {
+						break;
+					}
+				}
+
+				if (section->parsers[i].parser) {
+					if (section->parsers[i].type == XML_CONF_SCALAR) {
+						if (element->children->type == XML_TEXT_NODE) {
+							ret = section->parsers[i].parser(conf, (char *) name, element->children->content, section->parsers[i].offset);
+						}
+						else {
+							ret = "XML_TEXT_NODE is expected, something different is given";
+						}
+					}
+					else {
+						ret = section->parsers[i].parser(conf, (char *) name, element->children, section->parsers[i].offset);
+					}
+
+					xmlFree(name);
+					if (ret) { return ret; }
+					else { continue; }
+				}
+
+				fprintf(stderr, "Warning, unknown setting '%s' in section '%s'\n", (char *) name, section->path);
+
+				xmlFree(name);
+			}
+		}
+	}
+
+	return NULL;
+}
+
+static char *xml_conf_parse_file(xmlNode *element)
+{
+	char *ret = 0;
+
+	for ( ; element; element = element->next) {
+
+		if (element->parent && element->type == XML_ELEMENT_NODE && !strcmp((const char *) element->name, "section")) {
+			xmlChar *name = xmlGetProp(element, (unsigned char *) "name");
+
+			if (name) {
+				char *parent_name = (char *) xmlGetNodePath(element->parent);
+				char *full_name;
+				int i;
+				struct xml_conf_section *section = NULL;
+
+#ifdef XML_CONF_DEBUG
+				fprintf(stderr, "got a section: %s/%s\n", parent_name, name);
+#endif
+				full_name = alloca(strlen(parent_name) + strlen((char *) name) + 1 + 1);
+
+				sprintf(full_name, "%s/%s", parent_name, (char *) name);
+
+				xmlFree(parent_name);
+				xmlFree(name);
+
+				for (i = 0; i < xml_conf_sections_used; i++) {
+					if (!strcmp(xml_conf_sections[i]->path, full_name)) {
+						section = xml_conf_sections[i];
+					}
+				}
+
+				if (section) { /* found a registered section */
+					void *conf = section->conf();
+					ret = xml_conf_parse_section(&conf, section, element->children);
+					if (ret) { break; }
+				}
+
+			}
+		}
+
+		if (element->children) {
+			ret = xml_conf_parse_file(element->children);
+			if (ret) { break; }
+		}
+	}
+
+	return ret;
+}
+
+char *xml_conf_load_file(char *file)
+{
+	char *ret = 0;
+	xmlDoc *doc;
+
+	LIBXML_TEST_VERSION
+
+	doc = xmlParseFile(file);
+
+	if (doc) {
+		ret = xml_conf_parse_file(doc->children);
+		xmlFreeDoc(doc);
+	}
+	else {
+		ret = "failed to parse conf file";
+	}
+
+	xmlCleanupParser();
+	return ret;
+}
+
+int xml_conf_init()
+{
+	return 0;
+}
+
+void xml_conf_clean()
+{
+	if (xml_conf_sections) {
+		free(xml_conf_sections);
+	}
+}
+
+int xml_conf_section_register(struct xml_conf_section *section)
+{
+	if (xml_conf_sections_allocated == xml_conf_sections_used) {
+		int new_size = xml_conf_sections_used + 10;
+		void *new_ptr = realloc(xml_conf_sections, sizeof(struct xml_conf_section *) * new_size);
+
+		if (new_ptr) {
+			xml_conf_sections = new_ptr;
+			xml_conf_sections_allocated = new_size;
+		}
+		else {
+			fprintf(stderr, "xml_conf_section_register(): out of memory\n");
+			return -1;
+		}
+	}
+
+	xml_conf_sections[xml_conf_sections_used++] = section;
+
+	return 0;
+}
+
+int xml_conf_sections_register(struct xml_conf_section *sections[])
+{
+	for ( ; sections && *sections; sections++) {
+		if (0 > xml_conf_section_register(*sections)) {
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
diff -Naur php-src-vanilla/sapi/fpm/fpm/xml_config.h php-src/sapi/fpm/fpm/xml_config.h
--- php-src-vanilla/sapi/fpm/fpm/xml_config.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/xml_config.h	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,48 @@
+
+	/* $Id$ */
+	/* (c) 2004-2007 Andrei Nigmatulin */
+
+#ifndef XML_CONFIG_H
+#define XML_CONFIG_H 1
+
+#if HAVE_INTTYPES_H
+#include <inttypes.h>
+#else
+#include <stdint.h>
+#endif
+
+
+struct xml_value_parser;
+
+struct xml_value_parser {
+	int type;
+	char *name;
+	char *(*parser)(void **, char *, void *, intptr_t offset);
+	intptr_t offset;
+};
+
+struct xml_conf_section {
+	void *(*conf)();
+	char *path;
+	struct xml_value_parser *parsers;
+};
+
+char *xml_conf_set_slot_boolean(void **conf, char *name, void *value, intptr_t offset);
+char *xml_conf_set_slot_string(void **conf, char *name, void *value, intptr_t offset);
+char *xml_conf_set_slot_integer(void **conf, char *name, void *value, intptr_t offset);
+char *xml_conf_set_slot_time(void **conf, char *name, void *value, intptr_t offset);
+
+int xml_conf_init();
+void xml_conf_clean();
+char *xml_conf_load_file(char *file);
+char *xml_conf_parse_section(void **conf, struct xml_conf_section *section, void *ve);
+int xml_conf_section_register(struct xml_conf_section *section);
+int xml_conf_sections_register(struct xml_conf_section *sections[]);
+
+#define expand_hms(value) (value) / 3600, ((value) % 3600) / 60, (value) % 60
+
+#define expand_dhms(value) (value) / 86400, ((value) % 86400) / 3600, ((value) % 3600) / 60, (value) % 60
+
+enum { XML_CONF_SCALAR = 1, XML_CONF_SUBSECTION = 2 };
+
+#endif
diff -Naur php-src-vanilla/sapi/fpm/fpm/zlog.c php-src/sapi/fpm/fpm/zlog.c
--- php-src-vanilla/sapi/fpm/fpm/zlog.c	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/zlog.c	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,113 @@
+
+	/* $Id$ */
+	/* (c) 2004-2007 Andrei Nigmatulin */
+
+#include "fpm_config.h"
+
+#include <stdio.h>
+#include <unistd.h>
+#include <time.h>
+#include <string.h>
+#include <stdarg.h>
+#include <sys/time.h>
+#include <errno.h>
+
+#include "zlog.h"
+
+#define MAX_LINE_LENGTH 1024
+
+static int zlog_fd = -1;
+static int zlog_level = ZLOG_NOTICE;
+
+static const char *level_names[] = {
+	[ZLOG_DEBUG]		= "DEBUG",
+	[ZLOG_NOTICE]		= "NOTICE",
+	[ZLOG_WARNING]		= "WARNING",
+	[ZLOG_ERROR]		= "ERROR",
+	[ZLOG_ALERT]		= "ALERT",
+};
+
+size_t zlog_print_time(struct timeval *tv, char *timebuf, size_t timebuf_len)
+{
+	struct tm t;
+	size_t len;
+
+	len = strftime(timebuf, timebuf_len, "%b %d %H:%M:%S", localtime_r((const time_t *) &tv->tv_sec, &t));
+	len += snprintf(timebuf + len, timebuf_len - len, ".%06d", (int) tv->tv_usec);
+
+	return len;
+}
+
+int zlog_set_fd(int new_fd)
+{
+	int old_fd = zlog_fd;
+	zlog_fd = new_fd;
+
+	return old_fd;
+}
+
+int zlog_set_level(int new_value)
+{
+	int old_value = zlog_level;
+
+	zlog_level = new_value;
+
+	return old_value;
+}
+
+void zlog(const char *function, int line, int flags, const char *fmt, ...)
+{
+	struct timeval tv;
+	char buf[MAX_LINE_LENGTH];
+	const size_t buf_size = MAX_LINE_LENGTH;
+	va_list args;
+	size_t len;
+	int truncated = 0;
+	int saved_errno;
+
+	if ((flags & ZLOG_LEVEL_MASK) < zlog_level) {
+		return;
+	}
+
+	saved_errno = errno;
+
+	gettimeofday(&tv, 0);
+
+	len = zlog_print_time(&tv, buf, buf_size);
+
+	len += snprintf(buf + len, buf_size - len, " [%s] %s(), line %d: ", level_names[flags & ZLOG_LEVEL_MASK], function, line);
+
+	if (len > buf_size - 1) {
+		truncated = 1;
+	}
+
+	if (!truncated) {
+		va_start(args, fmt);
+
+		len += vsnprintf(buf + len, buf_size - len, fmt, args);
+
+		va_end(args);
+
+		if (len >= buf_size) {
+			truncated = 1;
+		}
+	}
+
+	if (!truncated) {
+		if (flags & ZLOG_HAVE_ERRNO) {
+			len += snprintf(buf + len, buf_size - len, ": %s (%d)", strerror(saved_errno), saved_errno);
+			if (len >= buf_size) {
+				truncated = 1;
+			}
+		}
+	}
+
+	if (truncated) {
+		memcpy(buf + buf_size - sizeof("..."), "...", sizeof("...") - 1);
+		len = buf_size - 1;
+	}
+
+	buf[len++] = '\n';
+
+	write(zlog_fd > -1 ? zlog_fd : STDERR_FILENO, buf, len);
+}
diff -Naur php-src-vanilla/sapi/fpm/fpm/zlog.h php-src/sapi/fpm/fpm/zlog.h
--- php-src-vanilla/sapi/fpm/fpm/zlog.h	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/fpm/zlog.h	2009-10-18 21:05:39.308376784 +0100
@@ -0,0 +1,34 @@
+
+	/* $Id$ */
+	/* (c) 2004-2007 Andrei Nigmatulin */
+
+#ifndef ZLOG_H
+#define ZLOG_H 1
+
+#define ZLOG_STUFF		__func__, __LINE__
+
+struct timeval;
+
+int zlog_set_fd(int new_fd);
+int zlog_set_level(int new_value);
+
+size_t zlog_print_time(struct timeval *tv, char *timebuf, size_t timebuf_len);
+
+void zlog(const char *function, int line, int flags, const char *fmt, ...)
+		__attribute__ ((format(printf,4,5)));
+
+enum {
+	ZLOG_DEBUG			= 1,
+	ZLOG_NOTICE			= 2,
+	ZLOG_WARNING		= 3,
+	ZLOG_ERROR			= 4,
+	ZLOG_ALERT			= 5,
+};
+
+#define ZLOG_LEVEL_MASK 7
+
+#define ZLOG_HAVE_ERRNO 0x100
+
+#define ZLOG_SYSERROR (ZLOG_ERROR | ZLOG_HAVE_ERRNO)
+
+#endif
diff -Naur php-src-vanilla/sapi/fpm/LICENSE php-src/sapi/fpm/LICENSE
--- php-src-vanilla/sapi/fpm/LICENSE	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/LICENSE	2009-10-18 21:05:39.302497288 +0100
@@ -0,0 +1,23 @@
+Copyright (c) 2007-2009, Andrei Nigmatulin
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGE.
diff -Naur php-src-vanilla/sapi/fpm/man/php-fpm.1.in php-src/sapi/fpm/man/php-fpm.1.in
--- php-src-vanilla/sapi/fpm/man/php-fpm.1.in	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/man/php-fpm.1.in	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,186 @@
+.TH PHP-FPM 1 "2009" "The PHP Group" "Scripting Language"
+.SH NAME
+.TP 15
+@php_fpm_bin@ \- PHP FastCGI Process Manager 'PHP-FPM'
+.SH SYNOPSIS
+.B @php_fpm_bin@
+[options]
+.LP
+.SH DESCRIPTION
+\fBPHP\fP is a widely\-used general\-purpose scripting language that is especially suited for 
+Web development and can be embedded into HTML. This is a variant of PHP that will run in the background as a daemon, listening for CGI requests. Output is logged to @php_fpm_log_path@.
+.LP
+Most options are set in the xml configuration file @php_fpm_conf_path@. Unless configured otherwise, @php_fpm_bin@ will respond to CGI requests listening on http localhost port 9000 by default. Therefore @php_fpm_bin@ expects your webserver to forward all requests for '.php' files to port 9000 and you should edit your webserver configuration file appropriately.
+.SH OPTIONS
+.TP 15
+.B \-C
+Do not chdir to the script's directory
+.TP
+.PD 0
+.B \-\-php\-ini \fIpath\fP|\fIfile\fP
+.TP
+.PD 1
+.B \-c \fIpath\fP|\fIfile\fP
+Look for 
+.B php.ini 
+file in the directory
+.IR path
+or use the specified
+.IR file
+.TP
+.PD 0
+.B \-\-no\-php\-ini
+.TP
+.PD 1
+.B \-n
+No 
+.B php.ini 
+file will be used
+.TP
+.PD 0
+.B \-\-define \fIfoo\fP[=\fIbar\fP]
+.TP
+.PD 1
+.B \-d \fIfoo\fP[=\fIbar\fP]
+Define INI entry 
+.IR foo 
+with value
+.IR bar
+.TP
+.B \-e
+Generate extended information for debugger/profiler
+.TP
+.PD 0
+.B \-\-help
+.TP
+.PD 1
+.B \-h
+This help
+.TP
+.PD 0
+.B \-\-info
+.TP
+.PD 1
+.B \-i
+PHP information and configuration
+.TP
+.PD 0
+.B \-\-modules
+.TP
+.PD 1
+.B \-m
+Show compiled in modules
+.TP
+.PD 0
+.B \-\-version
+.TP
+.PD 1
+.B \-v
+Version number
+.TP
+.PD 0
+.B \-\-fpm\-config \fIfile\fP
+.TP
+.PD 1
+.B \-\-y
+Specify alternative path to FastCGI process manager configuration file (the default is @php_fpm_conf_path@)
+.TP
+.PD 0
+.B \-\-zend\-extension \fIfile\fP
+.TP
+.PD 1
+.B \-z \fIfile\fP
+Load Zend extension 
+.IR file
+.SH FILES
+.TP 15
+.B @php_fpm_bin@.conf
+The configuration file for the @php_fpm_bin@ daemon.
+.TP
+.B php.ini
+The standard php configuration file.
+.SH EXAMPLES
+You should use the init script provided to start and stop the @php_fpm_bin@ daemon. This situation applies for any unix systems which use init.d for their main process manager.
+.P
+.PD 1
+.RS
+sudo /etc/init.d/@php_fpm_bin@ start
+.RE
+.TP
+If your installation has no appropriate init script, launch @php_fpm_bin_path@ with no arguments. It will launch as a daemon (background process) by default. The file @php_fpm_pid_path@ determines whether @php_fpm_bin@ is already up and running. Once started, @php_fpm_bin@ then responds to several POSIX signals:
+.P
+.PD 0
+.RS
+.B SIGINT,SIGTERM 	\fPimmediate termination
+.TP
+.B SIGQUIT 			\fPgraceful stop
+.TP
+.B SIGUSR1 			\fPre-open log file
+.TP
+.B SIGUSR2 			\fPgraceful reload of all workers + reload of fpm conf/binary
+.RE
+.PD 1
+.P
+.SH TIPS
+The PHP-FPM CGI daemon will work well with most popular webservers, including Apache2 and light-httpd. For best efficiency and performance improvements its also worthwhile to consider the engine-x webserver ('nginx'), and php opcode-cacher ('php5-xcache').
+.PD 1
+.P
+.SH SEE ALSO
+The PHP-FPM website:
+.PD 0
+.P
+.B http://php-fpm.org
+.PD 1
+.P
+For a more or less complete description of PHP look here:
+.PD 0
+.P
+.B http://www.php.net/manual/
+.PD 1
+.P
+A nice introduction to PHP by Stig Bakken can be found here:
+.PD 0
+.P
+.B http://www.zend.com/zend/art/intro.php
+.PD 1
+.SH BUGS
+You can view the list of known bugs or report any new bug you
+found at:
+.PD 0
+.P
+.B http://bugs.php.net
+.PD 1
+.SH AUTHORS
+PHP-FPM Sapi was written by Andrei Nigmatulin. The mailing-lists are highload-php-en (English) and highload-php-ru (Russion).
+.P
+The PHP Group: Thies C. Arntzen, Stig Bakken, Andi Gutmans, Rasmus Lerdorf, Sam Ruby, Sascha Schumann, Zeev Suraski, Jim Winstead, Andrei Zmievski.
+.P
+A List of active developers can be found here:
+.PD 0
+.P
+.B http://www.php.net/credits.php
+.PD 1
+.P
+And last but not least PHP was developed with the help of a huge amount of 
+contributors all around the world.
+.SH VERSION INFORMATION
+This manpage describes \fBphp\fP, version @PHP_VERSION@, \fBfpm\fP, version @fpm_version@.
+.SH COPYRIGHT
+Copyright \(co 1997\-2009 The PHP Group
+.PD 0
+.P
+Copyright (c) 2007-2009, Andrei Nigmatulin
+.PD 1
+.LP
+This source file is subject to version 3.01 of the PHP license,
+that is bundled with this package in the file LICENSE, and is
+available through the world-wide-web at the following url:
+.PD 0
+.P
+.B http://www.php.net/license/3_01.txt
+.PD 1
+.P
+If you did not receive a copy of the PHP license and are unable to
+obtain it through the world-wide-web, please send a note to
+.B license@php.net
+so we can mail you a copy immediately.
diff -Naur php-src-vanilla/sapi/fpm/readme-ru.markdown php-src/sapi/fpm/readme-ru.markdown
--- php-src-vanilla/sapi/fpm/readme-ru.markdown	1970-01-01 01:00:00.000000000 +0100
+++ php-src/sapi/fpm/readme-ru.markdown	2009-10-18 21:05:39.310440424 +0100
@@ -0,0 +1,127 @@
+# PHP FastCGI Менеджер процессов (PHP-FPM)
+
+PHP-FPM это Fast-CGI фронтэнд для php и расширение php-cgi. Проект находится на [Launchpad](https://launchpad.net/php-fpm)
+
+## Быстрый старт:
+
+Выберите один из 2 путей сборки fpm: Или `встроенный`, или `отдельный`. Если вы не разработчик или не системный администратор, то мы рекомендуем `встроенный` вариант компиляции. Для дополнительной информации смотрите файл `readme.markdown`.
+
+## Зависимости
+Если вы до этого не устанавливали php, то вам придётся установить пакет `libxml2-dev`. FPM также необходим `libevent-dev`. Debian / ubuntu:
+
+	sudo aptitude install -y libxml2-dev libevent-dev
+
+Рекомендуется использовать libevent 1.4.12-stable или позднее, но необходим, как минимум, libevent 1.4.3-stable. Если нет подходящей версии, скайте и скомпилируйте с [сайта Libevent](http://www.monkey.org/~provos/libevent/).
+
+	export LE_VER=1.4.12-stable
+	wget "http://www.monkey.org/~provos/libevent-$LE_VER.tar.gz"
+	tar -zxvf "libevent-$LE_VER.tar.gz"
+	cd "libevent-$LE_VER"
+	./configure && make
+	DESTDIR=$PWD make install
+	export LIBEVENT_SEARCH_PATH="$PWD/usr/local"
+
+## Встроенная сборка
+
+Скачайте fpm и сгенерируйте патч
+
+	export PHP_VER=5.3.0
+	wget "http://launchpad.net/php-fpm/master/0.6/+download/php-fpm-0.6-$PHP_VER.tar.gz"
+	tar -zxvf "php-fpm-0.6-$PHP_VER.tar.gz"
+	"php-fpm-0.6-$PHP_VER/generate-fpm-patch"
+
+Скачайте и распакуйте исходный код PHP
+
+	wget "http://ru2.php.net/get/php-$PHP_VER.tar.gz/from/ru2.php.net/mirror"
+	tar xvfz "php-$PHP_VER.tar.gz"
+	cd "php-$PHP_VER"
+
+Примените патч и компилируйте
+
+	patch -p1 < ../fpm.patch
+	./buildconf --force
+	mkdir fpm-build && cd fpm-build
+	../configure --with-fpm \
+	--with-libevent="$LIBEVENT_SEARCH_PATH" && make
+
+## Отдельная сборка
+
+Скачайте и распакуйте исходный код PHP
+
+	export PHP_VER=5.3.0
+	wget "http://ru2.php.net/get/php-$PHP_VER.tar.gz/from/ru2.php.net/mirror"
+	tar xvfz "php-$PHP_VER.tar.gz"
+	cd "php-$PHP_VER"
+	mkdir php-build && cd php-build
+	../configure && make
+
+Теперь можете скачать, конфигурировать и компилировать FPM фронтэнд
+
+	wget "http://launchpad.net/php-fpm/master/0.6/+download/php-fpm-0.6-$PHP_VER.tar.gz"
+	tar -zxvf "php-fpm-0.6-$PHP_VER.tar.gz"
+	cd "php-fpm-0.6-$PHP_VER"
+	mkdir fpm-build && cd fpm-build
+	../configure --srcdir=../ \
+	 --with-php-src="../../php-$PHP_VER" \
+	 --with-php-build="../../php-$PHP_VER/php-build" \
+	 --with-libevent="$LIBEVENT_SEARCH_PATH" && make
+
+## Флаги конфигурирования
+
+	--with-libevent[=PATH]       Путь до libevent, для fpm SAPI [/usr/local]
+	--with-fpm-bin[=PATH]        Путь для откомпилированного php-fpm [/usr/local/bin/php-fpm]
+	--with-fpm-port[=PORT]       TCP порт для cgi запросов [9000]
+	--with[out]-fpm-conf[=PATH]  Путь до файла конфигурации php-fpm [/etc/php-fpm.conf]
+	--with[out]-fpm-init[=PATH]  Путь до init-файла php-fpm [/etc/init.d/php-fpm]
+	--with-fpm-log[=PATH]        Путь до лог-файла php-fpm [/var/log/php-fpm.log]
+	--with-fpm-pid[=PATH]        Путь до pid-файла php-fpm [/var/run/php-fpm.pid]
+	--with-fpm-user[=USER]       Пользователь, под которым запускать php-fpm [nobody]
+	--with-fpm-group[=GRP]       Группа, под которой запускать php-fpm. Для системных 
+		                  	     пользователей задайте имя пользователя [nobody]
+
+## Установка
+
+Если вы делали `встроенную` сборку, то вы получите полный php, включая исполнитель коммандной строки `php-cli` и библиотеку PEAR. `Отдельная` или `независимая` сборка установит только демон `php-fpm` и минимум файлов, необходимых для его запуска.
+
+	# Посмотреть, какие файлы будут установлены
+	make install --dry-run
+
+	# Установить в '/'
+	sudo make install
+
+	# Установить в '/opt'
+	sudo INSTALL_ROOT=/opt make install
+
+Notes:
+
+* (Upgrade) When overwriting existing FPM installation files: A previous configuration file `php-fpm.conf` will be moved to `php-fpm.conf.old`. Then a newer (default) configuration file will be installed in it's place. If you have any custom XML settings which you wish to keep, its recommended to copy these back over manually.
+
+* (BSD) the default init.d path is `/usr/local/etc/rc.d/php-fpm` or disable: `--without-fpm-init`
+
+* (Nginx) An example nginx configuration file is generated. The file `nginx-site-conf.sample` may be installed into your nginx configuration directory, if exists: `/etc/nginx/`, `/usr/local/etc/nginx/`, or `/usr/local/nginx/conf`
+
+## Больше о процессе сборки PHP-FPM
+
+Процесс сборки можно описать так:
+
+	 1) Компилируются исходники php в объектные файлы
+	 2) Компилируются исходники fpm в объектные файлы
+	 3) Линковка php и fpm объектных файлов
+	 4) Результат: исполняемый php5, в основе которого php и fast-CGI от fpm как фронтэнд
+
+Fpm подмешивается в php при линковке (link-level). Андрей разделил исходный код fpm, сделав SAPI чем-то менее чуствительным к изменениям в остальном коде php. Код cgi-main.c из PHP-FPM - конктроллер запросов - вырезан из оригинального fcgi-sapi. Мы отправляем билд 0.6 в PHP Group. Мы будем отслеживать развитие PHP и периодически синхронизировать изменения с проектами встроенной / отдельной сборки.
+
+## Buildconf
+
+Для сборки fpm отдельно, конфигурирование (`./configure`) требует некоторой версии набора инструментов autoconf. Buildconf запустит `./generate-autotools` и попробует установить эти инструменты самостоятельно. Если `./buildconf` не работает, смотрите лог ошибок.
+
+
+## Обсуждение
+
+Есть 2 группы для обсуждения php-fpm,
+
+- [highload-php-ru](http://groups.google.com/group/highload-php-en) (english)
+
+- [highload-php-ru](http://groups.google.com/group/highload-php-ru) (русская)
+
+Translated by Anatoly Pashin
