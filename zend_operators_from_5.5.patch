--- php-5.4.41/Zend/zend_operators.h	2015-05-12 19:38:38.000000000 +0000
+++ php-5.5.25/Zend/zend_operators.h	2015-05-14 00:02:08.000000000 +0000
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | Zend Engine                                                          |
    +----------------------------------------------------------------------+
-   | Copyright (c) 1998-2014 Zend Technologies Ltd. (http://www.zend.com) |
+   | Copyright (c) 1998-2015 Zend Technologies Ltd. (http://www.zend.com) |
    +----------------------------------------------------------------------+
    | This source file is subject to version 2.00 of the Zend license,     |
    | that is bundled with this package in the file LICENSE, and is        |
@@ -26,6 +26,10 @@
 #include <math.h>
 #include <assert.h>
 
+#ifdef __GNUC__
+#include <stddef.h>
+#endif
+
 #ifdef HAVE_IEEEFP_H
 #include <ieeefp.h>
 #endif
@@ -474,6 +499,10 @@
 #define zend_update_current_locale()
 #endif
 
+/* The offset in bytes between the value and type fields of a zval */
+#define ZVAL_OFFSETOF_TYPE	\
+	(offsetof(zval,type) - offsetof(zval,value))
+
 static zend_always_inline int fast_increment_function(zval *op1)
 {
 	if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
@@ -483,20 +512,26 @@
 			"jno  0f\n\t"
 			"movl $0x0, (%0)\n\t"
 			"movl $0x41e00000, 0x4(%0)\n\t"
-			"movb $0x2,0xc(%0)\n"
+			"movb %1, %c2(%0)\n"
 			"0:"
 			:
-			: "r"(op1));
+			: "r"(&op1->value),
+			  "n"(IS_DOUBLE),
+			  "n"(ZVAL_OFFSETOF_TYPE)
+			: "cc");
 #elif defined(__GNUC__) && defined(__x86_64__)
 		__asm__(
 			"incq (%0)\n\t"
 			"jno  0f\n\t"
 			"movl $0x0, (%0)\n\t"
 			"movl $0x43e00000, 0x4(%0)\n\t"
-			"movb $0x2,0x14(%0)\n"
+			"movb %1, %c2(%0)\n"
 			"0:"
 			:
-			: "r"(op1));
+			: "r"(&op1->value),
+			  "n"(IS_DOUBLE),
+			  "n"(ZVAL_OFFSETOF_TYPE)
+			: "cc");
 #else
 		if (UNEXPECTED(Z_LVAL_P(op1) == LONG_MAX)) {
 			/* switch to double */
@@ -520,20 +555,26 @@
 			"jno  0f\n\t"
 			"movl $0x00200000, (%0)\n\t"
 			"movl $0xc1e00000, 0x4(%0)\n\t"
-			"movb $0x2,0xc(%0)\n"
+			"movb %1,%c2(%0)\n"
 			"0:"
 			:
-			: "r"(op1));
+			: "r"(&op1->value),
+			  "n"(IS_DOUBLE),
+			  "n"(ZVAL_OFFSETOF_TYPE)
+			: "cc");
 #elif defined(__GNUC__) && defined(__x86_64__)
 		__asm__(
 			"decq (%0)\n\t"
 			"jno  0f\n\t"
 			"movl $0x00000000, (%0)\n\t"
 			"movl $0xc3e00000, 0x4(%0)\n\t"
-			"movb $0x2,0x14(%0)\n"
+			"movb %1,%c2(%0)\n"
 			"0:"
 			:
-			: "r"(op1));
+			: "r"(&op1->value),
+			  "n"(IS_DOUBLE),
+			  "n"(ZVAL_OFFSETOF_TYPE)
+			: "cc");
 #else
 		if (UNEXPECTED(Z_LVAL_P(op1) == LONG_MIN)) {
 			/* switch to double */
@@ -558,40 +599,46 @@
 			"addl   (%2), %%eax\n\t"
 			"jo     0f\n\t"     
 			"movl   %%eax, (%0)\n\t"
-			"movb   $0x1,0xc(%0)\n\t"
+			"movb   %3, %c5(%0)\n\t"
 			"jmp    1f\n"
 			"0:\n\t"
 			"fildl	(%1)\n\t"
 			"fildl	(%2)\n\t"
 			"faddp	%%st, %%st(1)\n\t"
-			"movb   $0x2,0xc(%0)\n\t"
+			"movb   %4, %c5(%0)\n\t"
 			"fstpl	(%0)\n"
 			"1:"
 			: 
-			: "r"(result),
-			  "r"(op1),
-			  "r"(op2)
-			: "eax");
+			: "r"(&result->value),
+			  "r"(&op1->value),
+			  "r"(&op2->value),
+			  "n"(IS_LONG),
+			  "n"(IS_DOUBLE),
+			  "n"(ZVAL_OFFSETOF_TYPE)
+			: "eax","cc");
 #elif defined(__GNUC__) && defined(__x86_64__)
 		__asm__(
 			"movq	(%1), %%rax\n\t"
 			"addq   (%2), %%rax\n\t"
 			"jo     0f\n\t"     
 			"movq   %%rax, (%0)\n\t"
-			"movb   $0x1,0x14(%0)\n\t"
+			"movb   %3, %c5(%0)\n\t"
 			"jmp    1f\n"
 			"0:\n\t"
 			"fildq	(%1)\n\t"
 			"fildq	(%2)\n\t"
 			"faddp	%%st, %%st(1)\n\t"
-			"movb   $0x2,0x14(%0)\n\t"
+			"movb   %4, %c5(%0)\n\t"
 			"fstpl	(%0)\n"
 			"1:"
 			: 
-			: "r"(result),
-			  "r"(op1),
-			  "r"(op2)
-			: "rax");
+			: "r"(&result->value),
+			  "r"(&op1->value),
+			  "r"(&op2->value),
+			  "n"(IS_LONG),
+			  "n"(IS_DOUBLE),
+			  "n"(ZVAL_OFFSETOF_TYPE)
+			: "rax","cc");
 #else
 			/*
 			 * 'result' may alias with op1 or op2, so we need to
@@ -638,7 +685,7 @@
 			"subl   (%2), %%eax\n\t"
 			"jo     0f\n\t"     
 			"movl   %%eax, (%0)\n\t"
-			"movb   $0x1,0xc(%0)\n\t"
+			"movb   %3, %c5(%0)\n\t"
 			"jmp    1f\n"
 			"0:\n\t"
 			"fildl	(%2)\n\t"
@@ -648,21 +695,24 @@
 #else
 			"fsubp	%%st, %%st(1)\n\t"
 #endif
-			"movb   $0x2,0xc(%0)\n\t"
+			"movb   %4, %c5(%0)\n\t"
 			"fstpl	(%0)\n"
 			"1:"
 			: 
-			: "r"(result),
-			  "r"(op1),
-			  "r"(op2)
-			: "eax");
+			: "r"(&result->value),
+			  "r"(&op1->value),
+			  "r"(&op2->value),
+			  "n"(IS_LONG),
+			  "n"(IS_DOUBLE),
+			  "n"(ZVAL_OFFSETOF_TYPE)
+			: "eax","cc");
 #elif defined(__GNUC__) && defined(__x86_64__)
 		__asm__(
 			"movq	(%1), %%rax\n\t"
 			"subq   (%2), %%rax\n\t"
 			"jo     0f\n\t"     
 			"movq   %%rax, (%0)\n\t"
-			"movb   $0x1,0x14(%0)\n\t"
+			"movb   %3, %c5(%0)\n\t"
 			"jmp    1f\n"
 			"0:\n\t"
 			"fildq	(%2)\n\t"
@@ -672,14 +722,17 @@
 #else
 			"fsubp	%%st, %%st(1)\n\t"
 #endif
-			"movb   $0x2,0x14(%0)\n\t"
+			"movb   %4, %c5(%0)\n\t"
 			"fstpl	(%0)\n"
 			"1:"
 			: 
-			: "r"(result),
-			  "r"(op1),
-			  "r"(op2)
-			: "rax");
+			: "r"(&result->value),
+			  "r"(&op1->value),
+			  "r"(&op2->value),
+			  "n"(IS_LONG),
+			  "n"(IS_DOUBLE),
+			  "n"(ZVAL_OFFSETOF_TYPE)
+			: "rax","cc");
 #else
 			Z_LVAL_P(result) = Z_LVAL_P(op1) - Z_LVAL_P(op2);
 
