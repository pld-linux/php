--- php-5.4.41/Zend/zend_operators.h	2015-05-12 19:38:38.000000000 +0000
+++ php-5.5.25/Zend/zend_operators.h	2015-05-14 00:02:08.000000000 +0000
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | Zend Engine                                                          |
    +----------------------------------------------------------------------+
-   | Copyright (c) 1998-2014 Zend Technologies Ltd. (http://www.zend.com) |
+   | Copyright (c) 1998-2015 Zend Technologies Ltd. (http://www.zend.com) |
    +----------------------------------------------------------------------+
    | This source file is subject to version 2.00 of the Zend license,     |
    | that is bundled with this package in the file LICENSE, and is        |
@@ -26,6 +26,10 @@
 #include <math.h>
 #include <assert.h>
 
+#ifdef __GNUC__
+#include <stddef.h>
+#endif
+
 #ifdef HAVE_IEEEFP_H
 #include <ieeefp.h>
 #endif
@@ -68,22 +72,40 @@
 
 #if ZEND_DVAL_TO_LVAL_CAST_OK
 # define zend_dval_to_lval(d) ((long) (d))
-#elif SIZEOF_LONG == 4 && defined(HAVE_ZEND_LONG64)
+#elif SIZEOF_LONG == 4
 static zend_always_inline long zend_dval_to_lval(double d)
 {
 	if (d > LONG_MAX || d < LONG_MIN) {
-		return (long)(unsigned long)(zend_long64) d;
+		double	two_pow_32 = pow(2., 32.),
+				dmod;
+
+		dmod = fmod(d, two_pow_32);
+		if (dmod < 0) {
+			/* we're going to make this number positive; call ceil()
+			 * to simulate rounding towards 0 of the negative number */
+			dmod = ceil(dmod) + two_pow_32;
+		}
+		return (long)(unsigned long)dmod;
 	}
-	return (long) d;
+	return (long)d;
 }
 #else
 static zend_always_inline long zend_dval_to_lval(double d)
 {
 	/* >= as (double)LONG_MAX is outside signed range */
-	if (d >= LONG_MAX) {
-		return (long)(unsigned long) d;
+	if (d >= LONG_MAX || d < LONG_MIN) {
+		double	two_pow_64 = pow(2., 64.),
+				dmod;
+
+		dmod = fmod(d, two_pow_64);
+		if (dmod < 0) {
+			/* no need to call ceil; original double must have had no
+			 * fractional part, hence dmod does not have one either */
+			dmod += two_pow_64;
+		}
+		return (long)(unsigned long)dmod;
 	}
-	return (long) d;
+	return (long)d;
 }
 #endif
 /* }}} */
@@ -110,7 +132,7 @@
 {
 	const char *ptr;
 	int base = 10, digits = 0, dp_or_e = 0;
-	double local_dval;
+	double local_dval = 0.0;
 	zend_uchar type;
 
 	if (!length) {
@@ -302,6 +324,7 @@
 ZEND_API int decrement_function(zval *op2);
 
 ZEND_API void convert_scalar_to_number(zval *op TSRMLS_DC);
+ZEND_API void _convert_to_cstring(zval *op ZEND_FILE_LINE_DC);
 ZEND_API void _convert_to_string(zval *op ZEND_FILE_LINE_DC);
 ZEND_API void convert_to_long(zval *op);
 ZEND_API void convert_to_double(zval *op);
@@ -315,6 +338,7 @@
 ZEND_API void multi_convert_to_string_ex(int argc, ...);
 ZEND_API int add_char_to_string(zval *result, const zval *op1, const zval *op2);
 ZEND_API int add_string_to_string(zval *result, const zval *op1, const zval *op2);
+#define convert_to_cstring(op) if ((op)->type != IS_STRING) { _convert_to_cstring((op) ZEND_FILE_LINE_CC); }
 #define convert_to_string(op) if ((op)->type != IS_STRING) { _convert_to_string((op) ZEND_FILE_LINE_CC); }
 
 ZEND_API double zend_string_to_double(const char *number, zend_uint length);
@@ -341,6 +365,7 @@
 ZEND_API int zend_binary_strncmp(const char *s1, uint len1, const char *s2, uint len2, uint length);
 ZEND_API int zend_binary_strcasecmp(const char *s1, uint len1, const char *s2, uint len2);
 ZEND_API int zend_binary_strncasecmp(const char *s1, uint len1, const char *s2, uint len2, uint length);
+ZEND_API int zend_binary_strncasecmp_l(const char *s1, uint len1, const char *s2, uint len2, uint length);
 
 ZEND_API void zendi_smart_strcmp(zval *result, zval *s1, zval *s2);
 ZEND_API void zend_compare_symbol_tables(zval *result, HashTable *ht1, HashTable *ht2 TSRMLS_DC);
@@ -474,6 +499,10 @@
 #define zend_update_current_locale()
 #endif
 
+/* The offset in bytes between the value and type fields of a zval */
+#define ZVAL_OFFSETOF_TYPE	\
+	(offsetof(zval,type) - offsetof(zval,value))
+
 static zend_always_inline int fast_increment_function(zval *op1)
 {
 	if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
@@ -483,20 +512,26 @@
 			"jno  0f\n\t"
 			"movl $0x0, (%0)\n\t"
 			"movl $0x41e00000, 0x4(%0)\n\t"
-			"movb $0x2,0xc(%0)\n"
+			"movb %1, %c2(%0)\n"
 			"0:"
 			:
-			: "r"(op1));
+			: "r"(&op1->value),
+			  "n"(IS_DOUBLE),
+			  "n"(ZVAL_OFFSETOF_TYPE)
+			: "cc");
 #elif defined(__GNUC__) && defined(__x86_64__)
 		__asm__(
 			"incq (%0)\n\t"
 			"jno  0f\n\t"
 			"movl $0x0, (%0)\n\t"
 			"movl $0x43e00000, 0x4(%0)\n\t"
-			"movb $0x2,0x14(%0)\n"
+			"movb %1, %c2(%0)\n"
 			"0:"
 			:
-			: "r"(op1));
+			: "r"(&op1->value),
+			  "n"(IS_DOUBLE),
+			  "n"(ZVAL_OFFSETOF_TYPE)
+			: "cc");
 #else
 		if (UNEXPECTED(Z_LVAL_P(op1) == LONG_MAX)) {
 			/* switch to double */
@@ -520,20 +555,26 @@
 			"jno  0f\n\t"
 			"movl $0x00200000, (%0)\n\t"
 			"movl $0xc1e00000, 0x4(%0)\n\t"
-			"movb $0x2,0xc(%0)\n"
+			"movb %1,%c2(%0)\n"
 			"0:"
 			:
-			: "r"(op1));
+			: "r"(&op1->value),
+			  "n"(IS_DOUBLE),
+			  "n"(ZVAL_OFFSETOF_TYPE)
+			: "cc");
 #elif defined(__GNUC__) && defined(__x86_64__)
 		__asm__(
 			"decq (%0)\n\t"
 			"jno  0f\n\t"
 			"movl $0x00000000, (%0)\n\t"
 			"movl $0xc3e00000, 0x4(%0)\n\t"
-			"movb $0x2,0x14(%0)\n"
+			"movb %1,%c2(%0)\n"
 			"0:"
 			:
-			: "r"(op1));
+			: "r"(&op1->value),
+			  "n"(IS_DOUBLE),
+			  "n"(ZVAL_OFFSETOF_TYPE)
+			: "cc");
 #else
 		if (UNEXPECTED(Z_LVAL_P(op1) == LONG_MIN)) {
 			/* switch to double */
@@ -558,40 +599,46 @@
 			"addl   (%2), %%eax\n\t"
 			"jo     0f\n\t"     
 			"movl   %%eax, (%0)\n\t"
-			"movb   $0x1,0xc(%0)\n\t"
+			"movb   %3, %c5(%0)\n\t"
 			"jmp    1f\n"
 			"0:\n\t"
 			"fildl	(%1)\n\t"
 			"fildl	(%2)\n\t"
 			"faddp	%%st, %%st(1)\n\t"
-			"movb   $0x2,0xc(%0)\n\t"
+			"movb   %4, %c5(%0)\n\t"
 			"fstpl	(%0)\n"
 			"1:"
 			: 
-			: "r"(result),
-			  "r"(op1),
-			  "r"(op2)
-			: "eax");
+			: "r"(&result->value),
+			  "r"(&op1->value),
+			  "r"(&op2->value),
+			  "n"(IS_LONG),
+			  "n"(IS_DOUBLE),
+			  "n"(ZVAL_OFFSETOF_TYPE)
+			: "eax","cc");
 #elif defined(__GNUC__) && defined(__x86_64__)
 		__asm__(
 			"movq	(%1), %%rax\n\t"
 			"addq   (%2), %%rax\n\t"
 			"jo     0f\n\t"     
 			"movq   %%rax, (%0)\n\t"
-			"movb   $0x1,0x14(%0)\n\t"
+			"movb   %3, %c5(%0)\n\t"
 			"jmp    1f\n"
 			"0:\n\t"
 			"fildq	(%1)\n\t"
 			"fildq	(%2)\n\t"
 			"faddp	%%st, %%st(1)\n\t"
-			"movb   $0x2,0x14(%0)\n\t"
+			"movb   %4, %c5(%0)\n\t"
 			"fstpl	(%0)\n"
 			"1:"
 			: 
-			: "r"(result),
-			  "r"(op1),
-			  "r"(op2)
-			: "rax");
+			: "r"(&result->value),
+			  "r"(&op1->value),
+			  "r"(&op2->value),
+			  "n"(IS_LONG),
+			  "n"(IS_DOUBLE),
+			  "n"(ZVAL_OFFSETOF_TYPE)
+			: "rax","cc");
 #else
 			/*
 			 * 'result' may alias with op1 or op2, so we need to
@@ -638,7 +685,7 @@
 			"subl   (%2), %%eax\n\t"
 			"jo     0f\n\t"     
 			"movl   %%eax, (%0)\n\t"
-			"movb   $0x1,0xc(%0)\n\t"
+			"movb   %3, %c5(%0)\n\t"
 			"jmp    1f\n"
 			"0:\n\t"
 			"fildl	(%2)\n\t"
@@ -648,21 +695,24 @@
 #else
 			"fsubp	%%st, %%st(1)\n\t"
 #endif
-			"movb   $0x2,0xc(%0)\n\t"
+			"movb   %4, %c5(%0)\n\t"
 			"fstpl	(%0)\n"
 			"1:"
 			: 
-			: "r"(result),
-			  "r"(op1),
-			  "r"(op2)
-			: "eax");
+			: "r"(&result->value),
+			  "r"(&op1->value),
+			  "r"(&op2->value),
+			  "n"(IS_LONG),
+			  "n"(IS_DOUBLE),
+			  "n"(ZVAL_OFFSETOF_TYPE)
+			: "eax","cc");
 #elif defined(__GNUC__) && defined(__x86_64__)
 		__asm__(
 			"movq	(%1), %%rax\n\t"
 			"subq   (%2), %%rax\n\t"
 			"jo     0f\n\t"     
 			"movq   %%rax, (%0)\n\t"
-			"movb   $0x1,0x14(%0)\n\t"
+			"movb   %3, %c5(%0)\n\t"
 			"jmp    1f\n"
 			"0:\n\t"
 			"fildq	(%2)\n\t"
@@ -672,14 +722,17 @@
 #else
 			"fsubp	%%st, %%st(1)\n\t"
 #endif
-			"movb   $0x2,0x14(%0)\n\t"
+			"movb   %4, %c5(%0)\n\t"
 			"fstpl	(%0)\n"
 			"1:"
 			: 
-			: "r"(result),
-			  "r"(op1),
-			  "r"(op2)
-			: "rax");
+			: "r"(&result->value),
+			  "r"(&op1->value),
+			  "r"(&op2->value),
+			  "n"(IS_LONG),
+			  "n"(IS_DOUBLE),
+			  "n"(ZVAL_OFFSETOF_TYPE)
+			: "rax","cc");
 #else
 			Z_LVAL_P(result) = Z_LVAL_P(op1) - Z_LVAL_P(op2);
 
--- php-5.4.41/Zend/zend_operators.c	2015-05-12 19:38:38.000000000 +0000
+++ php-5.5.25/Zend/zend_operators.c	2015-05-14 00:02:08.000000000 +0000
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | Zend Engine                                                          |
    +----------------------------------------------------------------------+
-   | Copyright (c) 1998-2014 Zend Technologies Ltd. (http://www.zend.com) |
+   | Copyright (c) 1998-2015 Zend Technologies Ltd. (http://www.zend.com) |
    +----------------------------------------------------------------------+
    | This source file is subject to version 2.00 of the Zend license,     |
    | that is bundled with this package in the file LICENSE, and is        |
@@ -42,6 +42,43 @@
 
 #define TYPE_PAIR(t1,t2) (((t1) << 4) | (t2))
 
+static const unsigned char tolower_map[256] = {
+0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
+0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
+0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
+0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
+0x40,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
+0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x5b,0x5c,0x5d,0x5e,0x5f,
+0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
+0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
+0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
+0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
+0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
+0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
+0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
+0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
+0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
+0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
+};
+
+#define zend_tolower_ascii(c) (tolower_map[(unsigned char)(c)])
+
+/**
+ * Functions using locale lowercase:
+ 	 	zend_binary_strncasecmp_l
+ 	 	zend_binary_strcasecmp_l
+		zend_binary_zval_strcasecmp
+		zend_binary_zval_strncasecmp
+		string_compare_function_ex
+		string_case_compare_function
+ * Functions using ascii lowercase:
+  		zend_str_tolower_copy
+		zend_str_tolower_dup
+		zend_str_tolower
+		zend_binary_strcasecmp
+		zend_binary_strncasecmp
+ */
+
 ZEND_API int zend_atoi(const char *str, int str_len) /* {{{ */
 {
 	int retval;
@@ -535,6 +572,24 @@
 }
 /* }}} */
 
+ZEND_API void _convert_to_cstring(zval *op ZEND_FILE_LINE_DC) /* {{{ */
+{
+	double dval;
+	switch (Z_TYPE_P(op)) {
+		case IS_DOUBLE: {
+			TSRMLS_FETCH();
+			dval = Z_DVAL_P(op);
+			Z_STRLEN_P(op) = zend_spprintf(&Z_STRVAL_P(op), 0, "%.*H", (int) EG(precision), dval);
+			/* %H already handles removing trailing zeros from the fractional part, yay */
+			break;
+		}
+		default:
+			_convert_to_string(op ZEND_FILE_LINE_CC);
+	}
+	Z_TYPE_P(op) = IS_STRING;
+}
+/* }}} */
+
 ZEND_API void _convert_to_string(zval *op ZEND_FILE_LINE_DC) /* {{{ */
 {
 	long lval;
@@ -1916,7 +1971,7 @@
 	register unsigned char *end = str + length;
 
 	while (str < end) {
-		*result++ = zend_tolower((int)*str++);
+		*result++ = zend_tolower_ascii(*str++);
 	}
 	*result = '\0';
 
@@ -1936,7 +1991,7 @@
 	register unsigned char *end = p + length;
 
 	while (p < end) {
-		*p = zend_tolower((int)*p);
+		*p = zend_tolower_ascii(*p);
 		p++;
 	}
 }
@@ -1985,6 +2040,49 @@
 
 	len = MIN(len1, len2);
 	while (len--) {
+		c1 = zend_tolower_ascii(*(unsigned char *)s1++);
+		c2 = zend_tolower_ascii(*(unsigned char *)s2++);
+		if (c1 != c2) {
+			return c1 - c2;
+		}
+	}
+
+	return len1 - len2;
+}
+/* }}} */
+
+ZEND_API int zend_binary_strncasecmp(const char *s1, uint len1, const char *s2, uint len2, uint length) /* {{{ */
+{
+	int len;
+	int c1, c2;
+
+	if (s1 == s2) {
+		return 0;
+	}
+	len = MIN(length, MIN(len1, len2));
+	while (len--) {
+		c1 = zend_tolower_ascii(*(unsigned char *)s1++);
+		c2 = zend_tolower_ascii(*(unsigned char *)s2++);
+		if (c1 != c2) {
+			return c1 - c2;
+		}
+	}
+
+	return MIN(length, len1) - MIN(length, len2);
+}
+/* }}} */
+
+ZEND_API int zend_binary_strcasecmp_l(const char *s1, uint len1, const char *s2, uint len2) /* {{{ */
+{
+	int len;
+	int c1, c2;
+
+	if (s1 == s2) {
+		return 0;
+	}
+
+	len = MIN(len1, len2);
+	while (len--) {
 		c1 = zend_tolower((int)*(unsigned char *)s1++);
 		c2 = zend_tolower((int)*(unsigned char *)s2++);
 		if (c1 != c2) {
@@ -1996,7 +2094,7 @@
 }
 /* }}} */
 
-ZEND_API int zend_binary_strncasecmp(const char *s1, uint len1, const char *s2, uint len2, uint length) /* {{{ */
+ZEND_API int zend_binary_strncasecmp_l(const char *s1, uint len1, const char *s2, uint len2, uint length) /* {{{ */
 {
 	int len;
 	int c1, c2;
@@ -2031,13 +2129,13 @@
 
 ZEND_API int zend_binary_zval_strcasecmp(zval *s1, zval *s2) /* {{{ */
 {
-	return zend_binary_strcasecmp(Z_STRVAL_P(s1), Z_STRLEN_P(s1), Z_STRVAL_P(s2), Z_STRLEN_P(s2));
+	return zend_binary_strcasecmp_l(Z_STRVAL_P(s1), Z_STRLEN_P(s1), Z_STRVAL_P(s2), Z_STRLEN_P(s2));
 }
 /* }}} */
 
 ZEND_API int zend_binary_zval_strncasecmp(zval *s1, zval *s2, zval *s3) /* {{{ */
 {
-	return zend_binary_strncasecmp(Z_STRVAL_P(s1), Z_STRLEN_P(s1), Z_STRVAL_P(s2), Z_STRLEN_P(s2), Z_LVAL_P(s3));
+	return zend_binary_strncasecmp_l(Z_STRVAL_P(s1), Z_STRLEN_P(s1), Z_STRVAL_P(s2), Z_STRLEN_P(s2), Z_LVAL_P(s3));
 }
 /* }}} */
 
@@ -2045,8 +2143,8 @@
 {
 	int ret1, ret2;
 	int oflow1, oflow2;
-	long lval1, lval2;
-	double dval1, dval2;
+	long lval1 = 0, lval2 = 0;
+	double dval1 = 0.0, dval2 = 0.0;
 
 	if ((ret1=is_numeric_string_ex(Z_STRVAL_P(s1), Z_STRLEN_P(s1), &lval1, &dval1, 0, &oflow1)) &&
 		(ret2=is_numeric_string_ex(Z_STRVAL_P(s2), Z_STRLEN_P(s2), &lval2, &dval2, 0, &oflow2))) {
